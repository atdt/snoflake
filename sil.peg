// PEG.js Grammar for SIL (SNOBOL Implementation Language)
// (C) Copyright 2012 by Ori Livneh
// Released under GPL and MIT licenses
{
    var macros = {},
        labels = [],
        stack = [],
        index = 0;

    function stackPush(call) {
        return ["call", ["dot", ["name", "stack"], "push"], [call]];
    }

    var expansions = {
        'EQU': function (label, operands) {
            console.log(operands);
            return ["var", [[label[1], operands[0]]]];
        }
    };
}

program
  = lines:(statement / comment)+ end
{
    var statement,
        program = [];

    for (var i = 0, max = lines.length; i < max; i++) {
        statement = lines[i];

        // Skip comments
        if (typeof statement === 'string') {
            continue;
        }

        stack.push(statement.call);
        macros[statement.macro] = (macros[statement.macro] || 0) + 1;

        if (statement.label) {
            labels.push([statement.label, ["num", stack.length - 1]]);
        }
    }

    macros = Object.keys(macros).map(function (e) { return [e]; });

    program.push(["var", macros]);
    program.push(["var", labels]);
    program.push(["var", [["stack", ["array", stack]]]]);
    // program.push(["var", ["stack", ["array", stack]]]);

    return ["toplevel", program];
}


comment
  = '*' comment:[^\n]* '\n'
{
    return comment.join('');
}

statement
  = label:name? blank oper:name blank operands:operands blank? comment:[^\n]* '\n'
{
    return {
        label : label ? label[1] : undefined,
        macro : oper[1],
        call  : ["array", [oper, operands]],
    }


    
    macros[macro] = 1;
    /*
    if (macro in expansions) {
        var expand = expansions[macro];
        return expand(label || undefined, operands);
    }
    */

    if (label) {
        return ["var", [[label, stmt]]];
    } else {
        return ["stat", stmt];
    }
}

operands
  = head:variable tail:(',' variable)*
{
    var result = [head];
    for (var i = 0, max = tail.length; i < max; i++) {
        result.push(tail[i][1]);
    }
    return ["array", result];
}

variable
  = list
  / literal
  / expr
  / name
  / integer
  / &(',') { return ["name", "undefined"]; }


expr
  = left:(integer / name) operator:[*+-] right:(integer / name)
{
    return ["binary", operator, left, right];
}

literal "literal"
  = "'" literal:[^']* "'"
{
    return ["string", literal.join('')];
}

integer "integer"
  = digits:[0-9]+
{
    return ["num", parseInt(digits.join(''), 10)];
}

list "operand list"
  = '(' head:variable tail:(',' variable)* ')'
{
    var result = [head];
    for (var i = 0, max = tail.length; i < max; i++) {
        result.push(tail[i][1]);
    }
    return ["array", result];
}

blank
  = [\u0009\u0020]+


name "name"
  = head:[A-Z] tail:[A-Z0-9]*
{
    tail.unshift(head);
    return ["name", tail.join('')];
}

end
  = blank 'END' (blank / '\n')* !.

/* vim: set ft=javascript: */
