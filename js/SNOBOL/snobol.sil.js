// This file was automatically generated by src/translate.js.
var SNOBOL = require( './base' );
SNOBOL.interp = function (vm) {
  return [[null, "TITLE", function () {
    return ["Table of Contents"];
  }, ""], [null, "TITLE", function () {
    return ["Linkage and Equivalences"];
  }, ""], [null, "COPY", function () {
    return [vm.$("MLINK")];
  }, "Linkage segment"], [null, "COPY", function () {
    return [vm.$("PARMS")];
  }, "Machine-dependent parameters"], ["ATTRIB", "EQU", function () {
    return [2 * vm.$("DESCR")];
  }, "Offset of label in string structure"], ["LNKFLD", "EQU", function () {
    return [3 * vm.$("DESCR")];
  }, "Offset of link in string structure"], ["BCDFLD", "EQU", function () {
    return [4 * vm.$("DESCR")];
  }, "Offset of string in string structure"], ["FATHER", "EQU", function () {
    return [vm.$("DESCR")];
  }, "Offset of father in code node"], ["LSON", "EQU", function () {
    return [2 * vm.$("DESCR")];
  }, "Offset of left son in code node"], ["RSIB", "EQU", function () {
    return [3 * vm.$("DESCR")];
  }, "Offset of right sibling in code node"], ["CODE", "EQU", function () {
    return [4 * vm.$("DESCR")];
  }, "Offset of code in code node"], ["ESASIZ", "EQU", function () {
    return [50];
  }, "Limit on number of syntactic errors"], ["FBLKSZ", "EQU", function () {
    return [10 * vm.$("DESCR")];
  }, "Size of function descriptor block"], ["ARRLEN", "EQU", function () {
    return [20];
  }, "Limit on length of array print image"], ["CARDSZ", "EQU", function () {
    return [80];
  }, "Width of compiler input"], ["SEQSIZ", "EQU", function () {
    return [8];
  }, "Width of sequence field"], ["STNOSZ", "EQU", function () {
    return [8];
  }, "Length of statement number field"], ["DSTSZ", "EQU", function () {
    return [2 * vm.$("STNOSZ")];
  }, "Space for left and right numbering"], ["CNODSZ", "EQU", function () {
    return [4 * vm.$("DESCR")];
  }, "Size of code node"], ["DATSIZ", "EQU", function () {
    return [1000];
  }, "Limit on number of defined data type"], ["EXTSIZ", "EQU", function () {
    return [10];
  }, "Default allocation for tables"], ["NAMLSZ", "EQU", function () {
    return [20];
  }, "Growth quantum for name list"], ["NODESZ", "EQU", function () {
    return [3 * vm.$("DESCR")];
  }, "Size of pattern node"], ["OBSIZ", "EQU", function () {
    return [256];
  }, "Number of bin headers"], ["OBARY", "EQU", function () {
    return [vm.$("OBSIZ") + 3];
  }, "Total number for bins"], ["OCASIZ", "EQU", function () {
    return [1500];
  }, "Descriptors of initial object code"], ["SPDLSZ", "EQU", function () {
    return [1000];
  }, "Descriptors of pattern stack"], ["STSIZE", "EQU", function () {
    return [1000];
  }, "Descriptors of interpreter stack"], ["SPDR", "EQU", function () {
    return [vm.$("SPEC") + vm.$("DESCR")];
  }, "Descriptor plus specifier"], ["OBOFF", "EQU", function () {
    return [vm.$("OBSIZ") - 2];
  }, "Offset length in bins"], ["SPDLDR", "EQU", function () {
    return [vm.$("SPDLSZ") * vm.$("DESCR")];
  }, "Size of pattern stack"], ["ARYTYP", "EQU", function () {
    return [7];
  }, "Array reference"], ["CLNTYP", "EQU", function () {
    return [5];
  }, "Goto field"], ["CMATYP", "EQU", function () {
    return [2];
  }, "Comma"], ["CMTTYP", "EQU", function () {
    return [2];
  }, "Comment card"], ["CNTTYP", "EQU", function () {
    return [4];
  }, "Continue card"], ["CTLTYP", "EQU", function () {
    return [3];
  }, "Control card"], ["DIMTYP", "EQU", function () {
    return [1];
  }, "Dimension separator"], ["EOSTYP", "EQU", function () {
    return [6];
  }, "End of statement"], ["EQTYP", "EQU", function () {
    return [4];
  }, "Equal sign"], ["FGOTYP", "EQU", function () {
    return [3];
  }, "Failure goto"], ["FTOTYP", "EQU", function () {
    return [6];
  }, "Failure direct goto"], ["FLITYP", "EQU", function () {
    return [6];
  }, "Literal real"], ["FNCTYP", "EQU", function () {
    return [5];
  }, "Function call"], ["ILITYP", "EQU", function () {
    return [2];
  }, "Literal integer"], ["LPTYP", "EQU", function () {
    return [1];
  }, "Left parenthesis"], ["NBTYP", "EQU", function () {
    return [1];
  }, "Nonbreak character"], ["NEWTYP", "EQU", function () {
    return [1];
  }, "New statement"], ["NSTTYP", "EQU", function () {
    return [4];
  }, "Parenthesized expression"], ["QLITYP", "EQU", function () {
    return [1];
  }, "Quoted literal"], ["RBTYP", "EQU", function () {
    return [7];
  }, "Right bracket"], ["RPTYP", "EQU", function () {
    return [3];
  }, "Right parenthesis"], ["SGOTYP", "EQU", function () {
    return [2];
  }, "Success goto"], ["STOTYP", "EQU", function () {
    return [5];
  }, "Success direct goto"], ["UGOTYP", "EQU", function () {
    return [1];
  }, "Unconditional goto"], ["UTOTYP", "EQU", function () {
    return [4];
  }, "Unconditional direct goto"], ["VARTYP", "EQU", function () {
    return [3];
  }, "Variable"], ["A", "EQU", function () {
    return [4];
  }, "ARRAY"], ["B", "EQU", function () {
    return [2];
  }, "BLOCK (internal)"], ["C", "EQU", function () {
    return [8];
  }, "CODE"], ["E", "EQU", function () {
    return [11];
  }, "EXPRESSION"], ["I", "EQU", function () {
    return [6];
  }, "INTEGER"], ["K", "EQU", function () {
    return [10];
  }, "KEYWORD (NAME)"], ["L", "EQU", function () {
    return [12];
  }, "LINKED STRING (internal)"], ["N", "EQU", function () {
    return [9];
  }, "NAME"], ["P", "EQU", function () {
    return [3];
  }, "PATTERN"], ["R", "EQU", function () {
    return [7];
  }, "REAL"], ["S", "EQU", function () {
    return [1];
  }, "STRING"], ["T", "EQU", function () {
    return [5];
  }, "TABLE"], [null, "TITLE", function () {
    return ["Program Initialization"];
  }, ""], ["BEGIN", "INIT", function () {
    return [null];
  }, "Initialize system"], [null, "ISTACK", function () {
    return [null];
  }, "Initialize stack"], [null, "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("TITLEF")];
  }, "Title listing"], [null, "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("SOURCF")];
  }, "Print attribution"], [null, "MSTIME", function () {
    return [vm.$("TIMECL")];
  }, "Time in compiler"], [null, "RCALL", function () {
    return [vm.$("SCBSCL"), vm.$("BLOCK"), vm.$("OCALIM")];
  }, "Allocate block for object code"], [null, "MOVD", function () {
    return [vm.$("OCSVCL"), vm.$("SCBSCL")];
  }, "Save object code pointer"], [null, "RESETF", function () {
    return [vm.$("SCBSCL"), vm.$("PTR")];
  }, "Clear pointer flag"], [null, "GETSIZ", function () {
    return [vm.$("YCL"), vm.$("INITLS")];
  }, "Get size of initialization list"], ["SPCNVT", "GETD", function () {
    return [vm.$("XPTR"), vm.$("INITLS"), vm.$("YCL")];
  }, "Get pointer to list"], [null, "GETSIZ", function () {
    return [vm.$("XCL"), vm.$("XPTR")];
  }, "Get size of list"], ["SPCNV1", "GETD", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("XCL")];
  }, "Get pointer to specifier"], [null, "AEQLC", function () {
    return [vm.$("ZPTR"), 0, null, vm.$("SPCNV2")];
  }, "Skip dummy zero entries"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("GENVAR"), vm.$("ZPTR")];
  }, "Convert specifier to structure"], [null, "PUTD", function () {
    return [vm.$("XPTR"), vm.$("XCL"), vm.$("ZPTR")];
  }, "Replace pointer to specifier"], ["SPCNV2", "DECRA", function () {
    return [vm.$("XCL"), 2 * vm.$("DESCR")];
  }, "Decrement to next pair"], [null, "ACOMPC", function () {
    return [vm.$("XCL"), 0, vm.$("SPCNV1")];
  }, "Continue if one remains"], [null, "DECRA", function () {
    return [vm.$("YCL"), vm.$("DESCR")];
  }, "Decrement to next list"], [null, "ACOMPC", function () {
    return [vm.$("YCL"), 0, vm.$("SPCNVT")];
  }, "Continue if one remains"], ["INITD1", "GETDC", function () {
    return [vm.$("XPTR"), vm.$("INITB"), 0];
  }, "Get specifier to convert"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("GENVAR"), [vm.$("XPTR")]];
  }, "Convert it to string structure"], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("INITB"), vm.$("DESCR")];
  }, "Get location to put it"], [null, "PUTDC", function () {
    return [vm.$("ZPTR"), 0, vm.$("YPTR")];
  }, "Place pointer to string structure"], [null, "INCRA", function () {
    return [vm.$("INITB"), 2 * vm.$("DESCR")];
  }, "Decrement to next pair"], [null, "ACOMP", function () {
    return [vm.$("INITB"), vm.$("INITE"), null, null, vm.$("INITD1")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("ABRTKY"), vm.$("DESCR"), vm.$("ABOPAT")];
  }, "Initial value of ABORT"], [null, "PUTDC", function () {
    return [vm.$("ARBKY"), vm.$("DESCR"), vm.$("ARBPAT")];
  }, "Initial value of ARB"], [null, "PUTDC", function () {
    return [vm.$("BALKY"), vm.$("DESCR"), vm.$("BALPAT")];
  }, "Initial value of BAL"], [null, "PUTDC", function () {
    return [vm.$("FAILKY"), vm.$("DESCR"), vm.$("FALPAT")];
  }, "Initial value of FAIL"], [null, "PUTDC", function () {
    return [vm.$("FNCEKY"), vm.$("DESCR"), vm.$("FNCPAT")];
  }, "Initial value of FENCE"], [null, "PUTDC", function () {
    return [vm.$("REMKY"), vm.$("DESCR"), vm.$("REMPAT")];
  }, "Initial value of REM"], [null, "PUTDC", function () {
    return [vm.$("SUCCKY"), vm.$("DESCR"), vm.$("SUCPAT")];
  }, "Initial value of SUCCEED"], [null, "SETAC", function () {
    return [vm.$("VARSYM"), 0];
  }, "Set count of variables to zero"], [null, "RCALL", function () {
    return [vm.$("NBSPTR"), vm.$("BLOCK"), vm.$("NMOVER")];
  }, "Allocate block for value assignment"], [null, "MOVD", function () {
    return [vm.$("CMBSCL"), vm.$("SCBSCL")];
  }, "Set up pointer for compiler"], [null, "MOVD", function () {
    return [vm.$("UNIT"), vm.$("INPUT")];
  }, "Set up input unit"], [null, "MOVD", function () {
    return [vm.$("OCBSCL"), vm.$("CMBSCL")];
  }, "Project base for interpreter"], [null, "SUM", function () {
    return [vm.$("OCLIM"), vm.$("CMBSCL"), vm.$("OCALIM")];
  }, "Compute end of code block"], [null, "DECRA", function () {
    return [vm.$("OCLIM"), 5 * vm.$("DESCR")];
  }, "Leave room for overflow"], [null, "SETAC", function () {
    return [vm.$("INICOM"), 1];
  }, "SIGNAL COMPLETION\t\tE3.10.6"], [null, "BRANCH", function () {
    return [vm.$("XLATRN")];
  }, ""], [null, "TITLE", function () {
    return ["Compilation and Interpreter Invocation"];
  }, ""], ["XLATRD", "AEQLC", function () {
    return [vm.$("LISTCL"), 0, null, vm.$("XLATRN")];
  }, "Skip print if list is off"], [null, "STPRNT", function () {
    return [vm.$("IOKEY"), vm.$("OUTBLK"), vm.$("LNBFSP")];
  }, "Print line image"], ["XLATRN", "STREAD", function () {
    return [vm.$("INBFSP"), vm.$("UNIT"), vm.$("XLATRN"), vm.$("COMP5")];
  }, ""], [null, "SETSP", function () {
    return [vm.$("TEXTSP"), vm.$("NEXTSP")];
  }, "Read card and set up line"], [null, "STREAM", function () {
    return [vm.$("XSP"), vm.$("TEXTSP"), vm.$("CARDTB"), vm.$("COMP3"), vm.$("COMP3")];
  }, ""], [null, "RCALL", function () {
    return [null, vm.$("NEWCRD"), null];
  }, "(XLATRD,,) Process card type"], ["XLATNX", "RCALL", function () {
    return [null, vm.$("CMPILE"), null, [vm.$("COMP3"), null, vm.$("XLATNX")]];
  }, ""], [null, "INCRA", function () {
    return [vm.$("CMOFCL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "PUTD", function () {
    return [vm.$("CMBSCL"), vm.$("CMOFCL"), vm.$("ENDCL")];
  }, "Insert END function"], [null, "AEQLC", function () {
    return [vm.$("LISTCL"), 0, null, vm.$("XLATP")];
  }, "Skip print if list is off"], [null, "STPRNT", function () {
    return [vm.$("IOKEY"), vm.$("OUTBLK"), vm.$("LNBFSP")];
  }, "Print last line image"], ["XLATP", "AEQLC", function () {
    return [vm.$("STYPE"), vm.$("EOSTYP"), null, vm.$("XLAEND")];
  }, ""], [null, "STREAM", function () {
    return [vm.$("XSP"), vm.$("TEXTSP"), vm.$("IBLKTB"), vm.$("COMP3"), vm.$("XLAEND")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("STYPE"), vm.$("EOSTYP"), null, vm.$("XLAEND")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("STYPE"), vm.$("NBTYP"), vm.$("COMP7")];
  }, "Error if break character"], [null, "STREAM", function () {
    return [vm.$("XSP"), vm.$("TEXTSP"), vm.$("LBLTB"), vm.$("COMP7"), vm.$("COMP7")];
  }, ""], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), [vm.$("XSPPTR")]];
  }, ""], [null, "GETDC", function () {
    return [vm.$("OCBSCL"), vm.$("XPTR"), vm.$("ATTRIB")];
  }, "Get start for interpreter"], [null, "AEQLC", function () {
    return [vm.$("OCBSCL"), 0, null, vm.$("COMP7")];
  }, "Error if not attribute"], [null, "AEQLC", function () {
    return [vm.$("STYPE"), vm.$("EOSTYP"), null, vm.$("XLAEND")];
  }, ""], [null, "STREAM", function () {
    return [vm.$("XSP"), vm.$("TEXTSP"), vm.$("IBLKTB"), vm.$("COMP7"), null, vm.$("COMP7")];
  }, ""], ["XLAEND", "AEQLC", function () {
    return [vm.$("ESAICL"), 0, null, vm.$("XLATSC")];
  }, "Were there any compilation errors?"], [null, "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("ERRCF")];
  }, "Print message of errors"], [null, "BRANCH", function () {
    return [vm.$("XLATND")];
  }, ""], ["XLATSC", "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("SUCCF")];
  }, "Print message of no errors"], ["XLATND", "SETAC", function () {
    return [vm.$("UNIT"), 0];
  }, "Reset input unit"], [null, "SETAC", function () {
    return [vm.$("LPTR"), 0];
  }, "Reset last label pointer"], [null, "SETAC", function () {
    return [vm.$("OCLIM"), 0];
  }, "Reset limit on object code"], [null, "ZERBLK", function () {
    return [vm.$("COMREG"), vm.$("COMDCT")];
  }, "Clear compiler descriptors"], [null, "SUM", function () {
    return [vm.$("XCL"), vm.$("CMBSCL"), vm.$("CMOFCL")];
  }, "Compute end of object code"], [null, "RCALL", function () {
    return [null, vm.$("SPLIT"), [vm.$("XCL")]];
  }, "Split of unused part of block"], [null, "SETAC", function () {
    return [vm.$("LISTCL"), 0];
  }, "Turn off listing switch"], [null, "MSTIME", function () {
    return [vm.$("ETMCL")];
  }, "Time out compiler"], [null, "SUBTRT", function () {
    return [vm.$("TIMECL"), vm.$("ETMCL"), vm.$("TIMECL")];
  }, "Compute elapsed time"], [null, "SETAC", function () {
    return [vm.$("CNSLCL"), 1];
  }, "Permit label redefinition"], [null, "RCALL", function () {
    return [null, vm.$("INTERP"), null, [vm.$("MAIN1"), vm.$("MAIN1"), vm.$("MAIN1")]];
  }, ""], [null, "TITLE", function () {
    return ["Support Procedures"];
  }, ""], ["AUGATL", "PROC", function () {
    return [null];
  }, "Procedure to augment pair lists"], [null, "POP", function () {
    return [[vm.$("A1PTR"), vm.$("A2PTR"), vm.$("A3PTR")]];
  }, "List, type and value"], [null, "LOCAPT", function () {
    return [vm.$("A4PTR"), vm.$("A1PTR"), vm.$("ZEROCL"), vm.$("AUG1")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("A4PTR"), vm.$("DESCR"), vm.$("A2PTR")];
  }, "Insert type descriptor"], [null, "PUTDC", function () {
    return [vm.$("A4PTR"), 2 * vm.$("DESCR"), vm.$("A3PTR")];
  }, "Insert value descriptor"], [null, "MOVD", function () {
    return [vm.$("A5PTR"), vm.$("A1PTR")];
  }, "Set up return pointer"], [null, "BRANCH", function () {
    return [vm.$("A5RTN")];
  }, "Return pair list"], ["AUG1", "GETSIZ", function () {
    return [vm.$("A4PTR"), vm.$("A1PTR")];
  }, "Get size of present list"], [null, "INCRA", function () {
    return [vm.$("A4PTR"), 2 * vm.$("DESCR")];
  }, "Add two more descriptors"], [null, "SETVC", function () {
    return [vm.$("A4PTR"), vm.$("B")];
  }, "Insert BLOCK data type"], [null, "RCALL", function () {
    return [vm.$("A5PTR"), vm.$("BLOCK"), vm.$("A4PTR")];
  }, "Allocate new block"], [null, "PUTD", function () {
    return [vm.$("A5PTR"), vm.$("A4PTR"), vm.$("A3PTR")];
  }, "Insert value descriptor at end"], [null, "DECRA", function () {
    return [vm.$("A4PTR"), vm.$("DESCR")];
  }, "Decrement"], [null, "PUTD", function () {
    return [vm.$("A5PTR"), vm.$("A4PTR"), vm.$("A2PTR")];
  }, "Insert type descriptor above"], ["AUGMOV", "DECRA", function () {
    return [vm.$("A4PTR"), vm.$("DESCR")];
  }, "Adjust size"], [null, "MOVBLK", function () {
    return [vm.$("A5PTR"), vm.$("A1PTR"), vm.$("A4PTR")];
  }, "Copy old list at top"], [null, "BRANCH", function () {
    return [vm.$("A5RTN")];
  }, "Return new list"], ["CODSKP", "PROC", function () {
    return [null];
  }, "Procedure to skip object code"], [null, "POP", function () {
    return [vm.$("YCL")];
  }, "Restore number of items to skip"], ["CODCNT", "INCRA", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("XCL"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get object code descriptor"], [null, "TESTF", function () {
    return [vm.$("XCL"), vm.$("FNC"), null, vm.$("CODFNC")];
  }, "Check for function"], ["CODECR", "DECRA", function () {
    return [vm.$("YCL"), 1];
  }, "Count down"], [null, "ACOMPC", function () {
    return [vm.$("YCL"), 0, vm.$("CODCNT"), vm.$("RTN1"), vm.$("INTR10")];
  }, ""], ["CODFNC", "PUSH", function () {
    return [vm.$("YCL")];
  }, "Save number to skip"], [null, "SETAV", function () {
    return [vm.$("YCL"), vm.$("XCL")];
  }, "Get arguments to skip"], [null, "RCALL", function () {
    return [null, vm.$("CODSKP"), [vm.$("YCL")]];
  }, "Call self recursively"], [null, "POP", function () {
    return [vm.$("YCL")];
  }, "Restore number to skip"], [null, "BRANCH", function () {
    return [vm.$("CODECR")];
  }, "Go around again"], ["DTREP", "PROC", function () {
    return [null];
  }, "Procedure to represent data type"], [null, "POP", function () {
    return [vm.$("A2PTR")];
  }, "Restore object"], [null, "VEQLC", function () {
    return [vm.$("A2PTR"), vm.$("A"), null, vm.$("DTARRY")];
  }, "Is is ARRAY?"], [null, "VEQLC", function () {
    return [vm.$("A2PTR"), vm.$("T"), null, vm.$("DTABLE")];
  }, "Is it TABLE?"], [null, "VEQLC", function () {
    return [vm.$("A2PTR"), vm.$("R"), vm.$("DTREP1")];
  }, "Is it REAL?"], [null, "REALST", function () {
    return [vm.$("DPSP"), vm.$("A2PTR")];
  }, "Convert REAL to STRING"], [null, "BRANCH", function () {
    return [vm.$("DTREPR")];
  }, "Join end processing"], ["DTARRY", "GETDC", function () {
    return [vm.$("A3PTR"), vm.$("A2PTR"), vm.$("DESCR")];
  }, "Get prototype"], [null, "LOCSP", function () {
    return [vm.$("ZSP"), vm.$("A3PTR")];
  }, "Get specifier"], [null, "GETLG", function () {
    return [vm.$("A3PTR"), vm.$("ZSP")];
  }, "Get length"], [null, "ACOMPC", function () {
    return [vm.$("A3PTR"), vm.$("ARRLEN"), vm.$("DTREP1")];
  }, "Check for excessive length"], [null, "SETLC", function () {
    return [vm.$("DTARSP"), 0];
  }, "Clear specifier"], [null, "APDSP", function () {
    return [vm.$("DTARSP"), vm.$("ARRSP")];
  }, "Append ARRAY"], [null, "APDSP", function () {
    return [vm.$("DTARSP"), vm.$("LPRNSP")];
  }, "Append '('"], [null, "APDSP", function () {
    return [vm.$("DTARSP"), vm.$("QTSP")];
  }, "Append quote"], [null, "APDSP", function () {
    return [vm.$("DTARSP"), vm.$("ZSP")];
  }, "Append prototype"], [null, "APDSP", function () {
    return [vm.$("DTARSP"), vm.$("QTSP")];
  }, "Append quote"], ["DTARTB", "APDSP", function () {
    return [vm.$("DTARSP"), vm.$("RPRNSP")];
  }, "Append ')'"], [null, "SETSP", function () {
    return [vm.$("DPSP"), vm.$("DTARSP")];
  }, "Move specifier"], [null, "BRANCH", function () {
    return [vm.$("DTREPR")];
  }, "Return"], ["DTABLE", "GETSIZ", function () {
    return [vm.$("A3PTR"), vm.$("A2PTR")];
  }, "E3.2.3"], [null, "GETD", function () {
    return [vm.$("A1PTR"), vm.$("A2PTR"), vm.$("A3PTR")];
  }, "E3.2.3"], [null, "DECRA", function () {
    return [vm.$("A3PTR"), vm.$("DESCR")];
  }, "E3.2.3"], [null, "GETD", function () {
    return [vm.$("A2PTR"), vm.$("A2PTR"), vm.$("A3PTR")];
  }, "E3.2.3"], ["DTABL1", "AEQLC", function () {
    return [vm.$("A1PTR"), 1, null, vm.$("DTABL2")];
  }, "E3.2.3"], [null, "SUM", function () {
    return [vm.$("A3PTR"), vm.$("A3PTR"), vm.$("A2PTR")];
  }, "E3.2.3"], [null, "DECRA", function () {
    return [vm.$("A3PTR"), 2 * vm.$("DESCR")];
  }, "E3.2.3"], [null, "GETD", function () {
    return [vm.$("A1PTR"), vm.$("A1PTR"), vm.$("A2PTR")];
  }, "E3.2.3"], [null, "BRANCH", function () {
    return [vm.$("DTABL1")];
  }, "E3.2.3"], ["DTABL2", "DECRA", function () {
    return [vm.$("A3PTR"), vm.$("DESCR")];
  }, "E3.2.3"], [null, "DECRA", function () {
    return [vm.$("A2PTR"), 2 * vm.$("DESCR")];
  }, "E3.2.3"], [null, "DIVIDE", function () {
    return [vm.$("A3PTR"), vm.$("A3PTR"), vm.$("DSCRTW")];
  }, "Divide to get item count"], [null, "INTSPC", function () {
    return [vm.$("ZSP"), vm.$("A3PTR")];
  }, "Convert to string"], [null, "SETLC", function () {
    return [vm.$("DTARSP"), 0];
  }, "Clear specifier"], [null, "APDSP", function () {
    return [vm.$("DTARSP"), vm.$("ASSCSP")];
  }, "Append TABLE"], [null, "APDSP", function () {
    return [vm.$("DTARSP"), vm.$("LPRNSP")];
  }, "Append '('"], [null, "APDSP", function () {
    return [vm.$("DTARSP"), vm.$("ZSP")];
  }, "Append size"], [null, "APDSP", function () {
    return [vm.$("DTARSP"), vm.$("CMASP")];
  }, "Append comma"], [null, "DIVIDE", function () {
    return [vm.$("A2PTR"), vm.$("A2PTR"), vm.$("DSCRTW")];
  }, "E3.2.3"], [null, "INTSPC", function () {
    return [vm.$("ZSP"), vm.$("A2PTR")];
  }, "E3.2.3"], [null, "APDSP", function () {
    return [vm.$("DTARSP"), vm.$("ZSP")];
  }, "Append extent"], [null, "BRANCH", function () {
    return [vm.$("DTARTB")];
  }, "Join common processing"], ["DTREP1", "MOVV", function () {
    return [vm.$("DT1CL"), vm.$("A2PTR")];
  }, "Insert data type"], [null, "LOCAPT", function () {
    return [vm.$("A3PTR"), vm.$("DTATL"), vm.$("DT1CL"), vm.$("DTREPE")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("A3PTR"), vm.$("A3PTR"), 2 * vm.$("DESCR")];
  }, "Get data type name"], [null, "LOCSP", function () {
    return [vm.$("DPSP"), vm.$("A3PTR")];
  }, "Get specifier"], ["DTREPR", "RRTURN", function () {
    return [vm.$("DPSPTR"), 1];
  }, "Return pointer to specifier"], ["DTREPE", "SETSP", function () {
    return [vm.$("DPSP"), vm.$("EXDTSP")];
  }, "Set up EXTERNAL specifier"], [null, "BRANCH", function () {
    return [vm.$("DTREPR")];
  }, "Return"], ["FINDEX", "PROC", function () {
    return [null];
  }, "Procedure to get function descriptor"], [null, "POP", function () {
    return [vm.$("F1PTR")];
  }, "Restore name"], [null, "LOCAPV", function () {
    return [vm.$("F2PTR"), vm.$("FNCPL"), vm.$("F1PTR"), vm.$("FATNF")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("F2PTR"), vm.$("F2PTR"), vm.$("DESCR")];
  }, "Get function descriptor"], ["FATBAK", "RRTURN", function () {
    return [vm.$("F2PTR"), 1];
  }, "Return"], ["FATNF", "INCRA", function () {
    return [vm.$("NEXFCL"), 2 * vm.$("DESCR")];
  }, "Increment function block offset"], [null, "ACOMPC", function () {
    return [vm.$("NEXFCL"), vm.$("FBLKSZ"), vm.$("FATBLK")];
  }, ""], ["FATNXT", "SUM", function () {
    return [vm.$("F2PTR"), vm.$("FBLOCK"), vm.$("NEXFCL")];
  }, "Compute position"], [null, "RCALL", function () {
    return [vm.$("FNCPL"), vm.$("AUGATL"), [vm.$("FNCPL"), vm.$("F2PTR"), vm.$("F1PTR")]];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("F2PTR"), 0, vm.$("UNDFCL")];
  }, "Insert undefined function"], [null, "PUTDC", function () {
    return [vm.$("F2PTR"), vm.$("DESCR"), vm.$("F1PTR")];
  }, "Insert name"], [null, "BRANCH", function () {
    return [vm.$("FATBAK")];
  }, "Join return"], ["FATBLK", "RCALL", function () {
    return [vm.$("FBLOCK"), vm.$("BLOCK"), vm.$("FBLKRQ")];
  }, "Allocate new function block"], [null, "SETF", function () {
    return [vm.$("FBLOCK"), vm.$("FNC")];
  }, "Insert function flag"], [null, "SETVC", function () {
    return [vm.$("FBLOCK"), 0];
  }, "Clear data type"], [null, "SETAC", function () {
    return [vm.$("NEXFCL"), vm.$("DESCR")];
  }, "Initialize offset"], [null, "BRANCH", function () {
    return [vm.$("FATNXT")];
  }, "Join processing"], [null, "TITLE", function () {
    return ["Storage Allocation and Regeneration Procedures"];
  }, ""], ["BLOCK", "PROC", function () {
    return [null];
  }, "Procedure to allocate blocks"], [null, "POP", function () {
    return [vm.$("ARG1CL")];
  }, "Restore size to allocate"], [null, "ACOMP", function () {
    return [vm.$("ARG1CL"), vm.$("SIZLMT"), vm.$("SIZERR"), vm.$("SIZERR")];
  }, ""], ["BLOCK1", "MOVD", function () {
    return [vm.$("BLOCL"), vm.$("FRSGPT")];
  }, "Position pointer to title"], [null, "MOVV", function () {
    return [vm.$("BLOCL"), vm.$("ARG1CL")];
  }, "Move data type"], [null, "INCRA", function () {
    return [vm.$("FRSGPT"), vm.$("DESCR")];
  }, "Leave room for title"], [null, "SUM", function () {
    return [vm.$("FRSGPT"), vm.$("FRSGPT"), vm.$("ARG1CL")];
  }, ""], [null, "ACOMP", function () {
    return [vm.$("TLSGP1"), vm.$("FRSGPT"), null, null, vm.$("BLOGC")];
  }, ""], [null, "ZERBLK", function () {
    return [vm.$("BLOCL"), vm.$("ARG1CL")];
  }, "Clear block"], [null, "PUTAC", function () {
    return [vm.$("BLOCL"), 0, vm.$("BLOCL")];
  }, "Set up self-pointer in title"], [null, "SETFI", function () {
    return [vm.$("BLOCL"), vm.$("TTL")];
  }, "Insert title flag"], [null, "SETSIZ", function () {
    return [vm.$("BLOCL"), vm.$("ARG1CL")];
  }, "Insert block size"], [null, "RRTURN", function () {
    return [vm.$("BLOCL"), 1];
  }, "Return pointer to block"], ["BLOGC", "MOVA", function () {
    return [vm.$("FRSGPT"), vm.$("BLOCL")];
  }, "Restore position pointer"], [null, "RCALL", function () {
    return [null, vm.$("GC"), [vm.$("ARG1CL")], [vm.$("ALOC2"), vm.$("BLOCK1")]];
  }, ""], ["GENVAR", "PROC", function () {
    return [null];
  }, "Procedure to generate variable"], [null, "SETAC", function () {
    return [vm.$("CONVSW"), 0];
  }, "Note GENVAR entry"], [null, "POP", function () {
    return [vm.$("AXPTR")];
  }, "Resotre pointer to specifier"], [null, "GETSPC", function () {
    return [vm.$("SPECR1"), vm.$("AXPTR"), 0];
  }, "Get specifier"], [null, "LEQLC", function () {
    return [vm.$("SPECR1"), 0, null, vm.$("RT1NUL")];
  }, "Avoid null string"], ["LOCA1", "VARID", function () {
    return [vm.$("EQUVCL"), vm.$("SPECR1")];
  }, "Compute bin and ascension numbers"], [null, "SUM", function () {
    return [vm.$("BUKPTR"), vm.$("OBPTR"), vm.$("EQUVCL")];
  }, "Find bin"], ["LOCA2", "MOVD", function () {
    return [vm.$("LSTPTR"), vm.$("BUKPTR")];
  }, "Save working copy"], [null, "GETAC", function () {
    return [vm.$("BUKPTR"), vm.$("BUKPTR"), vm.$("LNKFLD")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("BUKPTR"), 0, null, vm.$("LOCA5")];
  }, "Check for end of chain"], [null, "VCMPIC", function () {
    return [vm.$("BUKPTR"), vm.$("LNKFLD"), vm.$("EQUVCL"), vm.$("LOCA5"), null, vm.$("LOCA2")];
  }, ""], [null, "LOCSP", function () {
    return [vm.$("SPECR2"), vm.$("BUKPTR")];
  }, "Get specifier to string in storage"], [null, "LEXCMP", function () {
    return [vm.$("SPECR1"), vm.$("SPECR2"), vm.$("LOCA2"), null, vm.$("LOCA2")];
  }, ""], [null, "MOVD", function () {
    return [vm.$("LCPTR"), vm.$("BUKPTR")];
  }, "Return string in storage"], [null, "BRANCH", function () {
    return [vm.$("LOCRET")];
  }, ""], ["LOCA5", "GETLG", function () {
    return [vm.$("AXPTR"), vm.$("SPECR1")];
  }, "Get length of string"], [null, "GETLTH", function () {
    return [vm.$("BKLTCL"), vm.$("AXPTR")];
  }, "Compute space required"], [null, "ACOMP", function () {
    return [vm.$("BKLTCL"), vm.$("SIZLMT"), vm.$("SIZERR")];
  }, ""], ["LOCA7", "MOVD", function () {
    return [vm.$("LCPTR"), vm.$("FRSGPT")];
  }, "Point to position in storage"], [null, "SETVC", function () {
    return [vm.$("LCPTR"), vm.$("S")];
  }, "Set data type to STRING"], [null, "INCRA", function () {
    return [vm.$("FRSGPT"), vm.$("DESCR")];
  }, "Leave space for title"], [null, "SUM", function () {
    return [vm.$("FRSGPT"), vm.$("FRSGPT"), vm.$("BKLTCL")];
  }, ""], [null, "ACOMP", function () {
    return [vm.$("TLSGP1"), vm.$("FRSGPT"), null, null, vm.$("LOCA4")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("LCPTR"), 0, vm.$("ZEROCL")];
  }, "Clear title"], [null, "PUTAC", function () {
    return [vm.$("LCPTR"), 0, vm.$("LCPTR")];
  }, "Point title to self"], [null, "SETFI", function () {
    return [vm.$("LCPTR"), vm.$("TTL") + vm.$("STTL")];
  }, "Set string and title flags"], [null, "SETSIZ", function () {
    return [vm.$("LCPTR"), vm.$("AXPTR")];
  }, "Insert size of string"], [null, "AEQLC", function () {
    return [vm.$("CONVSW"), 0, vm.$("LOCA6")];
  }, "Check for GENVAR entry"], [null, "PUTDC", function () {
    return [vm.$("LCPTR"), vm.$("DESCR"), vm.$("NULVCL")];
  }, "Set value to null string"], [null, "PUTDC", function () {
    return [vm.$("LCPTR"), vm.$("ATTRIB"), vm.$("ZEROCL")];
  }, "Set label attribute to zero"], [null, "LOCSP", function () {
    return [vm.$("SPECR2"), vm.$("LCPTR")];
  }, "Get specifier to string structure"], [null, "SETLC", function () {
    return [vm.$("SPECR2"), 0];
  }, "Clear length"], [null, "APDSP", function () {
    return [vm.$("SPECR2"), vm.$("SPECR1")];
  }, "Move new string in"], ["LOCA6", "PUTVC", function () {
    return [vm.$("LCPTR"), vm.$("LNKFLD"), vm.$("EQUVCL")];
  }, "Insert ascension number"], [null, "PUTAC", function () {
    return [vm.$("LCPTR"), vm.$("LNKFLD"), vm.$("BUKPTR")];
  }, "Insert link pointer"], [null, "PUTAC", function () {
    return [vm.$("LSTPTR"), vm.$("LNKFLD"), vm.$("LCPTR")];
  }, "Link to last structure"], [null, "INCRA", function () {
    return [vm.$("VARSYM"), 1];
  }, "Increment count of new variables"], ["LOCRET", "RRTURN", function () {
    return [vm.$("LCPTR"), 1];
  }, "Return pointer to structure"], ["LOCA4", "MOVA", function () {
    return [vm.$("FRSGPT"), vm.$("LCPTR")];
  }, "Restore position pointer"], [null, "RCALL", function () {
    return [null, vm.$("GC"), [vm.$("BKLTCL")], [vm.$("ALOC2"), vm.$("LOCA7")]];
  }, ""], ["GNVARI", "PROC", function () {
    return [vm.$("GENVAR")];
  }, "Procedure to generate string"], [null, "SETAC", function () {
    return [vm.$("CONVSW"), 0];
  }, "Note GENVAR entry"], [null, "POP", function () {
    return [vm.$("AXPTR")];
  }, "Restore integer"], [null, "INTSPC", function () {
    return [vm.$("SPECR1"), vm.$("AXPTR")];
  }, "Convert to string"], [null, "BRANCH", function () {
    return [vm.$("LOCA1")];
  }, "Join processing"], ["CONVAR", "PROC", function () {
    return [vm.$("GENVAR")];
  }, "Procedure to get space for variable"], [null, "POP", function () {
    return [vm.$("AXPTR")];
  }, "Restore length"], [null, "AEQLC", function () {
    return [vm.$("AXPTR"), 0, null, vm.$("RT1NUL")];
  }, "Avoid null string"], [null, "SETAC", function () {
    return [vm.$("CONVSW"), 1];
  }, "Note CONVAR entry"], [null, "GETLTH", function () {
    return [vm.$("BKLTCL"), vm.$("AXPTR")];
  }, "Get space required"], [null, "ACOMP", function () {
    return [vm.$("BKLTCL"), vm.$("SIZLMT"), vm.$("SIZERR")];
  }, ""], [null, "SUM", function () {
    return [vm.$("TEMPCL"), vm.$("FRSGPT"), vm.$("BKLTCL")];
  }, ""], [null, "INCRA", function () {
    return [vm.$("TEMPCL"), vm.$("DESCR")];
  }, "Save space for title"], [null, "ACOMP", function () {
    return [vm.$("TLSGP1"), vm.$("TEMPCL"), null, null, vm.$("CONVR4")];
  }, ""], ["CONVR5", "PUTDC", function () {
    return [vm.$("FRSGPT"), 0, vm.$("ZEROCL")];
  }, "Clear title"], [null, "PUTAC", function () {
    return [vm.$("FRSGPT"), 0, vm.$("FRSGPT")];
  }, "Set up self pointer"], [null, "SETFI", function () {
    return [vm.$("FRSGPT"), vm.$("TTL") + vm.$("STTL")];
  }, "Set string and title flags"], [null, "SETSIZ", function () {
    return [vm.$("FRSGPT"), vm.$("AXPTR")];
  }, "Insert tentative size of string"], [null, "PUTDC", function () {
    return [vm.$("FRSGPT"), vm.$("DESCR"), vm.$("NULVCL")];
  }, "Insert null string as value"], [null, "PUTDC", function () {
    return [vm.$("FRSGPT"), vm.$("ATTRIB"), vm.$("ZEROCL")];
  }, ""], [null, "MOVA", function () {
    return [vm.$("BKLTCL"), vm.$("FRSGPT")];
  }, "E3.3.2"], [null, "RRTURN", function () {
    return [vm.$("BKLTCL"), 1];
  }, "E3.3.2"], ["CONVR4", "RCALL", function () {
    return [null, vm.$("GC"), vm.$("BKLTCL"), [vm.$("ALOC2"), vm.$("CONVR5")]];
  }, ""], ["GNVARS", "PROC", function () {
    return [vm.$("GENVAR")];
  }, "Procedure to entry string"], [null, "POP", function () {
    return [vm.$("AXPTR")];
  }, "Restore length"], [null, "AEQLC", function () {
    return [vm.$("AXPTR"), 0, null, vm.$("RT1NUL")];
  }, "Avoid null string"], [null, "LOCSP", function () {
    return [vm.$("SPECR1"), vm.$("FRSGPT")];
  }, "Get specifier to position"], [null, "PUTLG", function () {
    return [vm.$("SPECR1"), vm.$("AXPTR")];
  }, "Insert final length"], [null, "SETSIZ", function () {
    return [vm.$("FRSGPT"), vm.$("AXPTR")];
  }, "Insert size in title"], [null, "BRANCH", function () {
    return [vm.$("LOCA1")];
  }, "Join processing"], ["GC", "PROC", function () {
    return [null];
  }, "Storage regeneration procedure"], [null, "POP", function () {
    return [vm.$("GCREQ")];
  }, "Restore space required"], [null, "PSTACK", function () {
    return [vm.$("BLOCL")];
  }, "Post stack position"], [null, "SUBTRT", function () {
    return [vm.$("BLOCL"), vm.$("BLOCL"), vm.$("STKPTR")];
  }, "Compute stack length used"], [null, "SETSIZ", function () {
    return [vm.$("STKPTR"), vm.$("BLOCL")];
  }, "Set stack size"], [null, "MOVD", function () {
    return [vm.$("BKDXU"), vm.$("PRMDX")];
  }, "Number of resident blocks"], ["GCT", "GETD", function () {
    return [vm.$("GCMPTR"), vm.$("PRMPTR"), vm.$("BKDXU")];
  }, "Get next resident block"], [null, "AEQLC", function () {
    return [vm.$("GCMPTR"), 0, null, vm.$("GCTDWN")];
  }, "Skip nonpointers"], [null, "RCALL", function () {
    return [null, vm.$("GCM"), [vm.$("GCMPTR")]];
  }, "Scan resident block"], ["GCTDWN", "DECRA", function () {
    return [vm.$("BKDXU"), vm.$("DESCR")];
  }, "Decrement block count"], [null, "AEQLC", function () {
    return [vm.$("BKDXU"), 0, vm.$("GCT")];
  }, "Test for end of loop"], [null, "SETAC", function () {
    return [vm.$("BKPTR"), vm.$("OBLIST") - vm.$("DESCR")];
  }, "Set up pointer to bins"], ["GCBA1", "ACOMP", function () {
    return [vm.$("BKPTR"), vm.$("OBEND"), vm.$("GCLAD")];
  }, "Check for end of bins"], [null, "INCRA", function () {
    return [vm.$("BKPTR"), vm.$("DESCR")];
  }, "Increment bin pointer"], [null, "MOVD", function () {
    return [vm.$("ST1PTR"), vm.$("BKPTR")];
  }, "Get working copy"], ["GCBA2", "GETAC", function () {
    return [vm.$("ST1PTR"), vm.$("ST1PTR"), vm.$("LNKFLD")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("ST1PTR"), 0, null, vm.$("GCBA1")];
  }, "Test for end of chain"], [null, "TESTFI", function () {
    return [vm.$("ST1PTR"), vm.$("MARK"), null, vm.$("GCBA2")];
  }, "Test for marked structure"], [null, "GETDC", function () {
    return [vm.$("ST2PTR"), vm.$("ST1PTR"), vm.$("DESCR")];
  }, "Get value descriptor"], [null, "DEQL", function () {
    return [vm.$("ST2PTR"), vm.$("NULVCL"), vm.$("GCBA4")];
  }, "Mark if nonnull"], [null, "AEQLIC", function () {
    return [vm.$("ST1PTR"), vm.$("ATTRIB"), 0, null, vm.$("GCBA2")];
  }, ""], ["GCBA4", "PUTDC", function () {
    return [vm.$("GCBLK"), vm.$("DESCR"), vm.$("ST1PTR")];
  }, "Set up pseudoblock"], [null, "RCALL", function () {
    return [null, vm.$("GCM"), [vm.$("GCBLK")], vm.$("GCBA2")];
  }, "Mark string structure"], ["GCLAD", "MOVD", function () {
    return [vm.$("CPYCL"), vm.$("HDSGPT")];
  }, "Initialize target pointer"], [null, "MOVD", function () {
    return [vm.$("TTLCL"), vm.$("HDSGPT")];
  }, "Initialize block pointer"], ["GCLAD0", "BKSIZE", function () {
    return [vm.$("BKDX"), vm.$("TTLCL")];
  }, "Get size of block"], [null, "TESTFI", function () {
    return [vm.$("TTLCL"), vm.$("MARK"), vm.$("GCLAD7")];
  }, "Is the block marked?"], [null, "SUM", function () {
    return [vm.$("CPYCL"), vm.$("CPYCL"), vm.$("BKDX")];
  }, "Is block marked?"], [null, "SUM", function () {
    return [vm.$("TTLCL"), vm.$("TTLCL"), vm.$("BKDX")];
  }, "Update block pointer"], [null, "AEQL", function () {
    return [vm.$("TTLCL"), vm.$("FRSGPT"), vm.$("GCLAD0"), vm.$("GCBB1")];
  }, ""], ["GCLAD7", "MOVD", function () {
    return [vm.$("MVSGPT"), vm.$("TTLCL")];
  }, "Update compression barrier"], ["GCLAD4", "SUM", function () {
    return [vm.$("TTLCL"), vm.$("TTLCL"), vm.$("BKDX")];
  }, "Update block pointer"], [null, "AEQL", function () {
    return [vm.$("TTLCL"), vm.$("FRSGPT"), null, vm.$("GCBB1")];
  }, "Check for end of region"], [null, "BKSIZE", function () {
    return [vm.$("BKDX"), vm.$("TTLCL")];
  }, "Get size of block"], [null, "TESTFI", function () {
    return [vm.$("TTLCL"), vm.$("MARK"), vm.$("GCLAD4")];
  }, "Is block marked?"], [null, "PUTAC", function () {
    return [vm.$("TTLCL"), 0, vm.$("CPYCL")];
  }, "Point title to target"], [null, "SUM", function () {
    return [vm.$("CPYCL"), vm.$("CPYCL"), vm.$("BKDX")];
  }, "Update target pointer"], [null, "BRANCH", function () {
    return [vm.$("GCLAD4")];
  }, "Continue"], ["GCBB1", "SETAC", function () {
    return [vm.$("BKPTR"), vm.$("OBLIST") - vm.$("DESCR")];
  }, "Set up pointer to bins"], [null, "SETAC", function () {
    return [vm.$("NODPCL"), 1];
  }, "No dump while reorganizing"], ["GCBB2", "ACOMP", function () {
    return [vm.$("BKPTR"), vm.$("OBEND"), vm.$("GCLAP")];
  }, "Check for end of bins"], [null, "INCRA", function () {
    return [vm.$("BKPTR"), vm.$("DESCR")];
  }, "Increment bin pointer"], [null, "MOVD", function () {
    return [vm.$("ST1PTR"), vm.$("BKPTR")];
  }, "Get work copy"], ["GCBB3", "MOVD", function () {
    return [vm.$("ST2PTR"), vm.$("ST1PTR")];
  }, "Save pointer to be linked"], ["GCBB4", "GETAC", function () {
    return [vm.$("ST1PTR"), vm.$("ST1PTR"), vm.$("LNKFLD")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("ST1PTR"), 0, null, vm.$("GCBB5")];
  }, "Check for end of chain"], [null, "TESTFI", function () {
    return [vm.$("ST1PTR"), vm.$("MARK"), vm.$("GCBB4")];
  }, "Is string marked?"], [null, "GETAC", function () {
    return [vm.$("BLOCL"), vm.$("ST1PTR"), 0];
  }, "Get target address"], [null, "PUTAC", function () {
    return [vm.$("ST2PTR"), vm.$("LNKFLD"), vm.$("BLOCL")];
  }, "Set link to target"], [null, "BRANCH", function () {
    return [vm.$("GCBB3")];
  }, "Continue"], ["GCBB5", "PUTAC", function () {
    return [vm.$("ST2PTR"), vm.$("LNKFLD"), vm.$("ZEROCL")];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("GCBB2")];
  }, "Continue"], ["GCLAP", "MOVD", function () {
    return [vm.$("TTLCL"), vm.$("HDSGPT")];
  }, "Initialize target pointer"], ["GCLAP0", "BKSIZE", function () {
    return [vm.$("BKDXU"), vm.$("TTLCL")];
  }, "Get size of block"], [null, "TESTFI", function () {
    return [vm.$("TTLCL"), vm.$("STTL"), null, vm.$("GCLAP1")];
  }, "Check for string"], [null, "MOVD", function () {
    return [vm.$("BKDX"), vm.$("BKDXU")];
  }, "Working copy of block size"], [null, "BRANCH", function () {
    return [vm.$("GCLAP2")];
  }, ""], ["GCLAP1", "SETAC", function () {
    return [vm.$("BKDX"), 3 * vm.$("DESCR")];
  }, "Three descriptors for string"], ["GCLAP2", "TESTFI", function () {
    return [vm.$("TTLCL"), vm.$("MARK"), vm.$("GCLAP5")];
  }, "Is block marked?"], [null, "DECRA", function () {
    return [vm.$("BKDX"), vm.$("DESCR")];
  }, "Decrement offset"], ["GCLAP3", "GETD", function () {
    return [vm.$("DESCL"), vm.$("TTLCL"), vm.$("BKDX")];
  }, "Get next descriptor in block"], [null, "TESTF", function () {
    return [vm.$("DESCL"), vm.$("PTR"), vm.$("GCLAP4")];
  }, "Is it a pointer?"], [null, "ACOMP", function () {
    return [vm.$("DESCL"), vm.$("MVSGPT"), null, null, vm.$("GCLAP4")];
  }, ""], [null, "TOP", function () {
    return [vm.$("TOPCL"), vm.$("OFSET"), vm.$("DESCL")];
  }, "Compute offset to target"], [null, "ADJUST", function () {
    return [vm.$("DESCL"), vm.$("TOPCL"), vm.$("OFSET")];
  }, "Adjust pointer to target"], [null, "PUTD", function () {
    return [vm.$("TTLCL"), vm.$("BKDX"), vm.$("DESCL")];
  }, "Put descriptor back in block"], ["GCLAP4", "DECRA", function () {
    return [vm.$("BKDX"), vm.$("DESCR")];
  }, "Decrement offset"], [null, "AEQLC", function () {
    return [vm.$("BKDX"), 0, vm.$("GCLAP3")];
  }, "Check for end of block"], ["GCLAP5", "SUM", function () {
    return [vm.$("TTLCL"), vm.$("TTLCL"), vm.$("BKDXU")];
  }, "Move to next block"], [null, "AEQL", function () {
    return [vm.$("TTLCL"), vm.$("FRSGPT"), vm.$("GCLAP0")];
  }, "Check for end of region"], [null, "MOVD", function () {
    return [vm.$("BKDXU"), vm.$("PRMDX")];
  }, "Number of resident blocks"], ["GCLAT1", "GETD", function () {
    return [vm.$("TTLCL"), vm.$("PRMPTR"), vm.$("BKDXU")];
  }, "Get next resident block"], [null, "AEQLC", function () {
    return [vm.$("TTLCL"), 0, null, vm.$("GCLAT4")];
  }, "Skip nonpointer"], [null, "GETSIZ", function () {
    return [vm.$("BKDX"), vm.$("TTLCL")];
  }, "Get size of block"], ["GCLAT2", "GETD", function () {
    return [vm.$("DESCL"), vm.$("TTLCL"), vm.$("BKDX")];
  }, "Get descriptor from block"], [null, "TESTF", function () {
    return [vm.$("DESCL"), vm.$("PTR"), vm.$("GCLAT3")];
  }, "Is it a pointer?"], [null, "ACOMP", function () {
    return [vm.$("DESCL"), vm.$("MVSGPT"), null, null, vm.$("GCLAT3")];
  }, ""], [null, "TOP", function () {
    return [vm.$("TOPCL"), vm.$("OFSET"), vm.$("DESCL")];
  }, "Compute offset to target"], [null, "ADJUST", function () {
    return [vm.$("DESCL"), vm.$("TOPCL"), vm.$("OFSET")];
  }, "Adjust pointer to target"], [null, "PUTD", function () {
    return [vm.$("TTLCL"), vm.$("BKDX"), vm.$("DESCL")];
  }, "Put descriptor back in block"], ["GCLAT3", "DECRA", function () {
    return [vm.$("BKDX"), vm.$("DESCR")];
  }, "Decrement offset"], [null, "AEQLC", function () {
    return [vm.$("BKDX"), 0, vm.$("GCLAT2")];
  }, "Check for end of block"], ["GCLAT4", "DECRA", function () {
    return [vm.$("BKDXU"), vm.$("DESCR")];
  }, "Decrement count of resident blocks"], [null, "AEQLC", function () {
    return [vm.$("BKDXU"), 0, vm.$("GCLAT1")];
  }, "Check for end of resident blocks"], [null, "MOVD", function () {
    return [vm.$("TTLCL"), vm.$("HDSGPT")];
  }, "Set up target pointer"], ["GCLAM0", "BKSIZE", function () {
    return [vm.$("BKDXU"), vm.$("TTLCL")];
  }, "Get size of block"], [null, "ACOMP", function () {
    return [vm.$("TTLCL"), vm.$("MVSGPT"), vm.$("GCLAM5"), vm.$("GCLAM5")];
  }, ""], [null, "GETAC", function () {
    return [vm.$("TOPCL"), vm.$("TTLCL"), 0];
  }, "Get target position"], [null, "MOVDIC", function () {
    return [vm.$("TOPCL"), 0, vm.$("TTLCL"), 0];
  }, "Move title to target position"], [null, "RSETFI", function () {
    return [vm.$("TOPCL"), vm.$("MARK")];
  }, "Clear mark flag"], [null, "BRANCH", function () {
    return [vm.$("GCLAM4")];
  }, "Continue"], ["GCLAM5", "MOVA", function () {
    return [vm.$("BKDX"), vm.$("BKDXU")];
  }, "Working copy of block size"], [null, "DECRA", function () {
    return [vm.$("BKDX"), vm.$("DESCR")];
  }, "Size to be moved"], [null, "TESTFI", function () {
    return [vm.$("TTLCL"), vm.$("MARK"), vm.$("GCLAM4")];
  }, "Is block marked?"], [null, "GETAC", function () {
    return [vm.$("TOPCL"), vm.$("TTLCL"), 0];
  }, "Get target position"], [null, "MOVDIC", function () {
    return [vm.$("TOPCL"), 0, vm.$("TTLCL"), 0];
  }, "Move title"], [null, "RSETFI", function () {
    return [vm.$("TOPCL"), vm.$("MARK")];
  }, "Clear mark flag"], [null, "MOVBLK", function () {
    return [vm.$("TOPCL"), vm.$("TTLCL"), vm.$("BKDX")];
  }, "Move block itself"], ["GCLAM4", "SUM", function () {
    return [vm.$("TTLCL"), vm.$("TTLCL"), vm.$("BKDXU")];
  }, "Get to next block"], [null, "AEQL", function () {
    return [vm.$("TTLCL"), vm.$("FRSGPT"), vm.$("GCLAM0")];
  }, "Check for end of region"], [null, "INCRA", function () {
    return [vm.$("GCNO"), 1];
  }, "Increment count of regenerations"], [null, "SETAC", function () {
    return [vm.$("NODPCL"), 0];
  }, "Permit dump"], [null, "BKSIZE", function () {
    return [vm.$("BKDX"), vm.$("TOPCL")];
  }, "Get size of last block"], [null, "SUM", function () {
    return [vm.$("FRSGPT"), vm.$("TOPCL"), vm.$("BKDX")];
  }, "Compute new allocation pointer"], [null, "RESETF", function () {
    return [vm.$("FRSGPT"), vm.$("FNC")];
  }, "Clear possible function flag"], [null, "SUBTRT", function () {
    return [vm.$("GCGOT"), vm.$("TLSGP1"), vm.$("FRSGPT")];
  }, "Compute amount reclaimed"], [null, "DECRA", function () {
    return [vm.$("GCGOT"), vm.$("DESCR")];
  }, ""], [null, "RESETF", function () {
    return [vm.$("GCGOT"), vm.$("PTR")];
  }, "Clear pointer flag"], [null, "ACOMP", function () {
    return [vm.$("GCREQ"), vm.$("GCGOT"), vm.$("FAIL")];
  }, "Compare with amount required"], [null, "RRTURN", function () {
    return [vm.$("GCGOT"), 2];
  }, ""], ["GCM", "PROC", function () {
    return [null];
  }, "Procedure to mark blocks"], [null, "POP", function () {
    return [vm.$("BK1CL")];
  }, "Restore block to mark from"], [null, "PUSH", function () {
    return [vm.$("ZEROCL")];
  }, "Save end marker"], ["GCMA1", "GETSIZ", function () {
    return [vm.$("BKDX"), vm.$("BK1CL")];
  }, "Get size of block"], ["GCMA2", "GETD", function () {
    return [vm.$("DESCL"), vm.$("BK1CL"), vm.$("BKDX")];
  }, "Get descriptor"], [null, "TESTF", function () {
    return [vm.$("DESCL"), vm.$("PTR"), vm.$("GCMA3")];
  }, "Is it a pointer?"], [null, "AEQLC", function () {
    return [vm.$("DESCL"), 0, null, vm.$("GCMA3")];
  }, "Is address zero?"], [null, "TOP", function () {
    return [vm.$("TOPCL"), vm.$("OFSET"), vm.$("DESCL")];
  }, "Get to title of block pointed to"], [null, "TESTFI", function () {
    return [vm.$("TOPCL"), vm.$("MARK"), vm.$("GCMA4")];
  }, "Is block marked?"], ["GCMA3", "DECRA", function () {
    return [vm.$("BKDX"), vm.$("DESCR")];
  }, "Decrement offset"], [null, "AEQLC", function () {
    return [vm.$("BKDX"), 0, vm.$("GCMA2")];
  }, "Check for end of block"], [null, "POP", function () {
    return [vm.$("BK1CL")];
  }, "Restore block pushed"], [null, "AEQLC", function () {
    return [vm.$("BK1CL"), 0, null, vm.$("RTN1")];
  }, "Check for end"], [null, "SETAV", function () {
    return [vm.$("BKDX"), vm.$("BK1CL")];
  }, "Get size remaining"], [null, "BRANCH", function () {
    return [vm.$("GCMA2")];
  }, "Continue processing"], ["GCMA4", "DECRA", function () {
    return [vm.$("BKDX"), vm.$("DESCR")];
  }, "Decrement offset"], [null, "AEQLC", function () {
    return [vm.$("BKDX"), 0, null, vm.$("GCMA9")];
  }, "Check for end"], [null, "SETVA", function () {
    return [vm.$("BK1CL"), vm.$("BKDX")];
  }, "Insert offset"], [null, "PUSH", function () {
    return [vm.$("BK1CL")];
  }, "Save current block"], ["GCMA9", "MOVD", function () {
    return [vm.$("BK1CL"), vm.$("TOPCL")];
  }, "Set poiner to new block"], [null, "SETFI", function () {
    return [vm.$("BK1CL"), vm.$("MARK")];
  }, "Mark block"], [null, "TESTFI", function () {
    return [vm.$("BK1CL"), vm.$("STTL"), vm.$("GCMA1")];
  }, "Is it a string?"], [null, "MOVD", function () {
    return [vm.$("BKDX"), vm.$("TWOCL")];
  }, "Set size of string to 2"], [null, "BRANCH", function () {
    return [vm.$("GCMA2")];
  }, "Join processing"], ["SPLIT", "PROC", function () {
    return [null];
  }, "Procedure to split blocks"], [null, "POP", function () {
    return [vm.$("A4PTR")];
  }, "Restore pointer to middle of block"], [null, "TOP", function () {
    return [vm.$("A5PTR"), vm.$("A6PTR"), vm.$("A4PTR")];
  }, "Get title and offset"], [null, "AEQLC", function () {
    return [vm.$("A6PTR"), 0, null, vm.$("RTN1")];
  }, "Avoid block of zero length"], [null, "GETSIZ", function () {
    return [vm.$("A7PTR"), vm.$("A5PTR")];
  }, "Get present block size"], [null, "SUBTRT", function () {
    return [vm.$("A7PTR"), vm.$("A7PTR"), vm.$("A6PTR")];
  }, "Subtract offset"], [null, "DECRA", function () {
    return [vm.$("A7PTR"), vm.$("DESCR")];
  }, "Decrement for title"], [null, "ACOMPC", function () {
    return [vm.$("A7PTR"), 0, null, vm.$("RTN1"), vm.$("RTN1")];
  }, "Avoid block of zero length"], [null, "SETSIZ", function () {
    return [vm.$("A5PTR"), vm.$("A6PTR")];
  }, "Reset size of old block"], [null, "INCRA", function () {
    return [vm.$("A4PTR"), vm.$("DESCR")];
  }, "Adjust pointer to middle"], [null, "PUTDC", function () {
    return [vm.$("A4PTR"), 0, vm.$("ZEROCL")];
  }, ""], [null, "PUTAC", function () {
    return [vm.$("A4PTR"), 0, vm.$("A4PTR")];
  }, ""], [null, "SETFI", function () {
    return [vm.$("A4PTR"), vm.$("TTL")];
  }, "Insert title flag"], [null, "SETSIZ", function () {
    return [vm.$("A4PTR"), vm.$("A7PTR")];
  }, "Insert size fo new block"], [null, "BRANCH", function () {
    return [vm.$("RTN1")];
  }, "Return"], [null, "TITLE", function () {
    return ["Compilation Procedures"];
  }, ""], ["BINOP", "PROC", function () {
    return [null];
  }, "Compiler binary operator analysis"], [null, "RCALL", function () {
    return [null, vm.$("FORBLK"), null, vm.$("BINOP1")];
  }, "Test for initial blank"], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("NBTYP"), vm.$("RTN2")];
  }, "If so, fail on break"], [null, "STREAM", function () {
    return [vm.$("XSP"), vm.$("TEXTSP"), vm.$("BIOPTB"), vm.$("BINCON")];
  }, ""], [null, "MOVD", function () {
    return [vm.$("ZPTR"), vm.$("STYPE")];
  }, "Move function descriptor"], [null, "BRANCH", function () {
    return [vm.$("RTZPTR")];
  }, "Return function descriptor"], ["BINOP1", "RCALL", function () {
    return [null, vm.$("FORWRD"), null, vm.$("COMP3")];
  }, "If no blank, find character"], [null, "SELBRA", function () {
    return [vm.$("BRTYPE"), [null, vm.$("RTN2"), vm.$("RTN2"), null, null, vm.$("RTN2"), vm.$("RTN2")]];
  }, ""], ["BINERR", "SETAC", function () {
    return [vm.$("EMSGCL"), vm.$("ILLBIN")];
  }, "Set up error message"], [null, "BRANCH", function () {
    return [vm.$("RTN1")];
  }, "Take error return"], ["BINCON", "MOVD", function () {
    return [vm.$("ZPTR"), vm.$("CONCL")];
  }, "No operator, concatenation"], [null, "BRANCH", function () {
    return [vm.$("RTZPTR")];
  }, "Return function descriptor"], ["BINEOS", "SETAC", function () {
    return [vm.$("EMSGCL"), vm.$("ILLEOS")];
  }, "Set up error message"], [null, "BRANCH", function () {
    return [vm.$("RTN1")];
  }, "Error return"], ["CMPILE", "PROC", function () {
    return [null];
  }, "Procedure to compile statement"], [null, "SETAC", function () {
    return [vm.$("BRTYPE"), 0];
  }, "Clear break indicator"], [null, "MOVD", function () {
    return [vm.$("BOSCL"), vm.$("CMOFCL")];
  }, "Set statement beginning offset"], [null, "INCRA", function () {
    return [vm.$("CSTNCL"), 1];
  }, "Increment statement number"], [null, "STREAM", function () {
    return [vm.$("XSP"), vm.$("TEXTSP"), vm.$("LBLTB"), vm.$("CERR1")];
  }, ""], [null, "LEQLC", function () {
    return [vm.$("XSP"), 0, null, vm.$("CMPILA")];
  }, "Check for no label"], [null, "INCRA", function () {
    return [vm.$("CMOFCL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "PUTD", function () {
    return [vm.$("CMBSCL"), vm.$("CMOFCL"), vm.$("BASECL")];
  }, ""], [null, "SUM", function () {
    return [vm.$("CMBSCL"), vm.$("CMBSCL"), vm.$("CMOFCL")];
  }, ""], [null, "ACOMP", function () {
    return [vm.$("CMBSCL"), vm.$("OCLIM"), null, null, vm.$("CMPILO")];
  }, ""], [null, "RCALL", function () {
    return [vm.$("XCL"), vm.$("BLOCK"), vm.$("CODELT")];
  }, "Get block for more"], [null, "PUTDC", function () {
    return [vm.$("CMBSCL"), 0, vm.$("GOTGCL")];
  }, "Replace BASE with direct goto"], [null, "PUTDC", function () {
    return [vm.$("CMBSCL"), vm.$("DESCR"), vm.$("LIT1CL")];
  }, "E3.7.1"], [null, "PUTDC", function () {
    return [vm.$("CMBSCL"), 2 * vm.$("DESCR"), vm.$("XCL")];
  }, "Aim at new block"], [null, "MOVD", function () {
    return [vm.$("CMBSCL"), vm.$("XCL")];
  }, "Set up base of new region"], [null, "SUM", function () {
    return [vm.$("OCLIM"), vm.$("CMBSCL"), vm.$("CODELT")];
  }, "Compute end of new block"], [null, "DECRA", function () {
    return [vm.$("OCLIM"), 5 * vm.$("DESCR")];
  }, "Leave safety factor"], [null, "PUTDC", function () {
    return [vm.$("CMBSCL"), vm.$("DESCR"), vm.$("BASECL")];
  }, "Set BASE function in new region"], [null, "INCRA", function () {
    return [vm.$("CMBSCL"), vm.$("DESCR")];
  }, "Increment base"], ["CMPILO", "SETAC", function () {
    return [vm.$("CMOFCL"), 0];
  }, "Zero offset"], [null, "SETAC", function () {
    return [vm.$("BOSCL"), 0];
  }, "Zero base offset"], [null, "RCALL", function () {
    return [vm.$("LPTR"), vm.$("GENVAR"), vm.$("XSPPTR")];
  }, "Get variable for label"], [null, "AEQLIC", function () {
    return [vm.$("LPTR"), vm.$("ATTRIB"), 0, null, vm.$("CMPILC")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("CNSLCL"), 0, null, vm.$("CERR2")];
  }, "Check for label redefinition"], ["CMPILC", "PUTDC", function () {
    return [vm.$("LPTR"), vm.$("ATTRIB"), vm.$("CMBSCL")];
  }, "Insert label attribute"], [null, "DEQL", function () {
    return [vm.$("LPTR"), vm.$("ENDPTR"), null, vm.$("RTN2")];
  }, "Check for END"], ["CMPILA", "RCALL", function () {
    return [null, vm.$("FORBLK"), null, vm.$("CERR12")];
  }, "Get to next character"], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("EOSTYP"), null, vm.$("RTN3")];
  }, "Was end of statement founc?"], [null, "INCRA", function () {
    return [vm.$("CMOFCL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "PUTD", function () {
    return [vm.$("CMBSCL"), vm.$("CMOFCL"), vm.$("INITCL")];
  }, ""], [null, "INCRA", function () {
    return [vm.$("CMOFCL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "MOVD", function () {
    return [vm.$("FRNCL"), vm.$("CMOFCL")];
  }, "Save offset for failure position"], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("NBTYP"), null, vm.$("CMPSUB")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("CLNTYP"), vm.$("CERR3"), vm.$("CMPGO")];
  }, ""], ["CMPSUB", "RCALL", function () {
    return [vm.$("SUBJND"), vm.$("ELEMNT"), null, [vm.$("CDIAG"), vm.$("COMP3")]];
  }, ""], [null, "RCALL", function () {
    return [null, vm.$("FORBLK"), null, vm.$("CERR5")];
  }, "Get to next character"], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("NBTYP"), null, vm.$("CMPATN")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("EQTYP"), null, vm.$("CMPFRM")];
  }, ""], [null, "RCALL", function () {
    return [null, vm.$("TREPUB"), [vm.$("SUBJND")]];
  }, "Copy subject into object code"], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("CLNTYP"), null, vm.$("CMPGO")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("EOSTYP"), vm.$("CERR5"), vm.$("CMPNGO")];
  }, ""], ["CMPATN", "RCALL", function () {
    return [vm.$("PATND"), vm.$("EXPR"), null, vm.$("CDIAG")];
  }, "Compile pattern"], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("EQTYP"), null, vm.$("CMPASP")];
  }, ""], [null, "INCRA", function () {
    return [vm.$("CMOFCL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "PUTD", function () {
    return [vm.$("CMBSCL"), vm.$("CMOFCL"), vm.$("SCANCL")];
  }, ""], [null, "RCALL", function () {
    return [null, vm.$("TREPUB"), [vm.$("SUBJND")]];
  }, "Copy subject into object code"], [null, "RCALL", function () {
    return [null, vm.$("TREPUB"), [vm.$("PATND")]];
  }, "Copy pattern into object code"], ["CMPTGO", "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("EOSTYP"), null, vm.$("CMPNGO")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("CLNTYP"), vm.$("CERR5"), vm.$("CMPGO")];
  }, ""], ["CMPFRM", "RCALL", function () {
    return [vm.$("FORMND"), vm.$("EXPR"), null, vm.$("CDIAG")];
  }, "Compile object"], [null, "INCRA", function () {
    return [vm.$("CMOFCL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "PUTD", function () {
    return [vm.$("CMBSCL"), vm.$("CMOFCL"), vm.$("ASGNCL")];
  }, ""], [null, "RCALL", function () {
    return [null, vm.$("TREPUB"), [vm.$("SUBJND")]];
  }, "Copy subject into object code"], [null, "BRANCH", function () {
    return [vm.$("CMPFT")];
  }, "Join object publication"], ["CMPASP", "RCALL", function () {
    return [vm.$("FORMND"), vm.$("EXPR"), null, vm.$("CDIAG")];
  }, "Compile object"], [null, "INCRA", function () {
    return [vm.$("CMOFCL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "PUTD", function () {
    return [vm.$("CMBSCL"), vm.$("CMOFCL"), vm.$("SJSRCL")];
  }, ""], [null, "RCALL", function () {
    return [null, vm.$("TREPUB"), [vm.$("SUBJND")]];
  }, "Copy subject into object code"], [null, "RCALL", function () {
    return [null, vm.$("TREPUB"), [vm.$("PATND")]];
  }, "Copy pattern into object code"], ["CMPFT", "RCALL", function () {
    return [null, vm.$("TREPUB"), vm.$("FORMND"), vm.$("CMPTGO")];
  }, ""], ["CMPNGO", "SETVA", function () {
    return [vm.$("CSTNCL"), vm.$("CMOFCL")];
  }, "Set up offset for failure"], [null, "PUTD", function () {
    return [vm.$("CMBSCL"), vm.$("FRNCL"), vm.$("CSTNCL")];
  }, "Insert argument of INIT"], [null, "BRANCH", function () {
    return [vm.$("RTN3")];
  }, "Statement compilation is done"], ["CMPGO", "RCALL", function () {
    return [null, vm.$("FORWRD"), null, vm.$("COMP3")];
  }, "Check for end of statement"], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("EOSTYP"), null, vm.$("CMPNGO")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("NBTYP"), vm.$("CERR11")];
  }, ""], [null, "STREAM", function () {
    return [vm.$("XSP"), vm.$("TEXTSP"), vm.$("GOTOTB"), vm.$("CERR11"), vm.$("CERR12")];
  }, ""], [null, "MOVD", function () {
    return [vm.$("GOGOCL"), vm.$("GOTLCL")];
  }, "Predict GOTL"], [null, "SETAC", function () {
    return [vm.$("GOBRCL"), vm.$("RPTYP")];
  }, "Set up predicted closing break"], [null, "ACOMP", function () {
    return [vm.$("STYPE"), vm.$("GTOCL"), null, vm.$("CMPGG"), vm.$("CMPGG")];
  }, ""], [null, "MOVD", function () {
    return [vm.$("GOGOCL"), vm.$("GOTGCL")];
  }, "Set up direct goto"], [null, "SETAC", function () {
    return [vm.$("GOBRCL"), vm.$("RBTYP")];
  }, "Set up closing break"], ["CMPGG", "SELBRA", function () {
    return [vm.$("STYPE"), [null, vm.$("CMPSGO"), vm.$("CMPFGO"), null, vm.$("CMPSGO"), vm.$("CMPFGO")]];
  }, ""], ["CMPUGO", "SETVA", function () {
    return [vm.$("CSTNCL"), vm.$("CMOFCL")];
  }, "Set up offset for failure"], [null, "PUTD", function () {
    return [vm.$("CMBSCL"), vm.$("FRNCL"), vm.$("CSTNCL")];
  }, "Insert argument of INIT"], [null, "RCALL", function () {
    return [vm.$("GOTOND"), vm.$("EXPR"), null, vm.$("CDIAG")];
  }, "Compile goto"], [null, "AEQL", function () {
    return [vm.$("BRTYPE"), vm.$("GOBRCL"), vm.$("CERR11")];
  }, ""], [null, "INCRA", function () {
    return [vm.$("CMOFCL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "PUTD", function () {
    return [vm.$("CMBSCL"), vm.$("CMOFCL"), vm.$("GOGOCL")];
  }, ""], [null, "RCALL", function () {
    return [null, vm.$("TREPUB"), [vm.$("GOTOND")]];
  }, "Copy goto into object code"], [null, "RCALL", function () {
    return [null, vm.$("FORWRD"), null, vm.$("COMP3")];
  }, "Get to next character"], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("EOSTYP"), vm.$("CERR11"), vm.$("RTN3")];
  }, ""], ["CMPSGO", "RCALL", function () {
    return [vm.$("SGOND"), vm.$("EXPR"), null, vm.$("CDIAG")];
  }, "Compile success goto"], [null, "AEQL", function () {
    return [vm.$("BRTYPE"), vm.$("GOBRCL"), vm.$("CERR11")];
  }, ""], [null, "INCRA", function () {
    return [vm.$("CMOFCL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "PUTD", function () {
    return [vm.$("CMBSCL"), vm.$("CMOFCL"), vm.$("GOGOCL")];
  }, ""], [null, "RCALL", function () {
    return [null, vm.$("TREPUB"), [vm.$("SGOND")]];
  }, "Copy goto into object code"], [null, "RCALL", function () {
    return [null, vm.$("FORWRD"), null, vm.$("COMP3")];
  }, "Get to next character"], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("EOSTYP"), vm.$("CMPILL")];
  }, ""], [null, "SETVA", function () {
    return [vm.$("CSTNCL"), vm.$("CMOFCL")];
  }, "Set up offset for failure"], [null, "PUTD", function () {
    return [vm.$("CMBSCL"), vm.$("FRNCL"), vm.$("CSTNCL")];
  }, "Insert argument of INIT"], [null, "BRANCH", function () {
    return [vm.$("RTN3")];
  }, "Compilation is complete, return"], ["CMPILL", "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("NBTYP"), vm.$("CERR11")];
  }, "Check for nonbreak"], [null, "STREAM", function () {
    return [vm.$("XSP"), vm.$("TEXTSP"), vm.$("GOTOTB"), vm.$("CERR11"), vm.$("CERR12")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("STYPE"), vm.$("FGOTYP"), vm.$("CMPFTC")];
  }, "Check for failure goto"], [null, "MOVD", function () {
    return [vm.$("GOGOCL"), vm.$("GOTLCL")];
  }, "Set up goto"], [null, "SETAC", function () {
    return [vm.$("GOBRCL"), vm.$("RPTYP")];
  }, "Set up closing break"], [null, "BRANCH", function () {
    return [vm.$("CMPUGO")];
  }, "Join processing"], ["CMPFTC", "AEQLC", function () {
    return [vm.$("STYPE"), vm.$("FTOTYP"), vm.$("CERR11")];
  }, "Verify failure goto"], [null, "MOVD", function () {
    return [vm.$("GOGOCL"), vm.$("GOTGCL")];
  }, "Set up goto"], [null, "SETAC", function () {
    return [vm.$("GOBRCL"), vm.$("RBTYP")];
  }, "Set up closing break"], [null, "BRANCH", function () {
    return [vm.$("CMPUGO")];
  }, "Join processing"], ["CMPFGO", "RCALL", function () {
    return [vm.$("FGOND"), vm.$("EXPR"), null, vm.$("CDIAG")];
  }, "Compile failure goto"], [null, "AEQL", function () {
    return [vm.$("BRTYPE"), vm.$("GOBRCL"), vm.$("CERR11")];
  }, ""], [null, "RCALL", function () {
    return [null, vm.$("FORWRD"), null, vm.$("COMP3")];
  }, "Get to next character"], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("EOSTYP"), vm.$("CMPILM")];
  }, ""], [null, "INCRA", function () {
    return [vm.$("CMOFCL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "PUTD", function () {
    return [vm.$("CMBSCL"), vm.$("CMOFCL"), vm.$("GOTOCL")];
  }, ""], [null, "INCRA", function () {
    return [vm.$("CMOFCL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "MOVD", function () {
    return [vm.$("SRNCL"), vm.$("CMOFCL")];
  }, "Save location for success"], [null, "SETVA", function () {
    return [vm.$("CSTNCL"), vm.$("CMOFCL")];
  }, "Set up failure offset"], [null, "PUTD", function () {
    return [vm.$("CMBSCL"), vm.$("FRNCL"), vm.$("CSTNCL")];
  }, "Insert argument of INIT"], [null, "INCRA", function () {
    return [vm.$("CMOFCL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "PUTD", function () {
    return [vm.$("CMBSCL"), vm.$("CMOFCL"), vm.$("GOGOCL")];
  }, ""], [null, "RCALL", function () {
    return [null, vm.$("TREPUB"), [vm.$("FGOND")]];
  }, "Copy goto into object code"], [null, "PUTD", function () {
    return [vm.$("CMBSCL"), vm.$("SRNCL"), vm.$("CMOFCL")];
  }, "Insert success offset into code"], [null, "BRANCH", function () {
    return [vm.$("RTN3")];
  }, "Compilation is complete, return"], ["CMPILM", "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("NBTYP"), vm.$("CERR11")];
  }, "Verify nonbreak"], [null, "STREAM", function () {
    return [vm.$("XSP"), vm.$("TEXTSP"), vm.$("GOTOTB"), vm.$("CERR11"), vm.$("CERR12")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("STYPE"), vm.$("SGOTYP"), vm.$("CMPSTC")];
  }, "Check for success goto"], [null, "PUSH", function () {
    return [vm.$("GOTLCL")];
  }, "Save goto type"], [null, "SETAC", function () {
    return [vm.$("GOBRCL"), vm.$("RPTYP")];
  }, "Set up closing break"], [null, "BRANCH", function () {
    return [vm.$("CMPILN")];
  }, "Join processing"], ["CMPSTC", "AEQLC", function () {
    return [vm.$("STYPE"), vm.$("STOTYP"), vm.$("CERR11")];
  }, "Verify success goto"], [null, "PUSH", function () {
    return [vm.$("GOTGCL")];
  }, "Save goto type"], [null, "SETAC", function () {
    return [vm.$("GOBRCL"), vm.$("RBTYP")];
  }, "Set up closing break"], ["CMPILN", "RCALL", function () {
    return [vm.$("SGOND"), vm.$("EXPR"), null, vm.$("CDIAG")];
  }, "Compile success goto"], [null, "AEQL", function () {
    return [vm.$("BRTYPE"), vm.$("GOBRCL"), vm.$("CERR11")];
  }, ""], [null, "RCALL", function () {
    return [null, vm.$("FORWRD"), null, vm.$("COMP3")];
  }, "Get to next character"], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("EOSTYP"), vm.$("CERR11")];
  }, ""], [null, "INCRA", function () {
    return [vm.$("CMOFCL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "POP", function () {
    return [vm.$("WCL")];
  }, "Restore goto type"], [null, "PUTD", function () {
    return [vm.$("CMBSCL"), vm.$("CMOFCL"), vm.$("WCL")];
  }, "Insert goto function"], [null, "RCALL", function () {
    return [null, vm.$("TREPUB"), [vm.$("SGOND")]];
  }, "Copy goto into object code"], [null, "SETVA", function () {
    return [vm.$("CSTNCL"), vm.$("CMOFCL")];
  }, "Set up failure offset"], [null, "PUTD", function () {
    return [vm.$("CMBSCL"), vm.$("FRNCL"), vm.$("CSTNCL")];
  }, "Insert argument of INIT"], [null, "INCRA", function () {
    return [vm.$("CMOFCL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "PUTD", function () {
    return [vm.$("CMBSCL"), vm.$("CMOFCL"), vm.$("GOGOCL")];
  }, ""], [null, "RCALL", function () {
    return [null, vm.$("TREPUB"), [vm.$("FGOND")], vm.$("RTN3")];
  }, ""], ["CERR1", "SETAC", function () {
    return [vm.$("EMSGCL"), vm.$("EMSG1")];
  }, "Erroneous label"], [null, "BRANCH", function () {
    return [vm.$("CDIAG")];
  }, ""], ["CERR2", "SETAC", function () {
    return [vm.$("EMSGCL"), vm.$("EMSG2")];
  }, "Multidefined label"], [null, "BRANCH", function () {
    return [vm.$("CDIAG")];
  }, ""], ["CERR3", "SETAC", function () {
    return [vm.$("EMSGCL"), vm.$("EMSG3")];
  }, "Break character before subject"], [null, "BRANCH", function () {
    return [vm.$("CDIAG")];
  }, ""], ["CERR5", "SETAC", function () {
    return [vm.$("EMSGCL"), vm.$("ILLBRK")];
  }, "Illegal character after pattern"], [null, "BRANCH", function () {
    return [vm.$("CDIAG")];
  }, ""], ["CERR12", "SETAC", function () {
    return [vm.$("EMSGCL"), vm.$("ILLEOS")];
  }, "Illegal statement termination"], [null, "BRANCH", function () {
    return [vm.$("CDIAG")];
  }, ""], ["CERR11", "SETAC", function () {
    return [vm.$("EMSGCL"), vm.$("EMSG14")];
  }, "Characters after goto"], ["CDIAG", "INCRA", function () {
    return [vm.$("BOSCL"), vm.$("DESCR")];
  }, "Increment offset of beginning"], [null, "PUTD", function () {
    return [vm.$("CMBSCL"), vm.$("BOSCL"), vm.$("ERORCL")];
  }, "Insert ERROR function"], [null, "INCRA", function () {
    return [vm.$("BOSCL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "PUTD", function () {
    return [vm.$("CMBSCL"), vm.$("BOSCL"), vm.$("CSTNCL")];
  }, "Insert argument of ERROR"], [null, "MOVD", function () {
    return [vm.$("CMOFCL"), vm.$("BOSCL")];
  }, "Reposition offset"], [null, "INCRA", function () {
    return [vm.$("ESAICL"), vm.$("DESCR")];
  }, "Increment count of errors"], [null, "ACOMP", function () {
    return [vm.$("ESAICL"), vm.$("ESALIM"), vm.$("COMP9")];
  }, "Test for excessive errors"], [null, "AEQLC", function () {
    return [vm.$("LISTCL"), 0, null, vm.$("CDIAG1")];
  }, "Check for listing mode"], [null, "MOVD", function () {
    return [vm.$("YCL"), vm.$("ERRBAS")];
  }, "Set up length of error vector"], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("EOSTYP"), null, vm.$("CDIAG3")];
  }, ""], [null, "GETLG", function () {
    return [vm.$("XCL"), vm.$("TEXTSP")];
  }, "Get length remaining"], [null, "SUBTRT", function () {
    return [vm.$("YCL"), vm.$("YCL"), vm.$("XCL")];
  }, "Compute position for marker"], ["CDIAG3", "PUTLG", function () {
    return [vm.$("ERRSP"), vm.$("YCL")];
  }, "Insert length"], [null, "APDSP", function () {
    return [vm.$("ERRSP"), vm.$("QTSP")];
  }, "Set in marker"], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("EOSTYP"), null, vm.$("CDIAG2")];
  }, ""], [null, "STPRNT", function () {
    return [vm.$("IOKEY"), vm.$("OUTBLK"), vm.$("LNBFSP")];
  }, "Print statement"], ["CDIAG2", "STPRNT", function () {
    return [vm.$("IOKEY"), vm.$("OUTBLK"), vm.$("ERRSP")];
  }, "Print error marker"], [null, "PUTLG", function () {
    return [vm.$("ERRSP"), vm.$("YCL")];
  }, "Insert length in marker"], [null, "APDSP", function () {
    return [vm.$("ERRSP"), vm.$("BLSP")];
  }, "Blank out marker"], [null, "GETSPC", function () {
    return [vm.$("TSP"), vm.$("EMSGCL"), 0];
  }, "Get error message"], [null, "SETLC", function () {
    return [vm.$("CERRSP"), 0];
  }, "Clear specifier"], [null, "APDSP", function () {
    return [vm.$("CERRSP"), vm.$("STARSP")];
  }, "Append attention getter"], [null, "APDSP", function () {
    return [vm.$("CERRSP"), vm.$("TSP")];
  }, "Append error message"], [null, "STPRNT", function () {
    return [vm.$("IOKEY"), vm.$("OUTBLK"), vm.$("CERRSP")];
  }, "Print error message"], [null, "STPRNT", function () {
    return [vm.$("IOKEY"), vm.$("OUTBLK"), vm.$("BLSP")];
  }, "Print blank line"], ["CDIAG1", "AEQLC", function () {
    return [vm.$("UNIT"), 0, null, vm.$("RTN1")];
  }, "E3.0.1"], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("EOSTYP"), null, vm.$("RTN3")];
  }, "E3.0.1"], [null, "STREAM", function () {
    return [vm.$("XSP"), vm.$("TEXTSP"), vm.$("EOSTB"), vm.$("COMP3"), null, vm.$("RTN3")];
  }, ""], ["DIAGRN", "STREAD", function () {
    return [vm.$("INBFSP"), vm.$("UNIT"), vm.$("DIAGRN"), vm.$("COMP5")];
  }, ""], [null, "SETSP", function () {
    return [vm.$("TEXTSP"), vm.$("NEXTSP")];
  }, "Set up new line"], [null, "STREAM", function () {
    return [vm.$("XSP"), vm.$("TEXTSP"), vm.$("CARDTB"), vm.$("COMP3"), vm.$("COMP3")];
  }, ""], [null, "RCALL", function () {
    return [null, vm.$("NEWCRD"), null, [null, null, vm.$("RTN3")]];
  }, "Process card image"], [null, "AEQLC", function () {
    return [vm.$("LISTCL"), 0, null, vm.$("DIAGRN")];
  }, ""], [null, "STPRNT", function () {
    return [vm.$("IOKEY"), vm.$("OUTBLK"), vm.$("LNBFSP")];
  }, "Print out bypassed card"], [null, "BRANCH", function () {
    return [vm.$("DIAGRN")];
  }, ""], ["ELEMNT", "PROC", function () {
    return [null];
  }, "Element analysis procedure"], [null, "RCALL", function () {
    return [vm.$("ELEMND"), vm.$("UNOP"), null, vm.$("RTN2")];
  }, "Get tree of unary operators"], [null, "STREAM", function () {
    return [vm.$("XSP"), vm.$("TEXTSP"), vm.$("ELEMTB"), vm.$("ELEICH"), vm.$("ELEILI")];
  }, ""], ["ELEMN9", "SELBRA", function () {
    return [vm.$("STYPE"), [null, vm.$("ELEILT"), vm.$("ELEVBL"), vm.$("ELENST"), vm.$("ELEFNC"), vm.$("ELEFLT"), vm.$("ELEARY")]];
  }, ""], [null, "FSHRTN", function () {
    return [vm.$("XSP"), 1];
  }, "Delete initial quote"], [null, "SHORTN", function () {
    return [vm.$("XSP"), 1];
  }, "Remove terminal quote"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), [vm.$("XSPPTR")]];
  }, ""], ["ELEMN5", "RCALL", function () {
    return [vm.$("ELEXND"), vm.$("BLOCK"), vm.$("CNDSIZ")];
  }, "Allocate block for tree node"], [null, "PUTDC", function () {
    return [vm.$("ELEXND"), vm.$("CODE"), vm.$("LITCL")];
  }, "Insert literal function"], [null, "RCALL", function () {
    return [vm.$("ELEYND"), vm.$("BLOCK"), vm.$("CNDSIZ")];
  }, "Allocate block for tree node"], [null, "PUTDC", function () {
    return [vm.$("ELEYND"), vm.$("CODE"), vm.$("XPTR")];
  }, "Insert literal value"], [null, "ADDSON", function () {
    return [vm.$("ELEXND"), vm.$("ELEYND")];
  }, "Add node as son"], ["ELEMN1", "AEQLC", function () {
    return [vm.$("ELEMND"), 0, vm.$("ELEMN6")];
  }, "Check for empty tree"], [null, "MOVD", function () {
    return [vm.$("ZPTR"), vm.$("ELEXND")];
  }, "Set up return"], [null, "BRANCH", function () {
    return [vm.$("ELEMRR")];
  }, "Join return processing"], ["ELEMN6", "ADDSON", function () {
    return [vm.$("ELEMND"), vm.$("ELEXND")];
  }, "Add as son of present tree"], ["ELEMNR", "MOVD", function () {
    return [vm.$("ZPTR"), vm.$("ELEMND")];
  }, "Move tree to return"], ["ELEMRR", "AEQLIC", function () {
    return [vm.$("ZPTR"), vm.$("FATHER"), 0, null, vm.$("RTZPTR")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("ZPTR"), vm.$("FATHER")];
  }, "Move back to father"], [null, "BRANCH", function () {
    return [vm.$("ELEMRR")];
  }, "Continue up tree"], ["ELEILT", "SPCINT", function () {
    return [vm.$("XPTR"), vm.$("XSP"), vm.$("ELEINT"), vm.$("ELEMN5")];
  }, ""], ["ELEFLT", "SPREAL", function () {
    return [vm.$("XPTR"), vm.$("XSP"), vm.$("ELEDEC"), vm.$("ELEMN5")];
  }, ""], ["ELEVBL", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), [vm.$("XSPPTR")]];
  }, ""], [null, "RCALL", function () {
    return [vm.$("ELEXND"), vm.$("BLOCK"), vm.$("CNDSIZ")];
  }, "Allocate block for tree node"], [null, "PUTDC", function () {
    return [vm.$("ELEXND"), vm.$("CODE"), vm.$("XPTR")];
  }, "Insert name"], [null, "BRANCH", function () {
    return [vm.$("ELEMN1")];
  }, "Join exit processing"], ["ELENST", "PUSH", function () {
    return [vm.$("ELEMND")];
  }, "Save current tree"], [null, "RCALL", function () {
    return [vm.$("ELEXND"), vm.$("EXPR"), null, vm.$("RTN1")];
  }, "Evaluate nested expression"], [null, "POP", function () {
    return [vm.$("ELEMND")];
  }, "Restore tree"], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("RPTYP"), vm.$("ELECMA"), vm.$("ELEMN1")];
  }, ""], ["ELEFNC", "SHORTN", function () {
    return [vm.$("XSP"), 1];
  }, "Delete open parenthesis"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), [vm.$("XSPPTR")]];
  }, ""], [null, "RCALL", function () {
    return [vm.$("XCL"), vm.$("FINDEX"), [vm.$("XPTR")]];
  }, "Find function descriptor"], [null, "RCALL", function () {
    return [vm.$("ELEXND"), vm.$("BLOCK"), vm.$("CNDSIZ")];
  }, "Allocate block for tree node"], [null, "PUTDC", function () {
    return [vm.$("ELEXND"), vm.$("CODE"), vm.$("XCL")];
  }, "Insert function descriptor in node"], [null, "AEQLC", function () {
    return [vm.$("ELEMND"), 0, null, vm.$("ELEMN7")];
  }, "Is tree empty?"], [null, "ADDSON", function () {
    return [vm.$("ELEMND"), vm.$("ELEXND")];
  }, "Add node as son to tree"], ["ELEMN7", "PUSH", function () {
    return [vm.$("ELEXND")];
  }, "Save current node"], [null, "RCALL", function () {
    return [vm.$("ELEXND"), vm.$("EXPR"), null, vm.$("RTN1")];
  }, "Evaluate argument of function"], [null, "POP", function () {
    return [vm.$("ELEMND")];
  }, "Resotre current node"], [null, "ADDSON", function () {
    return [vm.$("ELEMND"), vm.$("ELEXND")];
  }, "Add argument as son"], [null, "MOVD", function () {
    return [vm.$("ELEMND"), vm.$("ELEXND")];
  }, "Move to new node"], ["ELEMN2", "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("RPTYP"), null, vm.$("ELEMN3")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("CMATYP"), vm.$("ELECMA")];
  }, ""], [null, "PUSH", function () {
    return [vm.$("ELEMND")];
  }, "Save current node"], [null, "RCALL", function () {
    return [vm.$("ELEXND"), vm.$("EXPR"), null, vm.$("RTN1")];
  }, "Evaluate next argument"], [null, "POP", function () {
    return [vm.$("ELEMND")];
  }, "Restore current node"], [null, "ADDSIB", function () {
    return [vm.$("ELEMND"), vm.$("ELEXND")];
  }, "Add argument as sibling"], [null, "MOVD", function () {
    return [vm.$("ELEMND"), vm.$("ELEXND")];
  }, "Move to new node"], [null, "BRANCH", function () {
    return [vm.$("ELEMN2")];
  }, "Continue"], ["ELEMN3", "GETDC", function () {
    return [vm.$("ELEXND"), vm.$("ELEMND"), vm.$("FATHER")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("XCL"), vm.$("ELEXND"), vm.$("CODE")];
  }, "Get function descriptor"], [null, "GETDC", function () {
    return [vm.$("YCL"), vm.$("XCL"), 0];
  }, "Get procedure descriptor"], [null, "TESTF", function () {
    return [vm.$("YCL"), vm.$("FNC"), null, vm.$("ELEMNR")];
  }, "Check for fixed number requirement"], [null, "SETAV", function () {
    return [vm.$("XCL"), vm.$("XCL")];
  }, "Get number of arguments given"], [null, "SETAV", function () {
    return [vm.$("YCL"), vm.$("YCL")];
  }, "Get number of arguments expected"], ["ELEMN4", "ACOMP", function () {
    return [vm.$("XCL"), vm.$("YCL"), vm.$("ELEMNR"), vm.$("ELEMNR")];
  }, ""], [null, "RCALL", function () {
    return [vm.$("ELEYND"), vm.$("BLOCK"), vm.$("CNDSIZ")];
  }, "Allocate block for tree node"], [null, "PUTDC", function () {
    return [vm.$("ELEYND"), vm.$("CODE"), vm.$("LITCL")];
  }, "Insert literal function"], [null, "RCALL", function () {
    return [vm.$("ELEXND"), vm.$("BLOCK"), vm.$("CNDSIZ")];
  }, "Allocate block for tree node"], [null, "PUTDC", function () {
    return [vm.$("ELEXND"), vm.$("CODE"), vm.$("NULVCL")];
  }, "Insert null string value"], [null, "ADDSON", function () {
    return [vm.$("ELEYND"), vm.$("ELEXND")];
  }, "Add null as son of literal"], [null, "ADDSIB", function () {
    return [vm.$("ELEMND"), vm.$("ELEYND")];
  }, "Add literal as extra argument"], [null, "MOVD", function () {
    return [vm.$("ELEMND"), vm.$("ELEYND")];
  }, "Move to new node"], [null, "INCRA", function () {
    return [vm.$("XCL"), 1];
  }, "Increment argument count"], [null, "BRANCH", function () {
    return [vm.$("ELEMN4")];
  }, "Continue"], ["ELEARY", "SHORTN", function () {
    return [vm.$("XSP"), 1];
  }, "Remove left bracket"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), [vm.$("XSPPTR")]];
  }, ""], [null, "RCALL", function () {
    return [vm.$("ELEXND"), vm.$("BLOCK"), vm.$("CNDSIZ")];
  }, "Allocate block for tree node"], [null, "PUTDC", function () {
    return [vm.$("ELEXND"), vm.$("CODE"), vm.$("ITEMCL")];
  }, "Insert ITEM function"], [null, "AEQLC", function () {
    return [vm.$("ELEMND"), 0, null, vm.$("ELEMN8")];
  }, "Is tree empty?"], [null, "ADDSON", function () {
    return [vm.$("ELEMND"), vm.$("ELEXND")];
  }, "Add as son to tree"], ["ELEMN8", "MOVD", function () {
    return [vm.$("ELEMND"), vm.$("ELEXND")];
  }, "Move to new node"], [null, "RCALL", function () {
    return [vm.$("ELEXND"), vm.$("BLOCK"), vm.$("CNDSIZ")];
  }, "Allocate block for tree node"], [null, "PUTDC", function () {
    return [vm.$("ELEXND"), vm.$("CODE"), vm.$("XPTR")];
  }, "Insert array or table name"], [null, "ADDSON", function () {
    return [vm.$("ELEMND"), vm.$("ELEXND")];
  }, "Add as son to tree"], [null, "MOVD", function () {
    return [vm.$("ELEMND"), vm.$("ELEXND")];
  }, "Move to new node"], ["ELEAR1", "PUSH", function () {
    return [vm.$("ELEMND")];
  }, "Save current node"], [null, "RCALL", function () {
    return [vm.$("ELEXND"), vm.$("EXPR"), null, vm.$("RTN1")];
  }, "Evaluate argument"], [null, "POP", function () {
    return [vm.$("ELEMND")];
  }, "Restore current node"], [null, "ADDSIB", function () {
    return [vm.$("ELEMND"), vm.$("ELEXND")];
  }, "Add as sibling to tree"], [null, "MOVD", function () {
    return [vm.$("ELEMND"), vm.$("ELEXND")];
  }, "Move to new node"], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("RBTYP"), null, vm.$("ELEMNR")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("CMATYP"), vm.$("ELECMA"), vm.$("ELEAR1")];
  }, ""], ["ELEICH", "SETAC", function () {
    return [vm.$("EMSGCL"), vm.$("ILCHAR")];
  }, "'ILLEGAL CHARACTER IN ELEMENT'"], [null, "BRANCH", function () {
    return [vm.$("RTN1")];
  }, "Error return"], ["ELEILI", "AEQLC", function () {
    return [vm.$("STYPE"), vm.$("QLITYP"), vm.$("ELEMN9")];
  }, "Check cause of run out"], [null, "SETAC", function () {
    return [vm.$("EMSGCL"), vm.$("OPNLIT")];
  }, "'UNCLOSED LITERAL'"], [null, "BRANCH", function () {
    return [vm.$("RTN1")];
  }, "Error return"], ["ELEINT", "SETAC", function () {
    return [vm.$("EMSGCL"), vm.$("ILLINT")];
  }, "'ILLEGAL INTEGER'"], [null, "BRANCH", function () {
    return [vm.$("RTN1")];
  }, "Error return"], ["ELEDEC", "SETAC", function () {
    return [vm.$("EMSGCL"), vm.$("ILLDEC")];
  }, "'ILLEGAL REAL'"], [null, "BRANCH", function () {
    return [vm.$("RTN1")];
  }, "Error return"], ["ELECMA", "SETAC", function () {
    return [vm.$("EMSGCL"), vm.$("ILLBRK")];
  }, "'ILLEGAL BREAK CHARACTER'"], [null, "BRANCH", function () {
    return [vm.$("RTN1")];
  }, "Error return"], ["EXPR", "PROC", function () {
    return [null];
  }, "Procedure to compile expression"], [null, "RCALL", function () {
    return [vm.$("EXELND"), vm.$("ELEMNT"), null, [vm.$("RTN1"), vm.$("EXPNUL")]];
  }, ""], [null, "SETAC", function () {
    return [vm.$("EXPRND"), 0];
  }, "Zero expression tree"], [null, "BRANCH", function () {
    return [vm.$("EXPR2")];
  }, "Join main processing"], ["EXPR1", "PUSH", function () {
    return [vm.$("EXPRND")];
  }, "Save expression tree"], [null, "RCALL", function () {
    return [vm.$("EXELND"), vm.$("ELEMNT"), null, [vm.$("RTN1"), vm.$("EXPERR")]];
  }, ""], [null, "POP", function () {
    return [vm.$("EXPRND")];
  }, "Restore expression tree"], ["EXPR2", "RCALL", function () {
    return [vm.$("EXOPCL"), vm.$("BINOP"), null, [vm.$("RTN1"), vm.$("EXPR7")]];
  }, ""], [null, "RCALL", function () {
    return [vm.$("EXOPND"), vm.$("BLOCK"), vm.$("CNDSIZ")];
  }, "Allocate block for tree node"], [null, "PUTDC", function () {
    return [vm.$("EXOPND"), vm.$("CODE"), vm.$("EXOPCL")];
  }, "Insert binary operator"], [null, "AEQLC", function () {
    return [vm.$("EXPRND"), 0, vm.$("EXPR3")];
  }, "Check for empty tree"], [null, "ADDSON", function () {
    return [vm.$("EXOPND"), vm.$("EXELND")];
  }, "Add node as son"], [null, "MOVD", function () {
    return [vm.$("EXPRND"), vm.$("EXELND")];
  }, "Move to new node"], [null, "BRANCH", function () {
    return [vm.$("EXPR1")];
  }, "Continue processing"], ["EXPR3", "GETDC", function () {
    return [vm.$("EXOPCL"), vm.$("EXOPCL"), 2 * vm.$("DESCR")];
  }, ""], [null, "SETAV", function () {
    return [vm.$("EXOPCL"), vm.$("EXOPCL")];
  }, "Get left precedence"], [null, "GETDC", function () {
    return [vm.$("EXEXND"), vm.$("EXPRND"), vm.$("FATHER")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("XPTR"), vm.$("EXEXND"), vm.$("CODE")];
  }, "Get function descriptor"], [null, "GETDC", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), 2 * vm.$("DESCR")];
  }, "Get precedence descriptor"], [null, "ACOMP", function () {
    return [vm.$("XPTR"), vm.$("EXOPCL"), vm.$("EXPR4")];
  }, "Compare precedences"], [null, "ADDSIB", function () {
    return [vm.$("EXPRND"), vm.$("EXOPND")];
  }, "Add node as sibling"], [null, "MOVD", function () {
    return [vm.$("EXPRND"), vm.$("EXOPND")];
  }, "Move to new node"], [null, "ADDSON", function () {
    return [vm.$("EXPRND"), vm.$("EXELND")];
  }, "Put current node as son"], [null, "MOVD", function () {
    return [vm.$("EXPRND"), vm.$("EXELND")];
  }, "Move to new node"], [null, "BRANCH", function () {
    return [vm.$("EXPR1")];
  }, "Continue processing"], ["EXPR4", "ADDSIB", function () {
    return [vm.$("EXPRND"), vm.$("EXELND")];
  }, "Add current node as sibling"], ["EXPR5", "AEQLIC", function () {
    return [vm.$("EXPRND"), vm.$("FATHER"), 0, null, vm.$("EXPR11")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("EXPRND"), vm.$("EXPRND"), vm.$("FATHER")];
  }, ""], [null, "AEQLIC", function () {
    return [vm.$("EXPRND"), vm.$("FATHER"), 0, null, vm.$("EXPR11")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("EXEXND"), vm.$("EXPRND"), vm.$("FATHER")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("XPTR"), vm.$("EXEXND"), vm.$("CODE")];
  }, "Get function descriptor"], [null, "GETDC", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), 2 * vm.$("DESCR")];
  }, "Get precedence descriptor"], [null, "ACOMP", function () {
    return [vm.$("XPTR"), vm.$("EXOPCL"), vm.$("EXPR5")];
  }, "Compare precedences"], [null, "INSERT", function () {
    return [vm.$("EXPRND"), vm.$("EXOPND")];
  }, "Insert node above"], [null, "BRANCH", function () {
    return [vm.$("EXPR1")];
  }, "Continue processing"], ["EXPR7", "AEQLC", function () {
    return [vm.$("EXPRND"), 0, vm.$("EXPR10")];
  }, "Check for empty tree"], [null, "MOVD", function () {
    return [vm.$("XPTR"), vm.$("EXELND")];
  }, "Set up for return"], [null, "BRANCH", function () {
    return [vm.$("EXPR9")];
  }, "Join end processing"], ["EXPR10", "ADDSIB", function () {
    return [vm.$("EXPRND"), vm.$("EXELND")];
  }, "Add node as sibling"], [null, "MOVD", function () {
    return [vm.$("XPTR"), vm.$("EXPRND")];
  }, "Set up for return"], ["EXPR9", "AEQLIC", function () {
    return [vm.$("XPTR"), vm.$("FATHER"), 0, null, vm.$("RTXNAM")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), vm.$("FATHER")];
  }, "Go back to father"], [null, "BRANCH", function () {
    return [vm.$("EXPR9")];
  }, "Continue up tree"], ["EXPR11", "ADDSON", function () {
    return [vm.$("EXOPND"), vm.$("EXPRND")];
  }, "Add node as son"], [null, "BRANCH", function () {
    return [vm.$("EXPR1")];
  }, "Continue processing"], ["EXPNUL", "RCALL", function () {
    return [vm.$("EXPRND"), vm.$("BLOCK"), vm.$("CNDSIZ")];
  }, "Allocate block for tree node"], [null, "PUTDC", function () {
    return [vm.$("EXPRND"), vm.$("CODE"), vm.$("LITCL")];
  }, "Insert literal function"], [null, "RCALL", function () {
    return [vm.$("EXEXND"), vm.$("BLOCK"), vm.$("CNDSIZ")];
  }, "Allocate block for tree node"], [null, "PUTDC", function () {
    return [vm.$("EXEXND"), vm.$("CODE"), vm.$("NULVCL")];
  }, "Insert null string as value"], [null, "ADDSON", function () {
    return [vm.$("EXPRND"), vm.$("EXEXND")];
  }, "Add node as son"], [null, "MOVD", function () {
    return [vm.$("XPTR"), vm.$("EXPRND")];
  }, "Set up for return"], [null, "BRANCH", function () {
    return [vm.$("RTXNAM")];
  }, ""], ["EXPERR", "SETAC", function () {
    return [vm.$("EMSGCL"), vm.$("ILLEOS")];
  }, "'ILLEGAL END OF STATEMENT'"], [null, "BRANCH", function () {
    return [vm.$("RTN1")];
  }, "Take error return"], ["FORWRD", "PROC", function () {
    return [null];
  }, "Procedure to get to next character"], [null, "STREAM", function () {
    return [vm.$("XSP"), vm.$("TEXTSP"), vm.$("FRWDTB"), vm.$("COMP3"), vm.$("FORRUN")];
  }, ""], ["FORJRN", "MOVD", function () {
    return [vm.$("BRTYPE"), vm.$("STYPE")];
  }, "Set up break type"], [null, "BRANCH", function () {
    return [vm.$("RTN2")];
  }, "Return"], ["FORRUN", "AEQLC", function () {
    return [vm.$("UNIT"), 0, null, vm.$("FOREOS")];
  }, "Check for input stream"], [null, "AEQLC", function () {
    return [vm.$("LISTCL"), 0, null, vm.$("FORRUR")];
  }, "Check listing switch"], [null, "STPRNT", function () {
    return [vm.$("IOKEY"), vm.$("OUTBLK"), vm.$("LNBFSP")];
  }, "Print card image"], ["FORRUR", "STREAD", function () {
    return [vm.$("INBFSP"), vm.$("UNIT"), vm.$("FORRUR"), vm.$("COMP5")];
  }, ""], [null, "SETSP", function () {
    return [vm.$("TEXTSP"), vm.$("NEXTSP")];
  }, "Set up new line"], [null, "STREAM", function () {
    return [vm.$("XSP"), vm.$("TEXTSP"), vm.$("CARDTB"), vm.$("COMP3"), vm.$("COMP3")];
  }, ""], [null, "RCALL", function () {
    return [null, vm.$("NEWCRD"), null, [vm.$("FORRUN"), vm.$("FORWRD")]];
  }, ""], ["FOREOS", "MOVD", function () {
    return [vm.$("BRTYPE"), vm.$("EOSCL")];
  }, "Set up end-of-card"], [null, "BRANCH", function () {
    return [vm.$("RTN2")];
  }, "Return"], ["FORBLK", "PROC", function () {
    return [vm.$("FORWRD")];
  }, "Procedure to get to nonblank"], [null, "STREAM", function () {
    return [vm.$("XSP"), vm.$("TEXTSP"), vm.$("IBLKTB"), vm.$("RTN1"), vm.$("FORRUN"), vm.$("FORJRN")];
  }, ""], ["NEWCRD", "PROC", function () {
    return [null];
  }, "Process new card image"], [null, "SELBRA", function () {
    return [vm.$("STYPE"), [null, vm.$("CMTCRD"), vm.$("CTLCRD"), vm.$("CNTCRD")]];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("LISTCL"), 0, null, vm.$("RTN3")];
  }, "Return if listing is off"], [null, "MOVD", function () {
    return [vm.$("XCL"), vm.$("CSTNCL")];
  }, "Copy of statement number"], [null, "INCRA", function () {
    return [vm.$("XCL"), 1];
  }, "Increment number"], [null, "INTSPC", function () {
    return [vm.$("TSP"), vm.$("XCL")];
  }, "Convert it to STRING"], [null, "AEQLC", function () {
    return [vm.$("LLIST"), 0, vm.$("CARDL")];
  }, "Check for left listing"], [null, "SETLC", function () {
    return [vm.$("RNOSP"), 0];
  }, "Clear right specifier"], [null, "APDSP", function () {
    return [vm.$("RNOSP"), vm.$("TSP")];
  }, "Set to statement number"], [null, "BRANCH", function () {
    return [vm.$("RTN3")];
  }, ""], ["CARDL", "SETLC", function () {
    return [vm.$("LNOSP"), 0];
  }, "Clear left specifier"], [null, "APDSP", function () {
    return [vm.$("LNOSP"), vm.$("TSP")];
  }, "Set to statement number"], [null, "BRANCH", function () {
    return [vm.$("RTN3")];
  }, ""], ["CMTCRD", "AEQLC", function () {
    return [vm.$("LISTCL"), 0, null, vm.$("RTN1")];
  }, "Return if listing is off"], ["CMTCLR", "SETLC", function () {
    return [vm.$("LNOSP"), 0];
  }, "Clear left specifier"], [null, "SETLC", function () {
    return [vm.$("RNOSP"), 0];
  }, "Clear right specifier"], [null, "APDSP", function () {
    return [vm.$("LNOSP"), vm.$("BLNSP")];
  }, "Blank left specifier"], [null, "APDSP", function () {
    return [vm.$("RNOSP"), vm.$("BLNSP")];
  }, "Blank right specifier"], [null, "BRANCH", function () {
    return [vm.$("RTN1")];
  }, ""], ["CNTCRD", "FSHRTN", function () {
    return [vm.$("TEXTSP"), 1];
  }, "Remove continue character"], [null, "AEQLC", function () {
    return [vm.$("LISTCL"), 0, null, vm.$("RTN2")];
  }, "Return if listing is off"], [null, "INTSPC", function () {
    return [vm.$("TSP"), vm.$("CSTNCL")];
  }, "Get specifier for number"], [null, "AEQLC", function () {
    return [vm.$("LLIST"), 0, vm.$("CARDLL")];
  }, "Check for left listing"], [null, "SETLC", function () {
    return [vm.$("RNOSP"), 0];
  }, "Clear right specifier"], [null, "APDSP", function () {
    return [vm.$("RNOSP"), vm.$("TSP")];
  }, "Set to statement number"], [null, "BRANCH", function () {
    return [vm.$("RTN2")];
  }, ""], ["CARDLL", "SETLC", function () {
    return [vm.$("LNOSP"), 0];
  }, "Clear left specifier"], [null, "APDSP", function () {
    return [vm.$("LNOSP"), vm.$("TSP")];
  }, "Set to statement number"], [null, "BRANCH", function () {
    return [vm.$("RTN2")];
  }, ""], ["CTLCRD", "FSHRTN", function () {
    return [vm.$("TEXTSP"), 1];
  }, "Delete control character"], [null, "STREAM", function () {
    return [vm.$("XSP"), vm.$("TEXTSP"), vm.$("FRWDTB"), vm.$("COMP3"), vm.$("CMTCRD")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("STYPE"), vm.$("NBTYP"), vm.$("CMTCRD")];
  }, "Verify nonbreak"], [null, "STREAM", function () {
    return [vm.$("XSP"), vm.$("TEXTSP"), vm.$("LBLXTB"), vm.$("CMTCLR"), vm.$("CMTCLR")];
  }, ""], [null, "LEXCMP", function () {
    return [vm.$("XSP"), vm.$("UNLSP"), vm.$("CTLCR1"), null, vm.$("CTLCR1")];
  }, ""], [null, "SETAC", function () {
    return [vm.$("LISTCL"), 0];
  }, "Zero listing switch"], [null, "BRANCH", function () {
    return [vm.$("RTN1")];
  }, "Return"], ["CTLCR1", "LEXCMP", function () {
    return [vm.$("XSP"), vm.$("LISTSP"), vm.$("CTLCR3"), null, vm.$("CTLCR3")];
  }, ""], [null, "SETAC", function () {
    return [vm.$("LISTCL"), 1];
  }, "Turn on listing"], [null, "STREAM", function () {
    return [vm.$("XSP"), vm.$("TEXTSP"), vm.$("FRWDTB"), vm.$("COMP3"), vm.$("CMTCLR")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("STYPE"), vm.$("NBTYP"), vm.$("CMTCLR")];
  }, "Verify nonbreak"], [null, "STREAM", function () {
    return [vm.$("XSP"), vm.$("TEXTSP"), vm.$("LBLXTB"), vm.$("CMTCLR"), vm.$("CMTCLR")];
  }, ""], [null, "LEXCMP", function () {
    return [vm.$("XSP"), vm.$("LEFTSP"), vm.$("CTLCR2"), null, vm.$("CTLCR2")];
  }, ""], [null, "SETAC", function () {
    return [vm.$("LLIST"), 1];
  }, "Set left listing switch"], [null, "BRANCH", function () {
    return [vm.$("CMTCLR")];
  }, "Join terminal processing"], ["CTLCR2", "SETAC", function () {
    return [vm.$("LLIST"), 0];
  }, "Zero left listing as default"], [null, "BRANCH", function () {
    return [vm.$("CMTCLR")];
  }, "Join terminal processing"], ["CTLCR3", "LEXCMP", function () {
    return [vm.$("XSP"), vm.$("EJCTSP"), vm.$("CMTCLR"), null, vm.$("CMTCLR")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("LISTCL"), 0, null, vm.$("CMTCLR")];
  }, "Skip eject if not listing"], [null, "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("EJECTF")];
  }, "Eject page"], [null, "BRANCH", function () {
    return [vm.$("CMTCLR")];
  }, "Join terminal processing"], ["TREPUB", "PROC", function () {
    return [null];
  }, "Publish code tree"], [null, "POP", function () {
    return [vm.$("YPTR")];
  }, "Restore root node"], ["TREPU1", "GETDC", function () {
    return [vm.$("XPTR"), vm.$("YPTR"), vm.$("CODE")];
  }, "Get code descriptor"], [null, "INCRA", function () {
    return [vm.$("CMOFCL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "PUTD", function () {
    return [vm.$("CMBSCL"), vm.$("CMOFCL"), vm.$("XPTR")];
  }, "Insert code descriptor"], [null, "SUM", function () {
    return [vm.$("ZPTR"), vm.$("CMBSCL"), vm.$("CMOFCL")];
  }, "Compute total position"], [null, "ACOMP", function () {
    return [vm.$("ZPTR"), vm.$("OCLIM"), vm.$("TREPU5")];
  }, "Check against limit"], ["TREPU4", "AEQLIC", function () {
    return [vm.$("YPTR"), vm.$("LSON"), 0, null, vm.$("TREPU2")];
  }, "Is there a left son?"], [null, "GETDC", function () {
    return [vm.$("YPTR"), vm.$("YPTR"), vm.$("LSON")];
  }, "Get left son"], [null, "BRANCH", function () {
    return [vm.$("TREPU1")];
  }, "Continue"], ["TREPU2", "AEQLIC", function () {
    return [vm.$("YPTR"), vm.$("RSIB"), 0, null, vm.$("TREPU3")];
  }, "Is there a right sibling?"], [null, "GETDC", function () {
    return [vm.$("YPTR"), vm.$("YPTR"), vm.$("RSIB")];
  }, "Get right sibling"], [null, "BRANCH", function () {
    return [vm.$("TREPU1")];
  }, "Continue"], ["TREPU3", "AEQLIC", function () {
    return [vm.$("YPTR"), vm.$("FATHER"), 0, null, vm.$("RTN1")];
  }, "Is there a father?"], [null, "GETDC", function () {
    return [vm.$("YPTR"), vm.$("YPTR"), vm.$("FATHER")];
  }, "Get father"], [null, "BRANCH", function () {
    return [vm.$("TREPU2")];
  }, "Continue"], ["TREPU5", "SUM", function () {
    return [vm.$("ZPTR"), vm.$("CMOFCL"), vm.$("CODELT")];
  }, "Compute additional to get"], [null, "SETVC", function () {
    return [vm.$("ZPTR"), vm.$("C")];
  }, "Insert CODE data type"], [null, "RCALL", function () {
    return [vm.$("XCL"), vm.$("BLOCK"), vm.$("ZPTR")];
  }, "Allocate new code block"], [null, "AEQLC", function () {
    return [vm.$("LPTR"), 0, null, vm.$("TREPU6")];
  }, "Is there a last label?"], [null, "PUTDC", function () {
    return [vm.$("LPTR"), vm.$("ATTRIB"), vm.$("XCL")];
  }, "Insert new code position"], ["TREPU6", "MOVBLK", function () {
    return [vm.$("XCL"), vm.$("CMBSCL"), vm.$("CMOFCL")];
  }, "Move old code"], [null, "PUTDC", function () {
    return [vm.$("CMBSCL"), vm.$("DESCR"), vm.$("GOTGCL")];
  }, "Insert direct goto"], [null, "PUTDC", function () {
    return [vm.$("CMBSCL"), 2 * vm.$("DESCR"), vm.$("LIT1CL")];
  }, "E3.7.1"], [null, "PUTDC", function () {
    return [vm.$("CMBSCL"), 3 * vm.$("DESCR"), vm.$("XCL")];
  }, "Insert pointer to new code"], [null, "INCRA", function () {
    return [vm.$("CMBSCL"), 3 * vm.$("DESCR")];
  }, "Update end pointer"], [null, "RCALL", function () {
    return [null, vm.$("SPLIT"), [vm.$("CMBSCL")]];
  }, "Split off old portion"], [null, "MOVD", function () {
    return [vm.$("CMBSCL"), vm.$("XCL")];
  }, "Set up new compiler base pointer"], [null, "SUM", function () {
    return [vm.$("OCLIM"), vm.$("CMBSCL"), vm.$("ZPTR")];
  }, "Compute new limit"], [null, "DECRA", function () {
    return [vm.$("OCLIM"), 5 * vm.$("DESCR")];
  }, "Leave safety factor"], [null, "BRANCH", function () {
    return [vm.$("TREPU4")];
  }, "Rejoin processing"], ["UNOP", "PROC", function () {
    return [null];
  }, "Unary operator analysis"], [null, "RCALL", function () {
    return [null, vm.$("FORWRD"), null, vm.$("COMP3")];
  }, "Get to next nonblank character"], [null, "SETAC", function () {
    return [vm.$("XPTR"), 0];
  }, "Zero code tree"], [null, "AEQLC", function () {
    return [vm.$("BRTYPE"), vm.$("NBTYP"), vm.$("RTN1")];
  }, "Verify nonbreak"], ["UNOPA", "STREAM", function () {
    return [vm.$("XSP"), vm.$("TEXTSP"), vm.$("UNOPTB"), vm.$("RTXNAM"), vm.$("RTN1")];
  }, "E3.4.3"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("BLOCK"), vm.$("CNDSIZ")];
  }, "Allocate block for tree node"], [null, "PUTDC", function () {
    return [vm.$("YPTR"), vm.$("CODE"), vm.$("STYPE")];
  }, "Insert function descriptor"], [null, "AEQLC", function () {
    return [vm.$("XPTR"), 0, null, vm.$("UNOPB")];
  }, "Is tree empty"], [null, "ADDSON", function () {
    return [vm.$("XPTR"), vm.$("YPTR")];
  }, "Add new node as son"], ["UNOPB", "MOVD", function () {
    return [vm.$("XPTR"), vm.$("YPTR")];
  }, "Move to new node"], [null, "BRANCH", function () {
    return [vm.$("UNOPA")];
  }, "Continue"], [null, "TITLE", function () {
    return ["Interpreter Executive and Control Procedures"];
  }, ""], ["BASE", "PROC", function () {
    return [null];
  }, "Interpreter code basing procedure"], [null, "SUM", function () {
    return [vm.$("OCBSCL"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Add offset to base"], [null, "SETAC", function () {
    return [vm.$("OCICL"), 0];
  }, "Zero offset"], [null, "BRANCH", function () {
    return [vm.$("RTNUL3")];
  }, ""], ["GOTG", "PROC", function () {
    return [null];
  }, ":<X>"], [null, "RCALL", function () {
    return [vm.$("OCBSCL"), vm.$("ARGVAL"), null, vm.$("INTR5")];
  }, ""], [null, "VEQLC", function () {
    return [vm.$("OCBSCL"), vm.$("C"), vm.$("INTR4")];
  }, "Must have CODE data type"], [null, "SETAC", function () {
    return [vm.$("OCICL"), 0];
  }, "Zero offset"], [null, "BRANCH", function () {
    return [vm.$("RTNUL3")];
  }, ""], ["GOTL", "PROC", function () {
    return [null];
  }, ":(X)"], [null, "INCRA", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("XPTR"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get object code descriptor"], [null, "TESTF", function () {
    return [vm.$("XPTR"), vm.$("FNC"), null, vm.$("GOTLC")];
  }, "Test for function"], ["GOTLV", "ACOMPC", function () {
    return [vm.$("TRAPCL"), 0, null, vm.$("GOTLV1"), vm.$("GOTLV1")];
  }, ""], [null, "LOCAPT", function () {
    return [vm.$("ATPTR"), vm.$("TLABL"), vm.$("XPTR"), vm.$("GOTLV1")];
  }, ""], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save variable"], [null, "RCALL", function () {
    return [null, vm.$("TRPHND"), vm.$("ATPTR")];
  }, "E3.3.1"], [null, "POP", function () {
    return [vm.$("XPTR")];
  }, "Restore variable"], ["GOTLV1", "DEQL", function () {
    return [vm.$("XPTR"), vm.$("RETCL"), vm.$("GOTL1")];
  }, "Compare with RETURN"], [null, "RRTURN", function () {
    return [null, 6];
  }, "Return by value"], ["GOTL1", "DEQL", function () {
    return [vm.$("XPTR"), vm.$("FRETCL"), vm.$("GOTL2")];
  }, "Compare with FRETURN"], [null, "RRTURN", function () {
    return [null, 4];
  }, "Fail"], ["GOTL2", "DEQL", function () {
    return [vm.$("XPTR"), vm.$("NRETCL"), vm.$("GOTL3")];
  }, "Compare with NRETURN"], [null, "RRTURN", function () {
    return [null, 5];
  }, "Return by name"], ["GOTL3", "GETDC", function () {
    return [vm.$("OCBSCL"), vm.$("XPTR"), vm.$("ATTRIB")];
  }, "Get object code base"], [null, "AEQLC", function () {
    return [vm.$("OCBSCL"), 0, null, vm.$("INTR4")];
  }, "Must not be zero"], [null, "SETAC", function () {
    return [vm.$("OCICL"), 0];
  }, "Zero offset"], [null, "BRANCH", function () {
    return [vm.$("RTNUL3")];
  }, "Return"], ["GOTLC", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("INVOKE"), vm.$("XPTR"), [vm.$("INTR5"), null, vm.$("INTR4")]];
  }, "E3.10.3"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("S"), vm.$("INTR4"), vm.$("GOTLV")];
  }, "Variable must be STRING"], ["GOTO", "PROC", function () {
    return [null];
  }, "Interpreter goto procedure"], [null, "INCRA", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("OCICL"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get offset"], [null, "BRANCH", function () {
    return [vm.$("RTNUL3")];
  }, "Return"], ["INIT", "PROC", function () {
    return [null];
  }, "Statement initialization procedure"], [null, "MOVD", function () {
    return [vm.$("LSTNCL"), vm.$("STNOCL")];
  }, "Update &LASTNO"], [null, "INCRA", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("XCL"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get statement data"], [null, "MOVA", function () {
    return [vm.$("STNOCL"), vm.$("XCL")];
  }, "Update &STNO"], [null, "SETAV", function () {
    return [vm.$("FRTNCL"), vm.$("XCL")];
  }, "Set up failure offset"], [null, "ACOMP", function () {
    return [vm.$("EXNOCL"), vm.$("EXLMCL"), vm.$("EXEX"), vm.$("EXEX")];
  }, ""], [null, "INCRA", function () {
    return [vm.$("EXNOCL"), 1];
  }, "Increment &STCOUNT"], [null, "ACOMPC", function () {
    return [vm.$("TRAPCL"), 0, null, vm.$("RTNUL3"), vm.$("RTNUL3")];
  }, ""], [null, "LOCAPT", function () {
    return [vm.$("ATPTR"), vm.$("TKEYL"), vm.$("STCTKY"), vm.$("RTNUL3")];
  }, ""], [null, "RCALL", function () {
    return [null, vm.$("TRPHND"), vm.$("ATPTR")];
  }, "E3.3.1"], [null, "BRANCH", function () {
    return [vm.$("RTNUL3")];
  }, ""], ["INTERP", "PROC", function () {
    return [null];
  }, "Interpreter core procedure"], [null, "INCRA", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("XPTR"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get object code descriptor"], [null, "TESTF", function () {
    return [vm.$("XPTR"), vm.$("FNC"), vm.$("INTERP")];
  }, "Test for function"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("INVOKE"), [vm.$("XPTR")], [null, vm.$("INTERP"), vm.$("INTERP"), vm.$("RTN1"), vm.$("RTN2"), vm.$("RTN3")]];
  }, ""], [null, "MOVD", function () {
    return [vm.$("OCICL"), vm.$("FRTNCL")];
  }, "Set offset for failure"], [null, "INCRA", function () {
    return [vm.$("FALCL"), 1];
  }, "Increment &STFCOUNT"], [null, "ACOMPC", function () {
    return [vm.$("TRAPCL"), 0, null, vm.$("INTERP"), vm.$("INTERP")];
  }, ""], [null, "LOCAPT", function () {
    return [vm.$("ATPTR"), vm.$("TKEYL"), vm.$("FALKY"), vm.$("INTERP")];
  }, ""], [null, "RCALL", function () {
    return [null, vm.$("TRPHND"), vm.$("ATPTR")];
  }, "E3.3.1"], [null, "BRANCH", function () {
    return [vm.$("INTERP")];
  }, ""], ["INVOKE", "PROC", function () {
    return [null];
  }, "Invokation procedure"], [null, "POP", function () {
    return [vm.$("INCL")];
  }, "Get function index"], [null, "GETDC", function () {
    return [vm.$("XPTR"), vm.$("INCL"), 0];
  }, "Get procedure descriptor"], [null, "VEQL", function () {
    return [vm.$("INCL"), vm.$("XPTR"), vm.$("INVK2")];
  }, "Check argument counts"], ["INVK1", "BRANIC", function () {
    return [vm.$("INCL"), 0];
  }, "If equal, branch indirect"], ["INVK2", "TESTF", function () {
    return [vm.$("XPTR"), vm.$("FNC"), vm.$("ARGNER"), vm.$("INVK1")];
  }, ""], [null, "TITLE", function () {
    return ["Argument Evaluation Procedures"];
  }, ""], ["ARGVAL", "PROC", function () {
    return [null];
  }, "Procedure to evaluate argument"], [null, "INCRA", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Increment interpreter offset"], [null, "GETD", function () {
    return [vm.$("XPTR"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get argument"], [null, "TESTF", function () {
    return [vm.$("XPTR"), vm.$("FNC"), null, vm.$("ARGVC")];
  }, "Test for function descriptor"], ["ARGV1", "AEQLC", function () {
    return [vm.$("INSW"), 0, null, vm.$("ARGV2")];
  }, "Check &INPUT"], [null, "LOCAPV", function () {
    return [vm.$("ZPTR"), vm.$("INATL"), vm.$("XPTR"), vm.$("ARGV2")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("ZPTR"), vm.$("DESCR")];
  }, "Get input descriptor"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("PUTIN"), [vm.$("ZPTR"), vm.$("XPTR")], [vm.$("FAIL"), vm.$("RTXNAM")]];
  }, ""], ["ARGVC", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("INVOKE"), [vm.$("XPTR")], [vm.$("FAIL"), vm.$("ARGV1"), vm.$("RTXNAM")]];
  }, ""], ["ARGV2", "GETDC", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), vm.$("DESCR")];
  }, "Get value from name"], [null, "BRANCH", function () {
    return [vm.$("RTXNAM")];
  }, ""], ["EXPVAL", "PROC", function () {
    return [null];
  }, "Procedure to evaluate expression"], [null, "SETAC", function () {
    return [vm.$("SCL"), 1];
  }, "Note procedure entrance"], ["EXPVJN", "POP", function () {
    return [vm.$("XPTR")];
  }, "Restore pointer to object code"], ["EXPVJ2", "PUSH", function () {
    return [[vm.$("OCBSCL"), vm.$("OCICL"), vm.$("PATBCL"), vm.$("PATICL"), vm.$("WPTR"), vm.$("XCL"), vm.$("YCL"), vm.$("TCL")]];
  }, ""], [null, "PUSH", function () {
    return [[vm.$("MAXLEN"), vm.$("LENFCL"), vm.$("PDLPTR"), vm.$("PDLHED"), vm.$("NAMICL"), vm.$("NHEDCL")]];
  }, ""], [null, "SPUSH", function () {
    return [[vm.$("HEADSP"), vm.$("TSP"), vm.$("TXSP"), vm.$("XSP")]];
  }, ""], [null, "MOVD", function () {
    return [vm.$("OCBSCL"), vm.$("XPTR")];
  }, "Set up new code base"], [null, "SETAC", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Initialize offset"], [null, "MOVD", function () {
    return [vm.$("PDLHED"), vm.$("PDLPTR")];
  }, "Set up new history list header"], [null, "MOVD", function () {
    return [vm.$("NHEDCL"), vm.$("NAMICL")];
  }, "Set up new name list header"], [null, "GETD", function () {
    return [vm.$("XPTR"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get object code descriptor"], [null, "TESTF", function () {
    return [vm.$("XPTR"), vm.$("FNC"), null, vm.$("EXPVC")];
  }, "Check for function"], ["EXPV11", "AEQLC", function () {
    return [vm.$("SCL"), 0, null, vm.$("EXPV6")];
  }, "Check procedure entry"], [null, "AEQLC", function () {
    return [vm.$("INSW"), 0, null, vm.$("EXPV4")];
  }, "Check &INPUT"], [null, "LOCAPV", function () {
    return [vm.$("ZPTR"), vm.$("INATL"), vm.$("XPTR"), vm.$("EXPV4")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("ZPTR"), vm.$("DESCR")];
  }, "Get input association"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("PUTIN"), [vm.$("ZPTR"), vm.$("XPTR")], [vm.$("EXPV1"), vm.$("EXPV6")]];
  }, ""], ["EXPV4", "GETDC", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), vm.$("DESCR")];
  }, "Get value"], ["EXPV6", "SETAC", function () {
    return [vm.$("SCL"), 2];
  }, "Set up exit"], [null, "BRANCH", function () {
    return [vm.$("EXPV7")];
  }, "Join processing"], ["EXPV9", "POP", function () {
    return [vm.$("SCL")];
  }, "Popoff switch"], ["EXPV1", "SETAC", function () {
    return [vm.$("SCL"), 1];
  }, "Set new exit switch"], ["EXPV7", "SPOP", function () {
    return [[vm.$("XSP"), vm.$("TXSP"), vm.$("TSP"), vm.$("HEADSP")]];
  }, ""], [null, "POP", function () {
    return [[vm.$("NHEDCL"), vm.$("NAMICL"), vm.$("PDLHED"), vm.$("PDLPTR"), vm.$("LENFCL"), vm.$("MAXLEN")]];
  }, ""], [null, "POP", function () {
    return [[vm.$("TCL"), vm.$("YCL"), vm.$("XCL"), vm.$("WPTR"), vm.$("PATICL"), vm.$("PATBCL"), vm.$("OCICL"), vm.$("OCBSCL")]];
  }, ""], [null, "SELBRA", function () {
    return [vm.$("SCL"), [vm.$("FAIL"), vm.$("RTXNAM"), vm.$("RTZPTR")]];
  }, ""], ["EXPVC", "PUSH", function () {
    return [vm.$("SCL")];
  }, "Save entrance indicator"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("INVOKE"), vm.$("XPTR")];
  }, "(EXPV9,EXPV5,)"], [null, "POP", function () {
    return [vm.$("SCL")];
  }, "Restore entrance indicator"], [null, "AEQLC", function () {
    return [vm.$("SCL"), 0, vm.$("EXPV6")];
  }, "Check entry indicator"], [null, "SETAC", function () {
    return [vm.$("SCL"), 3];
  }, "Set exit switch"], [null, "MOVD", function () {
    return [vm.$("ZPTR"), vm.$("XPTR")];
  }, "Set up value"], [null, "BRANCH", function () {
    return [vm.$("EXPV7")];
  }, "Join end processing"], ["EXPV5", "POP", function () {
    return [vm.$("SCL")];
  }, "Restore entry indicator"], [null, "BRANCH", function () {
    return [vm.$("EXPV11")];
  }, "Join processing with name"], ["EXPEVL", "PROC", function () {
    return [vm.$("EXPVAL")];
  }, "Procedure to get expression value"], [null, "SETAC", function () {
    return [vm.$("SCL"), 0];
  }, "Set entry indicator"], [null, "BRANCH", function () {
    return [vm.$("EXPVJN")];
  }, "Join processing"], ["EVAL", "PROC", function () {
    return [vm.$("EXPVAL")];
  }, "EVAL(X)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("ARGVAL"), null, vm.$("FAIL")];
  }, "Get argument"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("E"), null, vm.$("EVAL1")];
  }, "Is it EXPRESSION?"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("I"), null, vm.$("RTXPTR")];
  }, "INTEGER is idempotent"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("R"), null, vm.$("RTXPTR")];
  }, "REAL is idempotent"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("S"), vm.$("INTR1")];
  }, "Is it STRING?"], [null, "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier"], [null, "LEQLC", function () {
    return [vm.$("XSP"), 0, null, vm.$("RTXPTR")];
  }, "E3.1.4"], [null, "SPCINT", function () {
    return [vm.$("XPTR"), vm.$("XSP"), null, vm.$("RTXPTR")];
  }, "Convert to INTEGER"], [null, "SPREAL", function () {
    return [vm.$("XPTR"), vm.$("XSP"), null, vm.$("RTXPTR")];
  }, "Convert to REAL"], [null, "MOVD", function () {
    return [vm.$("ZPTR"), vm.$("XPTR")];
  }, "Set up to convert to EXPRESSION"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("CONVE"), null, [vm.$("FAIL"), vm.$("INTR10")]];
  }, ""], ["EVAL1", "SETAC", function () {
    return [vm.$("SCL"), 0];
  }, "Set up entry indicator"], [null, "BRANCH", function () {
    return [vm.$("EXPVJ2")];
  }, "Join processing"], ["INTVAL", "PROC", function () {
    return [null];
  }, "Integer argument procedure"], [null, "INCRA", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("XPTR"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get object code descriptor"], [null, "TESTF", function () {
    return [vm.$("XPTR"), vm.$("FNC"), null, vm.$("INTVC")];
  }, "Check for function"], ["INTV1", "AEQLC", function () {
    return [vm.$("INSW"), 0, null, vm.$("INTV3")];
  }, "Check &INPUT"], [null, "LOCAPV", function () {
    return [vm.$("ZPTR"), vm.$("INATL"), vm.$("XPTR"), vm.$("INTV3")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("ZPTR"), vm.$("DESCR")];
  }, "Get association"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("PUTIN"), [vm.$("ZPTR"), vm.$("XPTR")], vm.$("FAIL")];
  }, ""], ["INTV", "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier for string"], [null, "SPCINT", function () {
    return [vm.$("XPTR"), vm.$("XSP"), vm.$("INTR1"), vm.$("RTXNAM")];
  }, ""], ["INTV3", "GETDC", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), vm.$("DESCR")];
  }, "Get value"], ["INTV2", "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("I"), null, vm.$("RTXNAM")];
  }, "INTEGER desired"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("S"), vm.$("INTR1"), vm.$("INTV")];
  }, "STRING must be converted"], ["INTVC", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("INVOKE"), [vm.$("XPTR")], [vm.$("FAIL"), vm.$("INTV1"), vm.$("INTV2")]];
  }, ""], ["PATVAL", "PROC", function () {
    return [null];
  }, "Evaluate argument as pattern"], [null, "INCRA", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("XPTR"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get object code descriptor"], [null, "TESTF", function () {
    return [vm.$("XPTR"), vm.$("FNC"), null, vm.$("PATVC")];
  }, "Check for function descriptor"], ["PATV1", "AEQLC", function () {
    return [vm.$("INSW"), 0, null, vm.$("PATV2")];
  }, "Check &INPUT"], [null, "LOCAPV", function () {
    return [vm.$("ZPTR"), vm.$("INATL"), vm.$("XPTR"), vm.$("PATV2")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("ZPTR"), vm.$("DESCR")];
  }, "Get association"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("PUTIN"), [vm.$("ZPTR"), vm.$("XPTR")], [vm.$("FAIL"), vm.$("RTXNAM")]];
  }, ""], ["PATVC", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("INVOKE"), [vm.$("XPTR")], [vm.$("FAIL"), vm.$("PATV1"), vm.$("PATV3")]];
  }, ""], ["PATV2", "GETDC", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), vm.$("DESCR")];
  }, "Get value"], ["PATV3", "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("P"), null, vm.$("RTXNAM")];
  }, "Is it PATTERN?"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("S"), null, vm.$("RTXNAM")];
  }, "Is it STRING?"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("I"), null, vm.$("GENVIX")];
  }, "Is it INTEGER?"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("R"), null, vm.$("PATVR")];
  }, "Is it REAL?"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("E"), vm.$("INTR1")];
  }, "Is it EXPRESSION?"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("STARSZ")];
  }, "Allocate block for pattern"], [null, "MOVBLK", function () {
    return [vm.$("TPTR"), vm.$("STRPAT"), vm.$("STARSZ")];
  }, "Copy pattern for expression"], [null, "PUTDC", function () {
    return [vm.$("TPTR"), 4 * vm.$("DESCR"), vm.$("XPTR")];
  }, "Insert expression"], [null, "MOVD", function () {
    return [vm.$("XPTR"), vm.$("TPTR")];
  }, "Set up value"], [null, "BRANCH", function () {
    return [vm.$("RTXNAM")];
  }, "Return"], ["PATVR", "REALST", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Convert REAL to STRING"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), vm.$("XSPPTR"), vm.$("RTXNAM")];
  }, ""], ["VARVAL", "PROC", function () {
    return [null];
  }, "Evaluate argument as string"], [null, "INCRA", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("XPTR"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get object code descriptor"], [null, "TESTF", function () {
    return [vm.$("XPTR"), vm.$("FNC"), null, vm.$("VARVC")];
  }, "Check for function"], ["VARV1", "AEQLC", function () {
    return [vm.$("INSW"), 0, null, vm.$("VARV4")];
  }, "Check &INPUT"], [null, "LOCAPV", function () {
    return [vm.$("ZPTR"), vm.$("INATL"), vm.$("XPTR"), vm.$("VARV4")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("ZPTR"), vm.$("DESCR")];
  }, "Get input association"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("PUTIN"), [vm.$("ZPTR"), vm.$("XPTR")], [vm.$("FAIL"), vm.$("RTXNAM")]];
  }, ""], ["VARV4", "GETDC", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), vm.$("DESCR")];
  }, "Get value"], ["VARV2", "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("S"), null, vm.$("RTXNAM")];
  }, "Is it STRING?"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("I"), vm.$("INTR1"), vm.$("GENVIX")];
  }, "Convert INTEGER to STRING"], ["VARVC", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("INVOKE"), [vm.$("XPTR")], [vm.$("FAIL"), vm.$("VARV1"), vm.$("VARV2")]];
  }, ""], ["XYARGS", "PROC", function () {
    return [null];
  }, "Procedure to evaluate argument pair"], [null, "SETAC", function () {
    return [vm.$("SCL"), 0];
  }, "Note first argument"], ["XYN", "INCRA", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("YPTR"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get object code descriptor"], [null, "TESTF", function () {
    return [vm.$("YPTR"), vm.$("FNC"), null, vm.$("XYC")];
  }, "Check for function"], ["XY1", "AEQLC", function () {
    return [vm.$("INSW"), 0, null, vm.$("XY2")];
  }, "Check &INPUT"], [null, "LOCAPV", function () {
    return [vm.$("ZPTR"), vm.$("INATL"), vm.$("YPTR"), vm.$("XY2")];
  }, "Look for input association"], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("ZPTR"), vm.$("DESCR")];
  }, "Get input association"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("PUTIN"), [vm.$("ZPTR"), vm.$("YPTR")], vm.$("FAIL")];
  }, ""], ["XY3", "AEQLC", function () {
    return [vm.$("SCL"), 0, vm.$("RTN2")];
  }, "Check for completion"], [null, "SETAC", function () {
    return [vm.$("SCL"), 1];
  }, "Note seconf argument"], [null, "MOVD", function () {
    return [vm.$("XPTR"), vm.$("YPTR")];
  }, "Set up first argument"], [null, "BRANCH", function () {
    return [vm.$("XYN")];
  }, "Go around again"], ["XY2", "GETDC", function () {
    return [vm.$("YPTR"), vm.$("YPTR"), vm.$("DESCR")];
  }, "Get value"], [null, "BRANCH", function () {
    return [vm.$("XY3")];
  }, "Continue"], ["XYC", "PUSH", function () {
    return [[vm.$("SCL"), vm.$("XPTR")]];
  }, "Save indicator and argument"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("INVOKE"), [vm.$("YPTR")], [vm.$("FAIL"), vm.$("XY4")]];
  }, ""], [null, "POP", function () {
    return [[vm.$("XPTR"), vm.$("SCL")]];
  }, "Restore indicator and argument"], [null, "BRANCH", function () {
    return [vm.$("XY3")];
  }, "Join processing"], ["XY4", "POP", function () {
    return [[vm.$("XPTR"), vm.$("SCL")]];
  }, "Restore indicator and argument"], [null, "BRANCH", function () {
    return [vm.$("XY1")];
  }, "Join processing"], [null, "TITLE", function () {
    return ["Arithmetic Operations, Predicates, and Functions"];
  }, ""], ["ADD", "PROC", function () {
    return [null];
  }, "X + Y"], [null, "SETAC", function () {
    return [vm.$("SCL"), 1];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("ARITH")];
  }, ""], ["DIV", "PROC", function () {
    return [vm.$("ADD")];
  }, "X / Y"], [null, "SETAC", function () {
    return [vm.$("SCL"), 2];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("ARITH")];
  }, ""], ["EXP", "PROC", function () {
    return [vm.$("ADD")];
  }, "X ** Y and X ^ Y"], [null, "SETAC", function () {
    return [vm.$("SCL"), 3];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("ARITH")];
  }, ""], ["MPY", "PROC", function () {
    return [vm.$("ADD")];
  }, "X * Y"], [null, "SETAC", function () {
    return [vm.$("SCL"), 4];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("ARITH")];
  }, ""], ["SUB", "PROC", function () {
    return [vm.$("ADD")];
  }, "X - Y"], [null, "SETAC", function () {
    return [vm.$("SCL"), 5];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("ARITH")];
  }, ""], ["EQ", "PROC", function () {
    return [vm.$("ADD")];
  }, "EQ(X,Y)"], [null, "SETAC", function () {
    return [vm.$("SCL"), 6];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("ARITH")];
  }, ""], ["GE", "PROC", function () {
    return [vm.$("ADD")];
  }, "GE(X,Y)"], [null, "SETAC", function () {
    return [vm.$("SCL"), 7];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("ARITH")];
  }, ""], ["GT", "PROC", function () {
    return [vm.$("ADD")];
  }, "GT(X,Y)"], [null, "SETAC", function () {
    return [vm.$("SCL"), 8];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("ARITH")];
  }, ""], ["LE", "PROC", function () {
    return [vm.$("ADD")];
  }, "LE(X,Y)"], [null, "SETAC", function () {
    return [vm.$("SCL"), 9];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("ARITH")];
  }, ""], ["LT", "PROC", function () {
    return [vm.$("ADD")];
  }, "LT(X,Y)"], [null, "SETAC", function () {
    return [vm.$("SCL"), 10];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("ARITH")];
  }, ""], ["NE", "PROC", function () {
    return [vm.$("ADD")];
  }, "NE(X,Y)"], [null, "SETAC", function () {
    return [vm.$("SCL"), 11];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("ARITH")];
  }, ""], ["REMDR", "PROC", function () {
    return [vm.$("ADD")];
  }, "REMDR(X,Y)"], [null, "SETAC", function () {
    return [vm.$("SCL"), 12];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("ARITH")];
  }, ""], ["ARITH", "PUSH", function () {
    return [vm.$("SCL")];
  }, "Save procedure switch"], [null, "RCALL", function () {
    return [null, vm.$("XYARGS"), null, vm.$("FAIL")];
  }, "Evaluate arguments"], [null, "POP", function () {
    return [vm.$("SCL")];
  }, "Restore procedure switch"], [null, "SETAV", function () {
    return [vm.$("DTCL"), vm.$("XPTR")];
  }, "Set up data type pair"], [null, "MOVV", function () {
    return [vm.$("DTCL"), vm.$("YPTR")];
  }, ""], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("IIDTP"), null, vm.$("ARTHII")];
  }, "INTEGER-INTEGER"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("IVDTP"), null, vm.$("ARTHIV")];
  }, "INTEGER-STRING"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("VIDTP"), null, vm.$("ARTHVI")];
  }, "STRING-INTEGER"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("VVDTP"), null, vm.$("ARTHVV")];
  }, "STRING-STRING"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("RRDTP"), null, vm.$("ARTHRR")];
  }, "REAL-REAL"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("IRDTP"), null, vm.$("ARTHIR")];
  }, "INTEGER-REAL"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("RIDTP"), null, vm.$("ARTHRI")];
  }, "REAL-INTEGER"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("VRDTP"), null, vm.$("ARTHVR")];
  }, "STRING-REAL"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("RVDTP"), vm.$("INTR1"), vm.$("ARTHRV")];
  }, ""], ["ARTHII", "SELBRA", function () {
    return [vm.$("SCL"), [vm.$("AD"), vm.$("DV"), vm.$("EX"), vm.$("MP"), vm.$("SB"), vm.$("CEQ"), vm.$("CGE"), vm.$("CGT"), vm.$("CLE"), vm.$("CLT"), vm.$("CNE"), vm.$("RM")]];
  }, ""], ["ARTHVI", "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier"], [null, "SPCINT", function () {
    return [vm.$("XPTR"), vm.$("XSP"), null, vm.$("ARTHII")];
  }, "Convert string to integer"], [null, "SPREAL", function () {
    return [vm.$("XPTR"), vm.$("XSP"), vm.$("INTR1"), vm.$("ARTHRI")];
  }, ""], ["ARTHIV", "LOCSP", function () {
    return [vm.$("YSP"), vm.$("YPTR")];
  }, "Get specifier"], [null, "SPCINT", function () {
    return [vm.$("YPTR"), vm.$("YSP"), null, vm.$("ARTHII")];
  }, "Convert string to integer"], [null, "SPREAL", function () {
    return [vm.$("YPTR"), vm.$("YSP"), vm.$("INTR1"), vm.$("ARTHIR")];
  }, ""], ["ARTHVV", "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier"], [null, "SPCINT", function () {
    return [vm.$("XPTR"), vm.$("XSP"), null, vm.$("ARTHIV")];
  }, "Convert string to integer"], [null, "SPREAL", function () {
    return [vm.$("XPTR"), vm.$("XSP"), vm.$("INTR1"), vm.$("ARTHRV")];
  }, ""], ["ARTHRR", "SELBRA", function () {
    return [vm.$("SCL"), [vm.$("AR"), vm.$("DR"), vm.$("EXR"), vm.$("MR"), vm.$("SR"), vm.$("REQ"), vm.$("RGE"), vm.$("RGT"), vm.$("RLE"), vm.$("RLT"), vm.$("RNE"), vm.$("INTR1")]];
  }, ""], ["ARTHIR", "INTRL", function () {
    return [vm.$("XPTR"), vm.$("XPTR")];
  }, "Convert integer to real"], [null, "BRANCH", function () {
    return [vm.$("ARTHRR")];
  }, ""], ["ARTHRI", "INTRL", function () {
    return [vm.$("YPTR"), vm.$("YPTR")];
  }, "Convert integer to real"], [null, "BRANCH", function () {
    return [vm.$("ARTHRR")];
  }, ""], ["ARTHVR", "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get spedifier"], [null, "SPCINT", function () {
    return [vm.$("XPTR"), vm.$("XSP"), null, vm.$("ARTHIR")];
  }, "Convert string to integer"], [null, "SPREAL", function () {
    return [vm.$("XPTR"), vm.$("XSP"), vm.$("INTR1"), vm.$("ARTHRR")];
  }, ""], ["ARTHRV", "LOCSP", function () {
    return [vm.$("YSP"), vm.$("YPTR")];
  }, ""], [null, "SPCINT", function () {
    return [vm.$("YPTR"), vm.$("YSP"), null, vm.$("ARTHRI")];
  }, "Convert string to integer"], [null, "SPREAL", function () {
    return [vm.$("YPTR"), vm.$("YSP"), vm.$("INTR1"), vm.$("ARTHRR")];
  }, ""], ["AD", "SUM", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("YPTR"), vm.$("AERROR"), vm.$("ARTN")];
  }, ""], ["DV", "DIVIDE", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("YPTR"), vm.$("AERROR"), vm.$("ARTN")];
  }, ""], ["EX", "EXPINT", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("YPTR"), vm.$("AERROR"), vm.$("ARTN")];
  }, ""], ["MP", "MULT", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("YPTR"), vm.$("AERROR"), vm.$("ARTN")];
  }, ""], ["SB", "SUBTRT", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("YPTR"), vm.$("AERROR"), vm.$("ARTN")];
  }, ""], ["CEQ", "AEQL", function () {
    return [vm.$("XPTR"), vm.$("YPTR"), vm.$("FAIL"), vm.$("RETNUL")];
  }, ""], ["CGE", "ACOMP", function () {
    return [vm.$("XPTR"), vm.$("YPTR"), vm.$("RETNUL"), vm.$("RETNUL"), vm.$("FAIL")];
  }, ""], ["CGT", "ACOMP", function () {
    return [vm.$("XPTR"), vm.$("YPTR"), vm.$("RETNUL"), vm.$("FAIL"), vm.$("FAIL")];
  }, ""], ["CLE", "ACOMP", function () {
    return [vm.$("XPTR"), vm.$("YPTR"), vm.$("FAIL"), vm.$("RETNUL"), vm.$("RETNUL")];
  }, ""], ["CLT", "ACOMP", function () {
    return [vm.$("XPTR"), vm.$("YPTR"), vm.$("FAIL"), vm.$("FAIL"), vm.$("RETNUL")];
  }, ""], ["CNE", "AEQL", function () {
    return [vm.$("XPTR"), vm.$("YPTR"), vm.$("RETNUL"), vm.$("FAIL")];
  }, ""], ["AR", "ADREAL", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("YPTR"), vm.$("AERROR"), vm.$("ARTN")];
  }, ""], ["DR", "DVREAL", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("YPTR"), vm.$("AERROR"), vm.$("ARTN")];
  }, ""], ["EXR", "EXREAL", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("YPTR"), vm.$("AERROR"), vm.$("ARTN")];
  }, ""], ["MR", "MPREAL", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("YPTR"), vm.$("AERROR"), vm.$("ARTN")];
  }, ""], ["SR", "SBREAL", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("YPTR"), vm.$("AERROR"), vm.$("ARTN")];
  }, ""], ["REQ", "RCOMP", function () {
    return [vm.$("XPTR"), vm.$("YPTR"), vm.$("FAIL"), vm.$("RETNUL"), vm.$("FAIL")];
  }, ""], ["RGE", "RCOMP", function () {
    return [vm.$("XPTR"), vm.$("YPTR"), vm.$("RETNUL"), vm.$("RETNUL"), vm.$("FAIL")];
  }, ""], ["RGT", "RCOMP", function () {
    return [vm.$("XPTR"), vm.$("YPTR"), vm.$("RETNUL"), vm.$("FAIL"), vm.$("FAIL")];
  }, ""], ["RLE", "RCOMP", function () {
    return [vm.$("XPTR"), vm.$("YPTR"), vm.$("FAIL"), vm.$("RETNUL"), vm.$("RETNUL")];
  }, ""], ["RLT", "RCOMP", function () {
    return [vm.$("XPTR"), vm.$("YPTR"), vm.$("FAIL"), vm.$("FAIL"), vm.$("RETNUL")];
  }, ""], ["RNE", "RCOMP", function () {
    return [vm.$("XPTR"), vm.$("YPTR"), vm.$("RETNUL"), vm.$("FAIL"), vm.$("RETNUL")];
  }, ""], ["RM", "DIVIDE", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("YPTR"), vm.$("AERROR")];
  }, ""], [null, "MULT", function () {
    return [vm.$("WPTR"), vm.$("ZPTR"), vm.$("YPTR")];
  }, "Multiply truncated part"], [null, "SUBTRT", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("WPTR")];
  }, "Get difference"], [null, "BRANCH", function () {
    return [vm.$("ARTN")];
  }, ""], ["INTGER", "PROC", function () {
    return [null];
  }, "INTEGER(X)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("ARGVAL"), null, vm.$("FAIL")];
  }, "Get argument"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("I"), null, vm.$("RETNUL")];
  }, "INTEGER succeeds"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("S"), vm.$("FAIL")];
  }, "STRING must be checked"], [null, "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier"], [null, "SPCINT", function () {
    return [vm.$("XPTR"), vm.$("XSP"), vm.$("FAIL"), vm.$("RETNUL")];
  }, ""], ["MNS", "PROC", function () {
    return [null];
  }, "-X"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("ARGVAL"), null, vm.$("FAIL")];
  }, "Get argument"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("I"), null, vm.$("MNSM")];
  }, "INTEGER acceptable"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("S"), null, vm.$("MNSV")];
  }, "STRING must be converted"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("R"), vm.$("INTR1"), vm.$("MNSR")];
  }, "REAL is acceptable"], ["MNSM", "MNSINT", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("AERROR"), vm.$("ARTN")];
  }, ""], ["MNSV", "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier for string"], [null, "SPCINT", function () {
    return [vm.$("XPTR"), vm.$("XSP"), null, vm.$("MNSM")];
  }, "Convert to INTEGER"], [null, "SPREAL", function () {
    return [vm.$("XPTR"), vm.$("XSP"), vm.$("INTR1")];
  }, "Convert to REAL"], ["MNSR", "MNREAL", function () {
    return [vm.$("ZPTR"), vm.$("XPTR")];
  }, "Form negative of real"], [null, "BRANCH", function () {
    return [vm.$("ARTN")];
  }, ""], ["PLS", "PROC", function () {
    return [null];
  }, "+X"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("ARGVAL"), null, vm.$("FAIL")];
  }, "Get argument"], [null, "VEQLC", function () {
    return [vm.$("ZPTR"), vm.$("I"), null, vm.$("ARTN")];
  }, "Is it INTEGER?"], [null, "VEQLC", function () {
    return [vm.$("ZPTR"), vm.$("S"), null, vm.$("PLSV")];
  }, "Is it STRING?"], [null, "VEQLC", function () {
    return [vm.$("ZPTR"), vm.$("R"), vm.$("INTR1"), vm.$("ARTN")];
  }, "Is it REAL?"], ["PLSV", "LOCSP", function () {
    return [vm.$("XSP"), vm.$("ZPTR")];
  }, "Get specifier"], [null, "SPCINT", function () {
    return [vm.$("ZPTR"), vm.$("XSP"), null, vm.$("ARTN")];
  }, "Convert STRING to INTEGER"], [null, "SPREAL", function () {
    return [vm.$("ZPTR"), vm.$("XSP"), vm.$("INTR1"), vm.$("ARTN")];
  }, "Convert STRING to REAL"], [null, "TITLE", function () {
    return ["Pattern-valued Functions and Operations"];
  }, ""], ["ANY", "PROC", function () {
    return [null];
  }, "ANY(S)"], [null, "PUSH", function () {
    return [vm.$("ANYCCL")];
  }, "Save function descriptor"], [null, "BRANCH", function () {
    return [vm.$("CHARZ")];
  }, "Join common processing"], ["BREAK", "PROC", function () {
    return [vm.$("ANY")];
  }, "BREAK(S)"], [null, "PUSH", function () {
    return [vm.$("BRKCCL")];
  }, "Save function descriptor"], [null, "PUSH", function () {
    return [vm.$("ZEROCL")];
  }, "Save minimum length of zero"], [null, "BRANCH", function () {
    return [vm.$("ABNSND")];
  }, "Join common processing"], ["NOTANY", "PROC", function () {
    return [vm.$("ANY")];
  }, "NOTANY(S)"], [null, "PUSH", function () {
    return [vm.$("NNYCCL")];
  }, "Save function descriptor"], [null, "BRANCH", function () {
    return [vm.$("CHARZ")];
  }, ""], ["SPAN", "PROC", function () {
    return [vm.$("ANY")];
  }, "SPAN(S)"], [null, "PUSH", function () {
    return [vm.$("SPNCCL")];
  }, "Save function descriptor"], ["CHARZ", "PUSH", function () {
    return [vm.$("CHARCL")];
  }, "Save minimum length of one"], ["ABNSND", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("ARGVAL"), null, vm.$("FAIL")];
  }, "Evaluate argument"], [null, "POP", function () {
    return [[vm.$("ZCL"), vm.$("YCL")]];
  }, "Restore descriptor and length"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("S"), null, vm.$("PATNOD")];
  }, "STRING is acceptable argument"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("E"), null, vm.$("PATNOD")];
  }, "So is EXPRESSION"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("I"), vm.$("INTR1")];
  }, "INTEGER must be converted"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GNVARI"), vm.$("XPTR")];
  }, ""], ["PATNOD", "DEQL", function () {
    return [vm.$("XPTR"), vm.$("NULVCL"), null, vm.$("NONAME")];
  }, "E3.5.4"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("LNODSZ")];
  }, "E3.5.4"], [null, "MAKNOD", function () {
    return [vm.$("ZPTR"), vm.$("TPTR"), vm.$("ZCL"), vm.$("ZEROCL"), vm.$("YCL"), vm.$("XPTR")];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("RTZPTR")];
  }, ""], ["LEN", "PROC", function () {
    return [vm.$("ANY")];
  }, "LEN(N)"], [null, "PUSH", function () {
    return [vm.$("LNTHCL")];
  }, "Save function descriptor"], [null, "BRANCH", function () {
    return [vm.$("LPRTND")];
  }, ""], ["POS", "PROC", function () {
    return [vm.$("ANY")];
  }, "POS(N)"], [null, "PUSH", function () {
    return [vm.$("POSICL")];
  }, "Save function descriptor"], [null, "BRANCH", function () {
    return [vm.$("LPRTND")];
  }, ""], ["RPOS", "PROC", function () {
    return [vm.$("ANY")];
  }, "RPOS(N)"], [null, "PUSH", function () {
    return [vm.$("RPSICL")];
  }, "Save function descriptor"], [null, "BRANCH", function () {
    return [vm.$("LPRTND")];
  }, ""], ["RTAB", "PROC", function () {
    return [vm.$("ANY")];
  }, "RTAB(N)"], [null, "PUSH", function () {
    return [vm.$("RTBCL")];
  }, "Save function descriptor"], [null, "BRANCH", function () {
    return [vm.$("LPRTND")];
  }, ""], ["TAB", "PROC", function () {
    return [vm.$("ANY")];
  }, "TAB(N)"], [null, "PUSH", function () {
    return [vm.$("TBCL")];
  }, "Save function descriptor"], ["LPRTND", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("ARGVAL"), null, vm.$("FAIL")];
  }, "Evaluate argument"], [null, "POP", function () {
    return [vm.$("YCL")];
  }, "Restore function descriptor"], [null, "MOVD", function () {
    return [vm.$("ZCL"), vm.$("ZEROCL")];
  }, "Predict minimum length of zero"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("I"), null, vm.$("LPRTNI")];
  }, "If INTEGER check for LEN"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("E"), null, vm.$("PATNOD")];
  }, "EXPRESSION is acceptable"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("S"), vm.$("INTR1")];
  }, "STRING must be converted to INTEGER"], [null, "LOCSP", function () {
    return [vm.$("ZSP"), vm.$("XPTR")];
  }, "Get specifier"], [null, "SPCINT", function () {
    return [vm.$("XPTR"), vm.$("ZSP"), vm.$("INTR1")];
  }, "Convert to INTEGER"], ["LPRTNI", "ACOMPC", function () {
    return [vm.$("XPTR"), 0, null, null, vm.$("LENERR")];
  }, "E3.6.1"], [null, "DEQL", function () {
    return [vm.$("YCL"), vm.$("LNTHCL"), vm.$("PATNOD")];
  }, "E3.6.1"], [null, "MOVA", function () {
    return [vm.$("ZCL"), vm.$("XPTR")];
  }, "If so, use value of integer"], [null, "BRANCH", function () {
    return [vm.$("PATNOD")];
  }, "Go form pattern"], ["ARBNO", "PROC", function () {
    return [null];
  }, "ARBNO(P)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("PATVAL"), null, vm.$("FAIL")];
  }, "Evaluate argument as pattern"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("P"), null, vm.$("ARBP")];
  }, "PATTERN is desired form"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("S"), vm.$("INTR1")];
  }, "STRING must be made into PATTERN"], [null, "LOCSP", function () {
    return [vm.$("TSP"), vm.$("XPTR")];
  }, "Get specifier"], [null, "GETLG", function () {
    return [vm.$("TMVAL"), vm.$("TSP")];
  }, "Get length of string"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("LNODSZ")];
  }, "Allocate block for argument"], [null, "MAKNOD", function () {
    return [vm.$("XPTR"), vm.$("TPTR"), vm.$("TMVAL"), vm.$("ZEROCL"), vm.$("CHRCL"), vm.$("XPTR")];
  }, ""], ["ARBP", "GETSIZ", function () {
    return [vm.$("XSIZ"), vm.$("XPTR")];
  }, "Get size of pattern"], [null, "SUM", function () {
    return [vm.$("TSIZ"), vm.$("XSIZ"), vm.$("ARBSIZ")];
  }, "Add additional space for ARBNO node"], [null, "SETVC", function () {
    return [vm.$("TSIZ"), vm.$("P")];
  }, "Insert PATTERN data type"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("TSIZ")];
  }, "Allocate block for pattern"], [null, "MOVD", function () {
    return [vm.$("ZPTR"), vm.$("TPTR")];
  }, "Save pointer to return"], [null, "GETSIZ", function () {
    return [vm.$("TSIZ"), vm.$("ARHEAD")];
  }, "Set up copy for heading node"], [null, "CPYPAT", function () {
    return [vm.$("TPTR"), vm.$("ARHEAD"), vm.$("ZEROCL"), vm.$("ZEROCL"), vm.$("ZEROCL"), vm.$("TSIZ")];
  }, ""], [null, "SUM", function () {
    return [vm.$("ZSIZ"), vm.$("XSIZ"), vm.$("TSIZ")];
  }, ""], [null, "CPYPAT", function () {
    return [vm.$("TPTR"), vm.$("XPTR"), vm.$("ZEROCL"), vm.$("TSIZ"), vm.$("ZSIZ"), vm.$("XSIZ")];
  }, ""], [null, "SUM", function () {
    return [vm.$("TSIZ"), vm.$("NODSIZ"), vm.$("NODSIZ")];
  }, "Set up size for trailing node"], [null, "CPYPAT", function () {
    return [vm.$("TPTR"), vm.$("ARTAIL"), vm.$("ZEROCL"), vm.$("ZSIZ"), vm.$("ZEROCL"), vm.$("TSIZ")];
  }, ""], [null, "SUM", function () {
    return [vm.$("ZSIZ"), vm.$("TSIZ"), vm.$("ZSIZ")];
  }, "Set up size for backup node"], [null, "CPYPAT", function () {
    return [vm.$("TPTR"), vm.$("ARBACK"), vm.$("ZEROCL"), vm.$("ZSIZ"), vm.$("TSIZ"), vm.$("TSIZ")];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("RTZPTR")];
  }, ""], ["ATOP", "PROC", function () {
    return [null];
  }, "@X"], [null, "INCRA", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Increment interpreter offset"], [null, "GETD", function () {
    return [vm.$("YPTR"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get object code descriptor"], [null, "TESTF", function () {
    return [vm.$("YPTR"), vm.$("FNC"), vm.$("ATOP1")];
  }, "Test for function descriptor"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("INVOKE"), vm.$("YPTR")];
  }, "(FAIL,ATOP1,)"], [null, "VEQLC", function () {
    return [vm.$("YPTR"), vm.$("E"), vm.$("NEMO")];
  }, "Only EXPRESSION can be value"], ["ATOP1", "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("LNODSZ")];
  }, "Allocate pattern node"], [null, "MAKNOD", function () {
    return [vm.$("ZPTR"), vm.$("TPTR"), vm.$("ZEROCL"), vm.$("ZEROCL"), vm.$("ATOPCL"), vm.$("YPTR")];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("RTZPTR")];
  }, ""], ["NAM", "PROC", function () {
    return [null];
  }, "X . Y"], [null, "PUSH", function () {
    return [vm.$("ENMECL")];
  }, "Save function descriptor"], [null, "BRANCH", function () {
    return [vm.$("NAM5")];
  }, "Join processing"], ["DOL", "PROC", function () {
    return [vm.$("NAM")];
  }, "X $ Y"], [null, "PUSH", function () {
    return [vm.$("ENMICL")];
  }, "Save function descritpor"], ["NAM5", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("PATVAL"), null, vm.$("FAIL")];
  }, "Get pattern for first argument"], [null, "INCRA", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("YPTR"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get object code descriptor"], [null, "TESTF", function () {
    return [vm.$("YPTR"), vm.$("FNC"), null, vm.$("NAMC2")];
  }, "Check for function"], ["NAM3", "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("S"), null, vm.$("NAMV")];
  }, "Is first argument STRING?"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("P"), vm.$("INTR1"), vm.$("NAMP")];
  }, "Is it PATTERN?"], ["NAMC2", "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save first argument"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("INVOKE"), vm.$("YPTR")];
  }, "(FAIL,NAM4,)"], [null, "VEQLC", function () {
    return [vm.$("YPTR"), vm.$("E"), vm.$("NEMO")];
  }, "Verify EXPRESSION"], ["NAM4", "POP", function () {
    return [vm.$("XPTR")];
  }, "Restore first argument"], [null, "BRANCH", function () {
    return [vm.$("NAM3")];
  }, "Join processing"], ["NAMV", "LOCSP", function () {
    return [vm.$("TSP"), vm.$("XPTR")];
  }, "Get specifier"], [null, "GETLG", function () {
    return [vm.$("TMVAL"), vm.$("TSP")];
  }, "Get length"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("LNODSZ")];
  }, "Allocate block for pattern"], [null, "MAKNOD", function () {
    return [vm.$("XPTR"), vm.$("TPTR"), vm.$("TMVAL"), vm.$("ZEROCL"), vm.$("CHRCL"), vm.$("XPTR")];
  }, ""], ["NAMP", "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("SNODSZ")];
  }, "Allocate block for pattern"], [null, "MAKNOD", function () {
    return [vm.$("WPTR"), vm.$("TPTR"), vm.$("ZEROCL"), vm.$("ZEROCL"), vm.$("NMECL")];
  }, ""], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("LNODSZ")];
  }, "Allocate block for  pattern"], [null, "POP", function () {
    return [vm.$("TVAL")];
  }, "Restore function descriptor"], [null, "MAKNOD", function () {
    return [vm.$("YPTR"), vm.$("TPTR"), vm.$("ZEROCL"), vm.$("ZEROCL"), vm.$("TVAL"), vm.$("YPTR")];
  }, ""], [null, "GETSIZ", function () {
    return [vm.$("XSIZ"), vm.$("XPTR")];
  }, "Get size of first pattern"], [null, "SUM", function () {
    return [vm.$("YSIZ"), vm.$("XSIZ"), vm.$("NODSIZ")];
  }, "Compute total size"], [null, "GETSIZ", function () {
    return [vm.$("TSIZ"), vm.$("YPTR")];
  }, "Get size of naming node"], [null, "SUM", function () {
    return [vm.$("ZSIZ"), vm.$("YSIZ"), vm.$("TSIZ")];
  }, "Compute total"], [null, "SETVC", function () {
    return [vm.$("ZSIZ"), vm.$("P")];
  }, "Insert PATTERN data type"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("ZSIZ")];
  }, "Allocate block for total pattern"], [null, "MOVD", function () {
    return [vm.$("ZPTR"), vm.$("TPTR")];
  }, "Save copy"], [null, "LVALUE", function () {
    return [vm.$("TVAL"), vm.$("XPTR")];
  }, "Get least value"], [null, "CPYPAT", function () {
    return [vm.$("TPTR"), vm.$("WPTR"), vm.$("TVAL"), vm.$("ZEROCL"), vm.$("NODSIZ"), vm.$("NODSIZ")];
  }, ""], [null, "CPYPAT", function () {
    return [vm.$("TPTR"), vm.$("XPTR"), vm.$("ZEROCL"), vm.$("NODSIZ"), vm.$("YSIZ"), vm.$("XSIZ")];
  }, ""], [null, "CPYPAT", function () {
    return [vm.$("TPTR"), vm.$("YPTR"), vm.$("ZEROCL"), vm.$("YSIZ"), vm.$("ZEROCL"), vm.$("TSIZ")];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("RTZPTR")];
  }, "Return pattern as value"], ["OR", "PROC", function () {
    return [null];
  }, "X | Y"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("PATVAL"), null, vm.$("FAIL")];
  }, "Get first argument"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save first argument"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("PATVAL"), null, vm.$("FAIL")];
  }, "Get second argument"], [null, "POP", function () {
    return [vm.$("XPTR")];
  }, "Restore first argument"], [null, "SETAV", function () {
    return [vm.$("DTCL"), vm.$("XPTR")];
  }, "Get first data type"], [null, "MOVV", function () {
    return [vm.$("DTCL"), vm.$("YPTR")];
  }, "Insert second data type"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("VVDTP"), null, vm.$("ORVV")];
  }, "Is it STRING-STRING?"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("VPDTP"), null, vm.$("ORVP")];
  }, "Is it STRING-PATTERN?"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("PVDTP"), null, vm.$("ORPV")];
  }, "Is it PATTERN-STRING?"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("PPDTP"), vm.$("INTR1"), vm.$("ORPP")];
  }, ""], ["ORVV", "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier"], [null, "GETLG", function () {
    return [vm.$("TMVAL"), vm.$("XSP")];
  }, "Get length"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("LNODSZ")];
  }, "Get block for pattern"], [null, "MAKNOD", function () {
    return [vm.$("XPTR"), vm.$("TPTR"), vm.$("TMVAL"), vm.$("ZEROCL"), vm.$("CHRCL"), vm.$("XPTR")];
  }, ""], ["ORPV", "LOCSP", function () {
    return [vm.$("YSP"), vm.$("YPTR")];
  }, "Get specifier"], [null, "GETLG", function () {
    return [vm.$("TMVAL"), vm.$("YSP")];
  }, "Get length"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("LNODSZ")];
  }, "Get block for pattern"], [null, "MAKNOD", function () {
    return [vm.$("YPTR"), vm.$("TPTR"), vm.$("TMVAL"), vm.$("ZEROCL"), vm.$("CHRCL"), vm.$("YPTR")];
  }, ""], ["ORPP", "GETSIZ", function () {
    return [vm.$("XSIZ"), vm.$("XPTR")];
  }, "Get size of first pattern"], [null, "GETSIZ", function () {
    return [vm.$("YSIZ"), vm.$("YPTR")];
  }, "Get size of second pattern"], [null, "SUM", function () {
    return [vm.$("TSIZ"), vm.$("XSIZ"), vm.$("YSIZ")];
  }, "Compute total size"], [null, "SETVC", function () {
    return [vm.$("TSIZ"), vm.$("P")];
  }, "Insert PATTERN data type"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("TSIZ")];
  }, "Allocate block for pattern"], [null, "MOVD", function () {
    return [vm.$("ZPTR"), vm.$("TPTR")];
  }, "Save copy"], [null, "CPYPAT", function () {
    return [vm.$("TPTR"), vm.$("XPTR"), vm.$("ZEROCL"), vm.$("ZEROCL"), vm.$("ZEROCL"), vm.$("XSIZ")];
  }, ""], [null, "CPYPAT", function () {
    return [vm.$("TPTR"), vm.$("YPTR"), vm.$("ZEROCL"), vm.$("XSIZ"), vm.$("ZEROCL"), vm.$("YSIZ")];
  }, ""], [null, "LINKOR", function () {
    return [vm.$("ZPTR"), vm.$("XSIZ")];
  }, "Link alternatives"], [null, "BRANCH", function () {
    return [vm.$("RTZPTR")];
  }, "Return pattern as value"], ["ORVP", "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier"], [null, "GETLG", function () {
    return [vm.$("TMVAL"), vm.$("XSP")];
  }, "Get length"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("LNODSZ")];
  }, "Get block for pattern"], [null, "MAKNOD", function () {
    return [vm.$("XPTR"), vm.$("TPTR"), vm.$("TMVAL"), vm.$("ZEROCL"), vm.$("CHRCL"), vm.$("XPTR")];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("ORPP")];
  }, "Join processing"], [null, "TITLE", function () {
    return ["Pattern Matching Procedures"];
  }, ""], ["SCAN", "PROC", function () {
    return [null];
  }, "Pattern Matching"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("ARGVAL"), null, vm.$("FAIL")];
  }, "Get subject"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save subject"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("PATVAL"), null, vm.$("FAIL")];
  }, "Get pattern"], [null, "POP", function () {
    return [vm.$("XPTR")];
  }, "Restore subject"], [null, "SETAV", function () {
    return [vm.$("DTCL"), vm.$("XPTR")];
  }, "Set up data type pair"], [null, "MOVV", function () {
    return [vm.$("DTCL"), vm.$("YPTR")];
  }, ""], [null, "INCRA", function () {
    return [vm.$("SCNCL"), 1];
  }, "Increment count of scanner entries"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("VVDTP"), null, vm.$("SCANVV")];
  }, "Is it STRING-STRING?"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("VPDTP"), null, vm.$("SCANVP")];
  }, "Is it STRING-PATTERN?"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("IVDTP"), null, vm.$("SCANIV")];
  }, "Is it INTEGER-STRING?"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("RVDTP"), null, vm.$("SCANRV")];
  }, "Is it REAL-STRING?"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("RPDTP"), null, vm.$("SCANRP")];
  }, "Is it REAL-PATTERN?"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("IPDTP"), vm.$("INTR1"), vm.$("SCANIP")];
  }, ""], ["SCANVV", "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier for subject"], [null, "LOCSP", function () {
    return [vm.$("YSP"), vm.$("YPTR")];
  }, "Get specifier for pattern"], ["SCANVB", "SUBSP", function () {
    return [vm.$("TSP"), vm.$("YSP"), vm.$("XSP"), vm.$("FAIL")];
  }, "Get part to compare"], [null, "LEXCMP", function () {
    return [vm.$("TSP"), vm.$("YSP"), null, vm.$("RETNUL")];
  }, "Compare strings"], [null, "AEQLC", function () {
    return [vm.$("ANCCL"), 0, vm.$("FAIL")];
  }, "Check &ANCHOR"], [null, "FSHRTN", function () {
    return [vm.$("XSP"), 1];
  }, "Delete lead character"], [null, "BRANCH", function () {
    return [vm.$("SCANVB")];
  }, "Try again"], ["SCANIV", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GNVARI"), vm.$("XPTR")];
  }, "Generate variable for integer"], [null, "BRANCH", function () {
    return [vm.$("SCANVV")];
  }, "Join processing"], ["SCANVP", "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier for subject"], [null, "RCALL", function () {
    return [null, vm.$("SCNR"), null, [vm.$("FAIL"), null, vm.$("FAIL")]];
  }, "Call scanner"], [null, "RCALL", function () {
    return [null, vm.$("NMD"), null, [vm.$("FAIL"), vm.$("RTN2")]];
  }, "Perform naming"], ["SCANIP", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GNVARI"), vm.$("XPTR")];
  }, "Generate variable for integer"], [null, "BRANCH", function () {
    return [vm.$("SCANVP")];
  }, "Join processing"], ["SCANRV", "REALST", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Convert REAL to STRING"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), vm.$("XSPPTR"), vm.$("SCANVV")];
  }, ""], ["SCANRP", "REALST", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Convert REAL to STRING"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), vm.$("XSPPTR"), vm.$("SCANVP")];
  }, ""], ["SJSR", "PROC", function () {
    return [null];
  }, "Pattern matching with replacement"], [null, "INCRA", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("WPTR"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get object code descriptor"], [null, "TESTF", function () {
    return [vm.$("WPTR"), vm.$("FNC"), null, vm.$("SJSRC1")];
  }, "Check for function"], ["SJSR1", "AEQLC", function () {
    return [vm.$("INSW"), 0, null, vm.$("SJSR1A")];
  }, "Check &INPUT"], [null, "LOCAPV", function () {
    return [vm.$("ZPTR"), vm.$("INATL"), vm.$("WPTR"), vm.$("SJSR1A")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("ZPTR"), vm.$("DESCR")];
  }, "Get association"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("PUTIN"), [vm.$("ZPTR"), vm.$("WPTR")], [vm.$("FAIL"), vm.$("SJSR1B")]];
  }, ""], ["SJSR1A", "GETDC", function () {
    return [vm.$("XPTR"), vm.$("WPTR"), vm.$("DESCR")];
  }, "Get value"], ["SJSR1B", "PUSH", function () {
    return [[vm.$("WPTR"), vm.$("XPTR")]];
  }, "Save name and value"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("PATVAL"), null, vm.$("FAIL")];
  }, "Get pattern"], [null, "POP", function () {
    return [vm.$("XPTR")];
  }, "Restore value"], [null, "SETAV", function () {
    return [vm.$("DTCL"), vm.$("XPTR")];
  }, "Set up data type pair"], [null, "MOVV", function () {
    return [vm.$("DTCL"), vm.$("YPTR")];
  }, ""], [null, "INCRA", function () {
    return [vm.$("SCNCL"), 1];
  }, "Increment count of scanner calls"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("VVDTP"), null, vm.$("SJSSVV")];
  }, "Is it STRING-PATTERN?"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("VPDTP"), null, vm.$("SJSSVP")];
  }, "Is it INTEGER-STRING?"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("IVDTP"), null, vm.$("SJSSIV")];
  }, "Is it INTEGER-PATTERN?"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("RVDTP"), null, vm.$("SJSSRV")];
  }, "Is it REAL-STRING?"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("RPDTP"), null, vm.$("SJSSRP")];
  }, "Is it REAL-PATTERN?"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("IPDTP"), vm.$("INTR1"), vm.$("SJSSIP")];
  }, ""], ["SJSRC1", "RCALL", function () {
    return [vm.$("WPTR"), vm.$("INVOKE"), [vm.$("WPTR")], [vm.$("FAIL"), vm.$("SJSR1"), vm.$("NEMO")]];
  }, ""], ["SJSSVP", "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier"], [null, "RCALL", function () {
    return [null, vm.$("SCNR"), null, [vm.$("FAIL"), null, vm.$("FAIL")]];
  }, "Call scanner"], [null, "SETAC", function () {
    return [vm.$("NAMGCL"), 1];
  }, "Set naming switch"], [null, "REMSP", function () {
    return [vm.$("TAILSP"), vm.$("XSP"), vm.$("TXSP")];
  }, "Get tail of subject"], [null, "BRANCH", function () {
    return [vm.$("SJSS1")];
  }, "Join common processing"], ["SJSSIP", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GNVARI"), vm.$("XPTR")];
  }, "Generate STRING from INTEGER"], [null, "BRANCH", function () {
    return [vm.$("SJSSVP")];
  }, "Join common processing"], ["SJSSIV", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GNVARI"), vm.$("XPTR")];
  }, "Generate STRING from INTEGER"], [null, "BRANCH", function () {
    return [vm.$("SJSSVV")];
  }, "Join common processing"], ["SJSSRV", "REALST", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Convert REAL to STRING"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), vm.$("XSPPTR"), vm.$("SJSSVV")];
  }, ""], ["SJSSRP", "REALST", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Convert REAL to STRING"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), vm.$("XSPPTR"), vm.$("SJSSVP")];
  }, ""], ["SJVVON", "AEQLC", function () {
    return [vm.$("ANCCL"), 0, vm.$("FAIL")];
  }, "Check &ANCHOR"], [null, "ADDLG", function () {
    return [vm.$("HEADSP"), vm.$("ONECL")];
  }, "Increment length of head"], [null, "FSHRTN", function () {
    return [vm.$("XSP"), 1];
  }, "Delete head character"], [null, "BRANCH", function () {
    return [vm.$("SJSSV2")];
  }, "Join common processing"], ["SJSSVV", "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier for subject"], [null, "LOCSP", function () {
    return [vm.$("YSP"), vm.$("YPTR")];
  }, "Get specifier for pattern"], [null, "SETSP", function () {
    return [vm.$("HEADSP"), vm.$("XSP")];
  }, "Set up head specifier"], [null, "SETLC", function () {
    return [vm.$("HEADSP"), 0];
  }, "Initialize zero length"], ["SJSSV2", "SUBSP", function () {
    return [vm.$("TSP"), vm.$("YSP"), vm.$("XSP"), vm.$("FAIL")];
  }, "Get common length"], [null, "LEXCMP", function () {
    return [vm.$("TSP"), vm.$("YSP"), vm.$("SJVVON"), null, vm.$("SJVVON")];
  }, ""], [null, "SETAC", function () {
    return [vm.$("NAMGCL"), 0];
  }, "Clear naming switch"], [null, "REMSP", function () {
    return [vm.$("TAILSP"), vm.$("XSP"), vm.$("TSP")];
  }, "Get tail of subject"], ["SJSS1", "SPUSH", function () {
    return [[vm.$("TAILSP"), vm.$("HEADSP")]];
  }, "Save head and tail"], [null, "AEQLC", function () {
    return [vm.$("NAMGCL"), 0, null, vm.$("SJSS1A")];
  }, "Check naming switch"], [null, "RCALL", function () {
    return [null, vm.$("NMD"), null, vm.$("FAIL")];
  }, "Perform naming"], ["SJSS1A", "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("ARGVAL"), null, vm.$("FAIL")];
  }, "Get object"], [null, "SPOP", function () {
    return [[vm.$("HEADSP"), vm.$("TAILSP")]];
  }, "Restore head and tail"], [null, "POP", function () {
    return [vm.$("WPTR")];
  }, "Restore name of subject"], [null, "LEQLC", function () {
    return [vm.$("HEADSP"), 0, vm.$("SJSSDT")];
  }, "Check for null head"], [null, "LEQLC", function () {
    return [vm.$("TAILSP"), 0, null, vm.$("SJSRV1")];
  }, "Check for null tail"], ["SJSSDT", "VEQLC", function () {
    return [vm.$("ZPTR"), vm.$("S"), null, vm.$("SJSRV")];
  }, "Is object STRING?"], [null, "VEQLC", function () {
    return [vm.$("ZPTR"), vm.$("P"), null, vm.$("SJSRP")];
  }, "Is object PATTERN?"], [null, "VEQLC", function () {
    return [vm.$("ZPTR"), vm.$("I"), null, vm.$("SJSRI")];
  }, "Is object INTEGER?"], [null, "VEQLC", function () {
    return [vm.$("ZPTR"), vm.$("R"), null, vm.$("SJSRR")];
  }, "Is object REAL?"], [null, "VEQLC", function () {
    return [vm.$("ZPTR"), vm.$("E"), vm.$("INTR1")];
  }, "Is object EXPRESSION?"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("STARSZ")];
  }, "Allocate block for pattern"], [null, "MOVBLK", function () {
    return [vm.$("TPTR"), vm.$("STRPAT"), vm.$("STARSZ")];
  }, "Set up pattern for expression"], [null, "PUTDC", function () {
    return [vm.$("TPTR"), 4 * vm.$("DESCR"), vm.$("ZPTR")];
  }, "Insert object"], [null, "MOVD", function () {
    return [vm.$("ZPTR"), vm.$("TPTR")];
  }, "Set up converted value"], ["SJSRP", "SETSP", function () {
    return [vm.$("XSP"), vm.$("HEADSP")];
  }, "Copy specifier"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), [vm.$("XSPPTR")]];
  }, ""], [null, "GETLG", function () {
    return [vm.$("TMVAL"), vm.$("HEADSP")];
  }, "Get length of head"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("LNODSZ")];
  }, "Allocate block for pattern"], [null, "MAKNOD", function () {
    return [vm.$("XPTR"), vm.$("TPTR"), vm.$("TMVAL"), vm.$("ZEROCL"), vm.$("CHRCL"), vm.$("XPTR")];
  }, ""], [null, "SETSP", function () {
    return [vm.$("YSP"), vm.$("TAILSP")];
  }, "Set up tail specifier"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("GENVAR"), [vm.$("YSPPTR")]];
  }, ""], [null, "GETLG", function () {
    return [vm.$("TMVAL"), vm.$("TAILSP")];
  }, "Get length of tail"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("LNODSZ")];
  }, "Allocate block for pattern"], [null, "MAKNOD", function () {
    return [vm.$("YPTR"), vm.$("TPTR"), vm.$("TMVAL"), vm.$("ZEROCL"), vm.$("CHRCL"), vm.$("YPTR")];
  }, ""], [null, "GETSIZ", function () {
    return [vm.$("XSIZ"), vm.$("XPTR")];
  }, "Get size of head node"], [null, "GETSIZ", function () {
    return [vm.$("YSIZ"), vm.$("YPTR")];
  }, "Get size of tail node"], [null, "GETSIZ", function () {
    return [vm.$("ZSIZ"), vm.$("ZPTR")];
  }, "Get size of object"], [null, "SUM", function () {
    return [vm.$("TSIZ"), vm.$("XSIZ"), vm.$("ZSIZ")];
  }, "Compute total size"], [null, "SUM", function () {
    return [vm.$("TSIZ"), vm.$("TSIZ"), vm.$("YSIZ")];
  }, "Get size of new pattern"], [null, "SETVC", function () {
    return [vm.$("TSIZ"), vm.$("P")];
  }, "Insert PATTERN data type"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("TSIZ")];
  }, "Allocate block for total pattern"], [null, "MOVD", function () {
    return [vm.$("VVAL"), vm.$("TPTR")];
  }, "Get working copy"], [null, "LVALUE", function () {
    return [vm.$("TVAL"), vm.$("ZPTR")];
  }, "Get least value of replacement"], [null, "CPYPAT", function () {
    return [vm.$("TPTR"), vm.$("XPTR"), vm.$("TVAL"), vm.$("ZEROCL"), vm.$("XSIZ"), vm.$("XSIZ")];
  }, ""], [null, "LVALUE", function () {
    return [vm.$("TVAL"), vm.$("YPTR")];
  }, "Get least value of tail"], [null, "SUM", function () {
    return [vm.$("TSIZ"), vm.$("XSIZ"), vm.$("ZSIZ")];
  }, "Get size of first two"], [null, "CPYPAT", function () {
    return [vm.$("TPTR"), vm.$("ZPTR"), vm.$("TVAL"), vm.$("XSIZ"), vm.$("TSIZ"), vm.$("ZSIZ")];
  }, ""], [null, "CPYPAT", function () {
    return [vm.$("TPTR"), vm.$("YPTR"), vm.$("ZEROCL"), vm.$("TSIZ"), vm.$("ZEROCL"), vm.$("YSIZ")];
  }, ""], [null, "MOVD", function () {
    return [vm.$("ZPTR"), vm.$("VVAL")];
  }, "Set up return value"], [null, "BRANCH", function () {
    return [vm.$("SJSRV1")];
  }, "Join common processing"], ["SJSRV", "LOCSP", function () {
    return [vm.$("ZSP"), vm.$("ZPTR")];
  }, ""], ["SJSRS", "GETLG", function () {
    return [vm.$("XPTR"), vm.$("TAILSP")];
  }, "Get length of tail"], [null, "GETLG", function () {
    return [vm.$("YPTR"), vm.$("HEADSP")];
  }, "Get length of tail"], [null, "GETLG", function () {
    return [vm.$("ZPTR"), vm.$("ZSP")];
  }, "Get length of object"], [null, "SUM", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), vm.$("YPTR")];
  }, "Compute total length"], [null, "SUM", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), vm.$("ZPTR")];
  }, ""], [null, "ACOMP", function () {
    return [vm.$("XPTR"), vm.$("MLENCL"), vm.$("INTR8")];
  }, "Check &MAXLNGTH"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("CONVAR"), [vm.$("XPTR")]];
  }, "Allocate storage for string"], [null, "LOCSP", function () {
    return [vm.$("TSP"), vm.$("ZPTR")];
  }, "Get specifier"], [null, "SETLC", function () {
    return [vm.$("TSP"), 0];
  }, "Clear length"], [null, "APDSP", function () {
    return [vm.$("TSP"), vm.$("HEADSP")];
  }, "Append head"], [null, "APDSP", function () {
    return [vm.$("TSP"), vm.$("ZSP")];
  }, "Append object"], [null, "APDSP", function () {
    return [vm.$("TSP"), vm.$("TAILSP")];
  }, "Append tail"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("GNVARS"), vm.$("XPTR")];
  }, "Enter string into storage"], ["SJSRV1", "PUTDC", function () {
    return [vm.$("WPTR"), vm.$("DESCR"), vm.$("ZPTR")];
  }, "Assign value to subject name"], [null, "AEQLC", function () {
    return [vm.$("OUTSW"), 0, null, vm.$("SJSRV2")];
  }, "Check &OUTPUT"], [null, "LOCAPV", function () {
    return [vm.$("YPTR"), vm.$("OUTATL"), vm.$("WPTR"), vm.$("SJSRV2")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("YPTR"), vm.$("YPTR"), vm.$("DESCR")];
  }, "Get output association"], [null, "RCALL", function () {
    return [null, vm.$("PUTOUT"), [vm.$("YPTR"), vm.$("ZPTR")]];
  }, "Perform output"], ["SJSRV2", "ACOMPC", function () {
    return [vm.$("TRAPCL"), 0, null, vm.$("RTN3"), vm.$("RTN3")];
  }, "Check &TRACE"], [null, "LOCAPT", function () {
    return [vm.$("ATPTR"), vm.$("TVALL"), vm.$("WPTR"), vm.$("RTN3")];
  }, ""], [null, "RCALL", function () {
    return [null, vm.$("TRPHND"), vm.$("ATPTR"), vm.$("RTN3")];
  }, "E3.3.1"], ["SJSRI", "INTSPC", function () {
    return [vm.$("ZSP"), vm.$("ZPTR")];
  }, "Convert INTEGER"], [null, "BRANCH", function () {
    return [vm.$("SJSRS")];
  }, ""], ["SJSRR", "REALST", function () {
    return [vm.$("ZSP"), vm.$("ZPTR")];
  }, "Convert REAL"], [null, "BRANCH", function () {
    return [vm.$("SJSRS")];
  }, ""], ["SCNR", "PROC", function () {
    return [null];
  }, "Scanning procedure"], [null, "GETLG", function () {
    return [vm.$("MAXLEN"), vm.$("XSP")];
  }, "Get maximum length"], [null, "LVALUE", function () {
    return [vm.$("YSIZ"), vm.$("YPTR")];
  }, "Get least value"], [null, "AEQLC", function () {
    return [vm.$("FULLCL"), 0, vm.$("SCNR1")];
  }, "Check &FULLSCAN"], [null, "ACOMP", function () {
    return [vm.$("YSIZ"), vm.$("MAXLEN"), vm.$("FAIL")];
  }, "CHeck maximum against minimum"], ["SCNR1", "SETSP", function () {
    return [vm.$("TXSP"), vm.$("XSP")];
  }, "Set up working specifier for head"], [null, "SETLC", function () {
    return [vm.$("TXSP"), 0];
  }, "Zero length"], [null, "MOVD", function () {
    return [vm.$("PDLPTR"), vm.$("PDLHED")];
  }, "Initialize history list"], [null, "MOVD", function () {
    return [vm.$("NAMICL"), vm.$("NHEDCL")];
  }, "Initialize name list"], [null, "AEQLC", function () {
    return [vm.$("ANCCL"), 0, vm.$("SCNR3")];
  }, "Check &ANCHOR"], [null, "AEQLC", function () {
    return [vm.$("FULLCL"), 0, null, vm.$("SCNR4")];
  }, "Check &FULLSCAN"], [null, "MOVD", function () {
    return [vm.$("YSIZ"), vm.$("MAXLEN")];
  }, "Set up length"], [null, "BRANCH", function () {
    return [vm.$("SCNR5")];
  }, "Join processing"], ["SCNR4", "SUBTRT", function () {
    return [vm.$("YSIZ"), vm.$("MAXLEN"), vm.$("YSIZ")];
  }, "Get difference of lengths"], ["SCNR5", "SUM", function () {
    return [vm.$("YSIZ"), vm.$("YSIZ"), vm.$("CHARCL")];
  }, "Add one"], ["SCNR2", "PUSH", function () {
    return [[vm.$("YPTR"), vm.$("YSIZ")]];
  }, "Save pattern and length"], [null, "SETSP", function () {
    return [vm.$("HEADSP"), vm.$("TXSP")];
  }, "Set up head specifier"], [null, "INCRA", function () {
    return [vm.$("PDLPTR"), 3 * vm.$("DESCR")];
  }, "Make room for history entry"], [null, "ACOMP", function () {
    return [vm.$("PDLPTR"), vm.$("PDLEND"), vm.$("INTR31")];
  }, ""], [null, "SETAC", function () {
    return [vm.$("LENFCL"), 1];
  }, "Set length failure"], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), vm.$("DESCR"), vm.$("SCONCL")];
  }, "Insert scan function"], [null, "GETLG", function () {
    return [vm.$("TMVAL"), vm.$("TXSP")];
  }, "Get cursor position"], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), 2 * vm.$("DESCR"), vm.$("TMVAL")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), 3 * vm.$("DESCR"), vm.$("LENFCL")];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("SCIN1")];
  }, "Join common scanning"], ["SCNR3", "INCRA", function () {
    return [vm.$("PDLPTR"), 3 * vm.$("DESCR")];
  }, "Make room for history entry"], [null, "ACOMP", function () {
    return [vm.$("PDLPTR"), vm.$("PDLEND"), vm.$("INTR31")];
  }, ""], [null, "SETLC", function () {
    return [vm.$("HEADSP"), 0];
  }, "Zero length of head"], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), vm.$("DESCR"), vm.$("SCFLCL")];
  }, "Insert scan failure function"], [null, "GETLG", function () {
    return [vm.$("TMVAL"), vm.$("TXSP")];
  }, "Get cursor position"], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), 2 * vm.$("DESCR"), vm.$("TMVAL")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), 3 * vm.$("DESCR"), vm.$("LENFCL")];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("SCIN1")];
  }, "Join common scanning"], ["SCIN", "PROC", function () {
    return [vm.$("SCNR")];
  }, ""], ["SCIN1", "MOVD", function () {
    return [vm.$("PATBCL"), vm.$("YPTR")];
  }, "Set up pattern base pointer"], [null, "SETAC", function () {
    return [vm.$("PATICL"), 0];
  }, "Zero offset"], ["SCIN2", "SETAC", function () {
    return [vm.$("LENFCL"), 1];
  }, "Set length failure"], ["SCIN3", "INCRA", function () {
    return [vm.$("PATICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("ZCL"), vm.$("PATBCL"), vm.$("PATICL")];
  }, "Get function descriptor"], [null, "INCRA", function () {
    return [vm.$("PATICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("XCL"), vm.$("PATBCL"), vm.$("PATICL")];
  }, "Get then-or descriptor"], [null, "INCRA", function () {
    return [vm.$("PATICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("YCL"), vm.$("PATBCL"), vm.$("PATICL")];
  }, "Get value-residual descriptor"], [null, "INCRA", function () {
    return [vm.$("PDLPTR"), 3 * vm.$("DESCR")];
  }, "Make room for history entry"], [null, "ACOMP", function () {
    return [vm.$("PDLPTR"), vm.$("PDLEND"), vm.$("INTR31")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), vm.$("DESCR"), vm.$("XCL")];
  }, "Insert then-or descriptor"], [null, "GETLG", function () {
    return [vm.$("TMVAL"), vm.$("TXSP")];
  }, "Get cursor position"], [null, "MOVV", function () {
    return [vm.$("TMVAL"), vm.$("YCL")];
  }, "Insert residual"], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), 2 * vm.$("DESCR"), vm.$("TMVAL")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), 3 * vm.$("DESCR"), vm.$("LENFCL")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("FULLCL"), 0, vm.$("SCIN4")];
  }, "Check &FULLSCAN"], [null, "CHKVAL", function () {
    return [vm.$("MAXLEN"), vm.$("YCL"), vm.$("TXSP"), vm.$("SALT1")];
  }, ""], ["SCIN4", "BRANIC", function () {
    return [vm.$("ZCL"), 0];
  }, "Branch to procedure"], ["SALF", "PROC", function () {
    return [vm.$("SCNR")];
  }, "Nonlength failure procedure"], ["SALF1", "SETAC", function () {
    return [vm.$("LENFCL"), 0];
  }, "Clear length failure"], [null, "BRANCH", function () {
    return [vm.$("SALT2")];
  }, "Join common processing"], ["SALT", "PROC", function () {
    return [vm.$("SCNR")];
  }, "Length failure procedure"], ["SALT1", "GETDC", function () {
    return [vm.$("LENFCL"), vm.$("PDLPTR"), 3 * vm.$("DESCR")];
  }, ""], ["SALT2", "GETDC", function () {
    return [vm.$("XCL"), vm.$("PDLPTR"), vm.$("DESCR")];
  }, "Get then-or descriptor"], [null, "GETDC", function () {
    return [vm.$("YCL"), vm.$("PDLPTR"), 2 * vm.$("DESCR")];
  }, "Get value-residual"], [null, "DECRA", function () {
    return [vm.$("PDLPTR"), 3 * vm.$("DESCR")];
  }, "Back over history entry"], [null, "MOVD", function () {
    return [vm.$("PATICL"), vm.$("XCL")];
  }, "Set offset to OR link"], [null, "AEQLC", function () {
    return [vm.$("PATICL"), 0, null, vm.$("SALT3")];
  }, "Check for none"], [null, "PUTLG", function () {
    return [vm.$("TXSP"), vm.$("YCL")];
  }, "Insert old length of head"], [null, "TESTF", function () {
    return [vm.$("PATICL"), vm.$("FNC"), vm.$("SCIN3")];
  }, "Check for function"], [null, "BRANIC", function () {
    return [vm.$("PATICL"), 0];
  }, "Branch to procedure"], ["SALT3", "AEQLC", function () {
    return [vm.$("LENFCL"), 0, vm.$("SALT1")];
  }, "Check length failure"], [null, "BRANCH", function () {
    return [vm.$("SALF1")];
  }, "Go to nonlength failure"], ["SCOK", "PROC", function () {
    return [vm.$("SCNR")];
  }, "Successful scanning procedure"], [null, "SETAV", function () {
    return [vm.$("PATICL"), vm.$("XCL")];
  }, "Set offset from THEN link"], [null, "AEQLC", function () {
    return [vm.$("PATICL"), 0, vm.$("SCIN2"), vm.$("RTN2")];
  }, "Check for none"], ["SCON", "PROC", function () {
    return [vm.$("SCNR")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("FULLCL"), 0, vm.$("SCON1")];
  }, "Check &FULLSCAN"], [null, "AEQLC", function () {
    return [vm.$("LENFCL"), 0, vm.$("FAIL")];
  }, "Check length failure"], ["SCON1", "POP", function () {
    return [[vm.$("YSIZ"), vm.$("YPTR")]];
  }, "Restore save descriptors"], [null, "DECRA", function () {
    return [vm.$("YSIZ"), 1];
  }, "Decrement possible count"], [null, "ACOMPC", function () {
    return [vm.$("YSIZ"), 0, null, vm.$("FAIL"), vm.$("INTR13")];
  }, "CHeck for end"], [null, "ADDLG", function () {
    return [vm.$("TXSP"), vm.$("ONECL")];
  }, "Increment length of head"], [null, "BRANCH", function () {
    return [vm.$("SCNR2")];
  }, "Continue"], ["UNSC", "PROC", function () {
    return [vm.$("SCNR")];
  }, "Backout procedure"], [null, "MOVD", function () {
    return [vm.$("PATBCL"), vm.$("YPTR")];
  }, "Reset pattern base"], [null, "BRANCH", function () {
    return [vm.$("SALT3")];
  }, "Join processing"], ["ANYC", "PROC", function () {
    return [null];
  }, "Matching procedure for ANY(S)"], [null, "SETAC", function () {
    return [vm.$("SCL"), 1];
  }, "Post entry"], ["ABNS", "INCRA", function () {
    return [vm.$("PATICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("XPTR"), vm.$("PATBCL"), vm.$("PATICL")];
  }, "Get argument"], [null, "PUSH", function () {
    return [vm.$("SCL")];
  }, "Save processor switch"], ["ABNS1", "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("S"), null, vm.$("ABNSV")];
  }, "E3.5.5"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("E"), null, vm.$("ABNSE")];
  }, "EXPRESSION must be evaluated"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("I"), null, vm.$("ABNSI")];
  }, "E3.5.6"], [null, "POP", function () {
    return [vm.$("SCL")];
  }, "E3.5.6"], [null, "BRANCH", function () {
    return [vm.$("SCDTER")];
  }, "E3.5.6"], ["ABNSE", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("EXPVAL"), vm.$("XPTR"), [vm.$("ABNSF"), vm.$("ABNS1")]];
  }, "E3.5.5"], ["ABNSF", "POP", function () {
    return [vm.$("SCL")];
  }, "E3.5.5"], [null, "BRANCH", function () {
    return [vm.$("TSALF")];
  }, "E3.5.5"], ["ABNSI", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GNVARI"), vm.$("XPTR")];
  }, ""], ["ABNSV", "POP", function () {
    return [vm.$("SCL")];
  }, "Restore procedure switch"], [null, "AEQLC", function () {
    return [vm.$("XPTR"), 0, null, vm.$("SCNAME")];
  }, "E3.5.5"], [null, "SELBRA", function () {
    return [vm.$("SCL"), [null, vm.$("BRKV"), vm.$("NNYV"), vm.$("SPNV")]];
  }, ""], ["ANYV", "DEQL", function () {
    return [vm.$("XPTR"), vm.$("TBLCS"), vm.$("ANYC2")];
  }, "Was last argument the same?"], [null, "AEQL", function () {
    return [vm.$("TBLFNC"), vm.$("ANYCCL"), null, vm.$("ANYC3")];
  }, ""], ["ANYC2", "CLERTB", function () {
    return [vm.$("SNABTB"), vm.$("ERROR")];
  }, "If not, clear stream table"], [null, "LOCSP", function () {
    return [vm.$("YSP"), vm.$("XPTR")];
  }, ""], [null, "PLUGTB", function () {
    return [vm.$("SNABTB"), vm.$("STOP"), vm.$("YSP")];
  }, "Plug entries for characters"], [null, "MOVD", function () {
    return [vm.$("TBLCS"), vm.$("XPTR")];
  }, "Save argument to check next time"], [null, "MOVD", function () {
    return [vm.$("TBLFNC"), vm.$("ANYCCL")];
  }, "Save procedure to check next time"], ["ANYC3", "SETSP", function () {
    return [vm.$("VSP"), vm.$("XSP")];
  }, "Set up working specifier"], [null, "AEQLC", function () {
    return [vm.$("FULLCL"), 0, vm.$("ANYC4")];
  }, "Leave length alone in FULLSCAN mode"], [null, "PUTLG", function () {
    return [vm.$("VSP"), vm.$("MAXLEN")];
  }, "Else insert maximum length"], [null, "LCOMP", function () {
    return [vm.$("VSP"), vm.$("TXSP"), null, null, vm.$("TSALT")];
  }, "Length failure if too short"], [null, "CHKVAL", function () {
    return [vm.$("MAXLEN"), vm.$("ZEROCL"), vm.$("XSP"), null, vm.$("ANYC4"), vm.$("ANYC4")];
  }, "E3.5.7"], [null, "ADDLG", function () {
    return [vm.$("VSP"), vm.$("ONECL")];
  }, "E3.5.7"], ["ANYC4", "REMSP", function () {
    return [vm.$("YSP"), vm.$("VSP"), vm.$("TXSP")];
  }, "Get specifier to unscanned portion"], [null, "STREAM", function () {
    return [vm.$("ZSP"), vm.$("YSP"), vm.$("SNABTB"), vm.$("TSALF"), vm.$("TSALT")];
  }, ""], [null, "GETLG", function () {
    return [vm.$("XPTR"), vm.$("ZSP")];
  }, "Get length accepted"], [null, "ADDLG", function () {
    return [vm.$("TXSP"), vm.$("XPTR")];
  }, "Add to length matched"], [null, "BRANCH", function () {
    return [vm.$("SCOK"), vm.$("SCNR")];
  }, "Return to success point"], ["BRKC", "PROC", function () {
    return [vm.$("ANYC")];
  }, "Matching procedure for BREAK(S)"], [null, "SETAC", function () {
    return [vm.$("SCL"), 2];
  }, "Post entry"], [null, "BRANCH", function () {
    return [vm.$("ABNS")];
  }, ""], ["BRKV", "DEQL", function () {
    return [vm.$("XPTR"), vm.$("TBLCS"), vm.$("BRKC2")];
  }, "Was last argument the same?"], [null, "AEQL", function () {
    return [vm.$("TBLFNC"), vm.$("BRKCCL"), null, vm.$("ANYC3")];
  }, ""], ["BRKC2", "CLERTB", function () {
    return [vm.$("SNABTB"), vm.$("CONTIN")];
  }, "If not, clear stream table"], [null, "LOCSP", function () {
    return [vm.$("YSP"), vm.$("XPTR")];
  }, ""], [null, "PLUGTB", function () {
    return [vm.$("SNABTB"), vm.$("STOPSH"), vm.$("YSP")];
  }, "Plug entries for characters"], [null, "MOVD", function () {
    return [vm.$("TBLCS"), vm.$("XPTR")];
  }, "Save argument to check next time"], [null, "MOVD", function () {
    return [vm.$("TBLFNC"), vm.$("BRKCCL")];
  }, "Save procedure to check next time"], [null, "BRANCH", function () {
    return [vm.$("ANYC3")];
  }, "Proceed"], ["NNYC", "PROC", function () {
    return [vm.$("ANYC")];
  }, "Matching procedure for NOTANY(S)"], [null, "SETAC", function () {
    return [vm.$("SCL"), 3];
  }, "Post entry"], [null, "BRANCH", function () {
    return [vm.$("ABNS")];
  }, ""], ["NNYV", "DEQL", function () {
    return [vm.$("XPTR"), vm.$("TBLCS"), vm.$("NNYC2")];
  }, "Was last argument the same?"], [null, "AEQL", function () {
    return [vm.$("TBLFNC"), vm.$("NNYCCL"), null, vm.$("ANYC3")];
  }, ""], ["NNYC2", "CLERTB", function () {
    return [vm.$("SNABTB"), vm.$("STOP")];
  }, "If not, clear stream table"], [null, "LOCSP", function () {
    return [vm.$("YSP"), vm.$("XPTR")];
  }, ""], [null, "PLUGTB", function () {
    return [vm.$("SNABTB"), vm.$("ERROR"), vm.$("YSP")];
  }, "Plug entries for characters"], [null, "MOVD", function () {
    return [vm.$("TBLCS"), vm.$("XPTR")];
  }, "Save argument to check next time"], [null, "MOVD", function () {
    return [vm.$("TBLFNC"), vm.$("NNYCCL")];
  }, "Save procedure to check next time"], [null, "BRANCH", function () {
    return [vm.$("ANYC3")];
  }, "Proceed"], ["SPNC", "PROC", function () {
    return [vm.$("ANYC")];
  }, "Matching procedure for SPAN(S)"], [null, "SETAC", function () {
    return [vm.$("SCL"), 4];
  }, "Post entry"], [null, "BRANCH", function () {
    return [vm.$("ABNS")];
  }, ""], ["SPNV", "DEQL", function () {
    return [vm.$("XPTR"), vm.$("TBLCS"), vm.$("SPNC2")];
  }, "Was last argument the same?"], [null, "AEQL", function () {
    return [vm.$("TBLFNC"), vm.$("SPNCCL"), null, vm.$("SPNC3")];
  }, ""], ["SPNC2", "CLERTB", function () {
    return [vm.$("SNABTB"), vm.$("STOPSH")];
  }, "If not, clear stream table"], [null, "LOCSP", function () {
    return [vm.$("YSP"), vm.$("XPTR")];
  }, ""], [null, "PLUGTB", function () {
    return [vm.$("SNABTB"), vm.$("CONTIN"), vm.$("YSP")];
  }, "Plug entries for characters"], [null, "MOVD", function () {
    return [vm.$("TBLCS"), vm.$("XPTR")];
  }, "Save argument to check next time"], [null, "MOVD", function () {
    return [vm.$("TBLFNC"), vm.$("SPNCCL")];
  }, "Save procedure to check next time"], ["SPNC3", "LCOMP", function () {
    return [vm.$("XSP"), vm.$("TXSP"), null, vm.$("TSALT"), vm.$("TSALT")];
  }, ""], [null, "REMSP", function () {
    return [vm.$("YSP"), vm.$("XSP"), vm.$("TXSP")];
  }, "Get specifier to unscanned portion"], [null, "STREAM", function () {
    return [vm.$("ZSP"), vm.$("YSP"), vm.$("SNABTB"), vm.$("TSALF")];
  }, ""], [null, "LEQLC", function () {
    return [vm.$("ZSP"), 0, null, vm.$("TSALF")];
  }, "Failure if length accepted is zero"], [null, "GETLG", function () {
    return [vm.$("XPTR"), vm.$("ZSP")];
  }, "Get length of accepted portion"], [null, "AEQLC", function () {
    return [vm.$("FULLCL"), 0, vm.$("SPNC5")];
  }, "Skip length check in FULLSCAN mode"], [null, "CHKVAL", function () {
    return [vm.$("MAXLEN"), vm.$("XPTR"), vm.$("TXSP"), vm.$("TSALT")];
  }, ""], ["SPNC5", "ADDLG", function () {
    return [vm.$("TXSP"), vm.$("XPTR")];
  }, "Add length accepted"], [null, "BRANCH", function () {
    return [vm.$("SCOK"), vm.$("SCNR")];
  }, ""], ["LNTH", "PROC", function () {
    return [null];
  }, "Matching procedure for LEN(N)"], [null, "SETAC", function () {
    return [vm.$("SCL"), 1];
  }, "Note entry"], ["LPRRT", "INCRA", function () {
    return [vm.$("PATICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("XPTR"), vm.$("PATBCL"), vm.$("PATICL")];
  }, "Get argument"], [null, "PUSH", function () {
    return [vm.$("SCL")];
  }, "Save entry indicator"], ["LPRRT1", "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("I"), null, vm.$("LPRRTI")];
  }, "Is it INTEGER?"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("E"), null, vm.$("LPRRTE")];
  }, "Is it EXPRESSION?"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("S"), null, vm.$("LPRRTV")];
  }, "E3.5.6"], [null, "POP", function () {
    return [vm.$("SCL")];
  }, "E3.5.6"], [null, "BRANCH", function () {
    return [vm.$("SCDTER")];
  }, "E3.5.6"], ["LPRRTE", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("EXPVAL"), vm.$("XPTR"), [null, vm.$("LPRRT1")]];
  }, "E3.2.1"], [null, "POP", function () {
    return [vm.$("SCL")];
  }, "E3.2.1"], [null, "BRANCH", function () {
    return [vm.$("TSALF")];
  }, "E3.2.1"], ["LPRRTV", "LOCSP", function () {
    return [vm.$("ZSP"), vm.$("XPTR")];
  }, "Get specifier"], [null, "SPCINT", function () {
    return [vm.$("XPTR"), vm.$("ZSP"), vm.$("SCDTER")];
  }, "Convert to INTEGER"], ["LPRRTI", "POP", function () {
    return [vm.$("SCL")];
  }, "Restore entry indicator"], [null, "SELBRA", function () {
    return [vm.$("SCL"), [null, vm.$("POSII"), vm.$("RPSII"), vm.$("RTBI"), vm.$("TBI")]];
  }, ""], [null, "ACOMPC", function () {
    return [vm.$("XPTR"), 0, null, null, vm.$("SCLENR")];
  }, "Check for negative length"], [null, "CHKVAL", function () {
    return [vm.$("MAXLEN"), vm.$("XPTR"), vm.$("TXSP"), vm.$("TSALT")];
  }, ""], [null, "ADDLG", function () {
    return [vm.$("TXSP"), vm.$("XPTR")];
  }, "Add to length matched"], [null, "BRANCH", function () {
    return [vm.$("SCOK"), vm.$("SCNR")];
  }, "Return successful match"], ["POSII", "ACOMPC", function () {
    return [vm.$("XPTR"), 0, null, null, vm.$("SCLENR")];
  }, "Check for negative position"], [null, "GETLG", function () {
    return [vm.$("NVAL"), vm.$("TXSP")];
  }, "Get cursor position"], [null, "ACOMP", function () {
    return [vm.$("XPTR"), vm.$("MAXLEN"), vm.$("TSALT")];
  }, "Check desired against maximum"], [null, "ACOMP", function () {
    return [vm.$("XPTR"), vm.$("NVAL"), vm.$("TSALF"), vm.$("TSCOK")];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("SALT"), vm.$("SCNR")];
  }, ""], ["RPSII", "ACOMPC", function () {
    return [vm.$("XPTR"), 0, null, null, vm.$("SCLENR")];
  }, "Check for negative position"], [null, "GETLG", function () {
    return [vm.$("NVAL"), vm.$("XSP")];
  }, "Get total length"], [null, "SUBTRT", function () {
    return [vm.$("TVAL"), vm.$("NVAL"), vm.$("XPTR")];
  }, "Find desired position"], [null, "GETLG", function () {
    return [vm.$("NVAL"), vm.$("TXSP")];
  }, "Get cursor position"], [null, "ACOMP", function () {
    return [vm.$("NVAL"), vm.$("TVAL"), vm.$("TSALT"), vm.$("TSCOK"), vm.$("TSALF")];
  }, ""], ["RTBI", "ACOMPC", function () {
    return [vm.$("XPTR"), 0, null, null, vm.$("SCLENR")];
  }, "Check for negative length"], [null, "GETLG", function () {
    return [vm.$("NVAL"), vm.$("XSP")];
  }, "Get total length"], [null, "SUBTRT", function () {
    return [vm.$("TVAL"), vm.$("NVAL"), vm.$("XPTR")];
  }, "Find desired position"], [null, "GETLG", function () {
    return [vm.$("NVAL"), vm.$("TXSP")];
  }, "Get current position"], [null, "ACOMP", function () {
    return [vm.$("NVAL"), vm.$("TVAL"), vm.$("TSALT")];
  }, "Compare two positions"], [null, "AEQLC", function () {
    return [vm.$("FULLCL"), 0, vm.$("RTBII")];
  }, "Check &FULLSCAN"], [null, "SETAV", function () {
    return [vm.$("NVAL"), vm.$("YCL")];
  }, "Get residual"], [null, "SUBTRT", function () {
    return [vm.$("NVAL"), vm.$("MAXLEN"), vm.$("NVAL")];
  }, "Find maximum allowed position"], [null, "ACOMP", function () {
    return [vm.$("NVAL"), vm.$("TVAL"), null, null, vm.$("TSALT")];
  }, "Compare with desired position"], ["RTBII", "PUTLG", function () {
    return [vm.$("TXSP"), vm.$("TVAL")];
  }, "Update length of string matched"], [null, "BRANCH", function () {
    return [vm.$("SCOK"), vm.$("SCNR")];
  }, ""], ["TBI", "ACOMPC", function () {
    return [vm.$("XPTR"), 0, null, null, vm.$("SCLENR")];
  }, "Check for negative length"], [null, "GETLG", function () {
    return [vm.$("NVAL"), vm.$("TXSP")];
  }, "Get cursor position"], [null, "ACOMP", function () {
    return [vm.$("NVAL"), vm.$("XPTR"), vm.$("TSALT")];
  }, "Check against desired position"], [null, "ACOMP", function () {
    return [vm.$("XPTR"), vm.$("MAXLEN"), vm.$("TSALT")];
  }, "Check for tab beyond end"], [null, "PUTLG", function () {
    return [vm.$("TXSP"), vm.$("XPTR")];
  }, "Update length of string matched"], [null, "BRANCH", function () {
    return [vm.$("SCOK"), vm.$("SCNR")];
  }, ""], ["POSI", "PROC", function () {
    return [vm.$("LNTH")];
  }, "Matching procedure for POS(N)"], [null, "SETAC", function () {
    return [vm.$("SCL"), 2];
  }, "Note entry"], [null, "BRANCH", function () {
    return [vm.$("LPRRT")];
  }, "Join common processing"], ["RPSI", "PROC", function () {
    return [vm.$("LNTH")];
  }, "Matching procedure for RPOS(N)"], [null, "SETAC", function () {
    return [vm.$("SCL"), 3];
  }, "Note entry"], [null, "BRANCH", function () {
    return [vm.$("LPRRT")];
  }, "Join common processing"], ["RTB", "PROC", function () {
    return [vm.$("LNTH")];
  }, "Matching procedure for RTAB(N)"], [null, "SETAC", function () {
    return [vm.$("SCL"), 4];
  }, "Note entry"], [null, "BRANCH", function () {
    return [vm.$("LPRRT")];
  }, "Join common processing"], ["TB", "PROC", function () {
    return [vm.$("LNTH")];
  }, "Matching procedure for TAB(N)"], [null, "SETAC", function () {
    return [vm.$("SCL"), 5];
  }, "Note entry"], [null, "BRANCH", function () {
    return [vm.$("LPRRT")];
  }, "Join common processing"], ["ARBN", "PROC", function () {
    return [null];
  }, "Matching for ARBNO(P)"], [null, "GETLG", function () {
    return [vm.$("TMVAL"), vm.$("TXSP")];
  }, "Get cursor position"], [null, "PUSH", function () {
    return [vm.$("TMVAL")];
  }, "Save cursor position"], [null, "BRANCH", function () {
    return [vm.$("SCOK"), vm.$("SCNR")];
  }, "Return matching successfully"], ["ARBF", "PROC", function () {
    return [vm.$("ARBN")];
  }, "Backup matching for ARBNO(P)"], [null, "POP", function () {
    return [[vm.$("TMVAL")]];
  }, "Restore cursor position"], [null, "BRANCH", function () {
    return [vm.$("ONAR2")];
  }, "Join common processing"], ["EARB", "PROC", function () {
    return [vm.$("ARBN")];
  }, ""], [null, "POP", function () {
    return [[vm.$("TMVAL")]];
  }, "Restore cursor position"], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), vm.$("DESCR"), vm.$("TMVAL")];
  }, "Insert on history list"], [null, "GETLG", function () {
    return [vm.$("TMVAL"), vm.$("TXSP")];
  }, "Get cursor position"], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), 2 * vm.$("DESCR"), vm.$("TMVAL")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), 3 * vm.$("DESCR"), vm.$("ZEROCL")];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("SCOK"), vm.$("SCNR")];
  }, "Return matching successfully"], ["ONAR", "PROC", function () {
    return [vm.$("ARBN")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("FULLCL"), 0, vm.$("TSCOK")];
  }, "Check &FULLSCAN"], [null, "MOVD", function () {
    return [vm.$("TVAL"), vm.$("ZEROCL")];
  }, ""], [null, "GETAC", function () {
    return [vm.$("TVAL"), vm.$("PDLPTR")];
  }, "-2*DESCR"], [null, "GETLG", function () {
    return [vm.$("TMVAL"), vm.$("TXSP")];
  }, "Get current cursor position"], [null, "ACOMP", function () {
    return [vm.$("TVAL"), vm.$("TMVAL"), vm.$("TSCOK"), null, vm.$("TSCOK")];
  }, ""], ["ONAR1", "PUSH", function () {
    return [vm.$("TVAL")];
  }, "Save cursor position"], [null, "DECRA", function () {
    return [vm.$("PDLPTR"), 6 * vm.$("DESCR")];
  }, "Delete history entries"], ["ONAR2", "AEQLC", function () {
    return [vm.$("LENFCL"), 0, vm.$("TSALT")];
  }, "Check length failure"], [null, "BRANCH", function () {
    return [vm.$("SALF"), vm.$("SCNR")];
  }, "Return matching failure"], ["ONRF", "PROC", function () {
    return [vm.$("ARBN")];
  }, ""], [null, "MOVD", function () {
    return [vm.$("TVAL"), vm.$("ZEROCL")];
  }, ""], [null, "GETAC", function () {
    return [vm.$("TVAL"), vm.$("PDLPTR")];
  }, "-2*DESCR"], [null, "BRANCH", function () {
    return [vm.$("ONAR1")];
  }, "Join processing"], ["FARB", "PROC", function () {
    return [null];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("FULLCL"), 0, null, vm.$("FARB2")];
  }, "Check &FULLSCAN"], [null, "SETAC", function () {
    return [vm.$("NVAL"), 0];
  }, "Set residual length to 0"], [null, "BRANCH", function () {
    return [vm.$("FARB3")];
  }, "Join processing"], ["FARB2", "AEQLC", function () {
    return [vm.$("LENFCL"), 0, vm.$("FARB1")];
  }, "Check for length failure"], [null, "SETAV", function () {
    return [vm.$("NVAL"), vm.$("YCL")];
  }, "Get residual length"], ["FARB3", "GETLG", function () {
    return [vm.$("TVAL"), vm.$("TXSP")];
  }, "Get cursor position"], [null, "SUM", function () {
    return [vm.$("TVAL"), vm.$("TVAL"), vm.$("NVAL")];
  }, "Add them"], [null, "ACOMP", function () {
    return [vm.$("TVAL"), vm.$("MAXLEN"), vm.$("FARB1"), vm.$("FARB1")];
  }, ""], [null, "ADDLG", function () {
    return [vm.$("TXSP"), vm.$("ONECL")];
  }, "Add one for ARB"], [null, "GETLG", function () {
    return [vm.$("TVAL"), vm.$("TXSP")];
  }, "Get length matched"], [null, "PUTAC", function () {
    return [vm.$("PDLPTR"), 2 * vm.$("DESCR"), vm.$("TVAL")];
  }, "Insert on history list"], [null, "BRANCH", function () {
    return [vm.$("SCOK"), vm.$("SCNR")];
  }, "Return successful match"], ["FARB1", "DECRA", function () {
    return [vm.$("PDLPTR"), 3 * vm.$("DESCR")];
  }, "Back over history entry"], [null, "BRANCH", function () {
    return [vm.$("SALT"), vm.$("SCNR")];
  }, ""], ["ATP", "PROC", function () {
    return [null];
  }, "Matching procedure for @X"], [null, "INCRA", function () {
    return [vm.$("PATICL"), vm.$("DESCR")];
  }, "Increment pattern offset"], [null, "GETD", function () {
    return [vm.$("XPTR"), vm.$("PATBCL"), vm.$("PATICL")];
  }, "Get argument"], ["ATP1", "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("E"), null, vm.$("ATPEXN")];
  }, "EXPRESSION must be evaluated"], [null, "GETLG", function () {
    return [vm.$("NVAL"), vm.$("TXSP")];
  }, "Get length of text matched"], [null, "SETVC", function () {
    return [vm.$("NVAL"), vm.$("I")];
  }, "Set INTEGER data type"], [null, "PUTDC", function () {
    return [vm.$("XPTR"), vm.$("DESCR"), vm.$("NVAL")];
  }, "Assign as value of variable X"], [null, "AEQLC", function () {
    return [vm.$("OUTSW"), 0, null, vm.$("ATP2")];
  }, "Check &OUTPUT"], [null, "LOCAPV", function () {
    return [vm.$("ZPTR"), vm.$("OUTATL"), vm.$("XPTR"), vm.$("ATP2")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("ZPTR"), vm.$("DESCR")];
  }, "Get output association descriptor"], [null, "RCALL", function () {
    return [null, vm.$("PUTOUT"), [vm.$("ZPTR"), vm.$("NVAL")]];
  }, "Perform output"], ["ATP2", "AEQLC", function () {
    return [vm.$("TRAPCL"), 0, null, vm.$("TSCOK")];
  }, "Check &TRACE"], [null, "LOCAPT", function () {
    return [vm.$("ATPTR"), vm.$("TVALL"), vm.$("XPTR"), vm.$("TSCOK")];
  }, ""], [null, "PUSH", function () {
    return [[vm.$("PATBCL"), vm.$("PATICL"), vm.$("WPTR"), vm.$("XCL"), vm.$("YCL")]];
  }, ""], [null, "PUSH", function () {
    return [[vm.$("MAXLEN"), vm.$("LENFCL"), vm.$("PDLPTR"), vm.$("PDLHED"), vm.$("NAMICL"), vm.$("NHEDCL")]];
  }, ""], [null, "SPUSH", function () {
    return [[vm.$("HEADSP"), vm.$("TSP"), vm.$("TXSP"), vm.$("XSP")]];
  }, ""], [null, "MOVD", function () {
    return [vm.$("PDLHED"), vm.$("PDLPTR")];
  }, "Set new stack heading"], [null, "MOVD", function () {
    return [vm.$("NHEDCL"), vm.$("NAMICL")];
  }, "Set new name list heading"], [null, "RCALL", function () {
    return [null, vm.$("TRPHND"), vm.$("ATPTR")];
  }, "E3.3.1"], [null, "SPOP", function () {
    return [[vm.$("XSP"), vm.$("TXSP"), vm.$("TSP"), vm.$("HEADSP")]];
  }, ""], [null, "POP", function () {
    return [[vm.$("NHEDCL"), vm.$("NAMICL"), vm.$("PDLHED"), vm.$("PDLPTR"), vm.$("LENFCL"), vm.$("MAXLEN")]];
  }, ""], [null, "POP", function () {
    return [[vm.$("YCL"), vm.$("XCL"), vm.$("WPTR"), vm.$("PATICL"), vm.$("PATBCL")]];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("SCOK"), vm.$("SCNR")];
  }, ""], ["ATPEXN", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("EXPEVL"), vm.$("XPTR"), [vm.$("TSALF"), vm.$("ATP1"), vm.$("SCNEMO")]];
  }, "E3.4.4"], ["BAL", "PROC", function () {
    return [null];
  }, "Matching procedure for BAL"], ["BALF1", "AEQLC", function () {
    return [vm.$("FULLCL"), 0, null, vm.$("BALF4")];
  }, "Check &FULLSCAN"], [null, "SETAC", function () {
    return [vm.$("NVAL"), 0];
  }, "Set length to zero"], [null, "BRANCH", function () {
    return [vm.$("BALF2")];
  }, ""], ["BALF4", "SETAV", function () {
    return [vm.$("NVAL"), vm.$("YCL")];
  }, ""], ["BALF2", "GETLG", function () {
    return [vm.$("TVAL"), vm.$("TXSP")];
  }, "Get length of text matched so far"], [null, "SUM", function () {
    return [vm.$("TVAL"), vm.$("TVAL"), vm.$("NVAL")];
  }, "Add remainder possible"], [null, "ACOMP", function () {
    return [vm.$("TVAL"), vm.$("MAXLEN"), vm.$("BAL1"), vm.$("BAL1")];
  }, ""], [null, "SUBTRT", function () {
    return [vm.$("TVAL"), vm.$("MAXLEN"), vm.$("TVAL")];
  }, "Get maximum length for BAL"], [null, "GETBAL", function () {
    return [vm.$("TXSP"), vm.$("TVAL"), vm.$("BAL1")];
  }, "Get balanced string"], [null, "GETLG", function () {
    return [vm.$("TVAL"), vm.$("TXSP")];
  }, "Get length matched"], [null, "PUTAC", function () {
    return [vm.$("PDLPTR"), 2 * vm.$("DESCR"), vm.$("TVAL")];
  }, "Insert history entry"], [null, "BRANCH", function () {
    return [vm.$("SCOK"), vm.$("SCNR")];
  }, "Successful match"], ["BAL1", "DECRA", function () {
    return [vm.$("PDLPTR"), 3 * vm.$("DESCR")];
  }, "Back over history entry"], [null, "ACOMP", function () {
    return [vm.$("PDLPTR"), vm.$("PDLHED"), vm.$("TSALF"), vm.$("TSALF"), vm.$("INTR13")];
  }, ""], ["BALF", "PROC", function () {
    return [vm.$("BAL")];
  }, "Matching procedure for BAL retry"], [null, "AEQLC", function () {
    return [vm.$("FULLCL"), 0, null, vm.$("BALF3")];
  }, "Check &FULLSCAN"], [null, "SETAC", function () {
    return [vm.$("NVAL"), 0];
  }, "If off, set length to zero"], [null, "BRANCH", function () {
    return [vm.$("BALF2")];
  }, "Reenter balanced matching"], ["BALF3", "AEQLC", function () {
    return [vm.$("LENFCL"), 0, vm.$("BAL1"), vm.$("BALF1")];
  }, "If on, test for length failure"], ["CHR", "PROC", function () {
    return [null];
  }, "Matching character string"], [null, "INCRA", function () {
    return [vm.$("PATICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("YPTR"), vm.$("PATBCL"), vm.$("PATICL")];
  }, "Get argument"], ["CHR1", "LOCSP", function () {
    return [vm.$("TSP"), vm.$("YPTR")];
  }, "Get specifier"], ["CHR2", "REMSP", function () {
    return [vm.$("VSP"), vm.$("XSP"), vm.$("TXSP")];
  }, "Remove part matched"], [null, "SUBSP", function () {
    return [vm.$("VSP"), vm.$("TSP"), vm.$("VSP"), vm.$("TSALT")];
  }, "Get part to match"], [null, "LEXCMP", function () {
    return [vm.$("VSP"), vm.$("TSP"), vm.$("TSALF"), null, vm.$("TSALF")];
  }, ""], [null, "GETLG", function () {
    return [vm.$("YPTR"), vm.$("TSP")];
  }, "Get length"], [null, "ADDLG", function () {
    return [vm.$("TXSP"), vm.$("YPTR")];
  }, "Update string matched"], [null, "BRANCH", function () {
    return [vm.$("SCOK"), vm.$("SCNR")];
  }, "Return successful match"], ["STAR", "PROC", function () {
    return [vm.$("CHR")];
  }, "Matching procedure for expressions"], [null, "INCRA", function () {
    return [vm.$("PATICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("YPTR"), vm.$("PATBCL"), vm.$("PATICL")];
  }, "Get argument expression"], ["STAR2", "RCALL", function () {
    return [vm.$("YPTR"), vm.$("EXPVAL"), vm.$("YPTR"), vm.$("TSALF")];
  }, ""], [null, "VEQLC", function () {
    return [vm.$("YPTR"), vm.$("E"), null, vm.$("STAR2")];
  }, "Is is EXPRESSION?"], [null, "SUM", function () {
    return [vm.$("XPTR"), vm.$("PATBCL"), vm.$("PATICL")];
  }, "Compute pointer to argument"], [null, "PUTDC", function () {
    return [vm.$("XPTR"), 7 * vm.$("DESCR"), vm.$("YPTR")];
  }, "Insert pointer in backup node"], [null, "VEQLC", function () {
    return [vm.$("YPTR"), vm.$("S"), null, vm.$("CHR1")];
  }, "Is it STRING?"], [null, "VEQLC", function () {
    return [vm.$("YPTR"), vm.$("P"), null, vm.$("STARP")];
  }, "Is it  PATTERN?"], [null, "VEQLC", function () {
    return [vm.$("YPTR"), vm.$("I"), vm.$("SCDTER")];
  }, "Is it INTEGER?"], [null, "INTSPC", function () {
    return [vm.$("TSP"), vm.$("YPTR")];
  }, "Get specifier for integer"], [null, "BRANCH", function () {
    return [vm.$("CHR2")];
  }, "Join processing"], ["STARP", "AEQLC", function () {
    return [vm.$("FULLCL"), 0, null, vm.$("STARP1")];
  }, "Check &FULLSCAN"], [null, "SETAC", function () {
    return [vm.$("NVAL"), 0];
  }, "Zero length"], [null, "BRANCH", function () {
    return [vm.$("STARP4")];
  }, "Join processing"], ["STARP1", "SETAV", function () {
    return [vm.$("NVAL"), vm.$("YCL")];
  }, "Get length"], ["STARP4", "SUBTRT", function () {
    return [vm.$("NVAL"), vm.$("MAXLEN"), vm.$("NVAL")];
  }, "Compute residual"], [null, "ACOMPC", function () {
    return [vm.$("NVAL"), 0, null, null, vm.$("TSALT")];
  }, ""], [null, "LVALUE", function () {
    return [vm.$("TSIZ"), vm.$("YPTR")];
  }, "Check &FULLSCAN"], [null, "AEQLC", function () {
    return [vm.$("FULLCL"), 0, vm.$("STARP6")];
  }, ""], [null, "ACOMP", function () {
    return [vm.$("TSIZ"), vm.$("NVAL"), vm.$("TSALT")];
  }, "Check against length"], ["STARP6", "INCRA", function () {
    return [vm.$("PDLPTR"), 3 * vm.$("DESCR")];
  }, "Make room for history"], [null, "ACOMP", function () {
    return [vm.$("PDLPTR"), vm.$("PDLEND"), vm.$("INTR31")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), vm.$("DESCR"), vm.$("SCFLCL")];
  }, "Insert failure function"], [null, "GETLG", function () {
    return [vm.$("TMVAL"), vm.$("TXSP")];
  }, "Get cursor position"], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), 2 * vm.$("DESCR"), vm.$("TMVAL")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), 3 * vm.$("DESCR"), vm.$("LENFCL")];
  }, ""], [null, "PUSH", function () {
    return [[vm.$("MAXLEN"), vm.$("PATBCL"), vm.$("PATICL"), vm.$("XCL"), vm.$("YCL")]];
  }, ""], [null, "MOVD", function () {
    return [vm.$("MAXLEN"), vm.$("NVAL")];
  }, "Set up new maximum"], [null, "RCALL", function () {
    return [null, vm.$("SCIN"), null, [vm.$("STARP5"), null, vm.$("RTNUL3")]];
  }, ""], ["STARP2", "POP", function () {
    return [[vm.$("YCL"), vm.$("XCL"), vm.$("PATICL"), vm.$("PATBCL"), vm.$("MAXLEN")]];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("SCOK"), vm.$("SCNR")];
  }, "Return matching successfully"], ["STARP5", "POP", function () {
    return [[vm.$("YCL"), vm.$("XCL"), vm.$("PATICL"), vm.$("PATBCL"), vm.$("MAXLEN")]];
  }, ""], ["STARP3", "AEQLC", function () {
    return [vm.$("LENFCL"), 0, vm.$("TSALT")];
  }, "Check length failure"], [null, "BRANCH", function () {
    return [vm.$("SALF"), vm.$("SCNR")];
  }, "Return matching failure"], ["DSAR", "PROC", function () {
    return [vm.$("CHR")];
  }, "Backup matching for expression"], [null, "INCRA", function () {
    return [vm.$("PATICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("YPTR"), vm.$("PATBCL"), vm.$("PATICL")];
  }, "Get argument"], [null, "VEQLC", function () {
    return [vm.$("YPTR"), vm.$("S"), null, vm.$("STARP3")];
  }, "Is it STRING?"], [null, "VEQLC", function () {
    return [vm.$("YPTR"), vm.$("P"), null, vm.$("DSARP")];
  }, "Is it PATTERN?"], [null, "VEQLC", function () {
    return [vm.$("YPTR"), vm.$("I"), vm.$("SCDTER"), vm.$("STARP3")];
  }, ""], ["DSARP", "AEQLC", function () {
    return [vm.$("FULLCL"), 0, null, vm.$("DSARP1")];
  }, "Check &FULLSCAN"], [null, "SETAC", function () {
    return [vm.$("NVAL"), 0];
  }, "Zero length"], [null, "BRANCH", function () {
    return [vm.$("DSARP2")];
  }, "Join processing"], ["DSARP1", "SETAV", function () {
    return [vm.$("NVAL"), vm.$("YCL")];
  }, "Get length"], ["DSARP2", "SUBTRT", function () {
    return [vm.$("NVAL"), vm.$("MAXLEN"), vm.$("NVAL")];
  }, "Compute residual"], [null, "PUSH", function () {
    return [[vm.$("MAXLEN"), vm.$("PATBCL"), vm.$("PATICL"), vm.$("XCL"), vm.$("YCL")]];
  }, ""], [null, "MOVD", function () {
    return [vm.$("MAXLEN"), vm.$("NVAL")];
  }, "Set up new maximum"], [null, "RCALL", function () {
    return [null, vm.$("UNSC"), null, [vm.$("STARP5"), vm.$("STARP2"), vm.$("RTNUL3")]];
  }, ""], ["FNCE", "PROC", function () {
    return [null];
  }, "Procedure for matching FENCE"], [null, "INCRA", function () {
    return [vm.$("PDLPTR"), 3 * vm.$("DESCR")];
  }, "Create new history entry"], [null, "ACOMP", function () {
    return [vm.$("PDLPTR"), vm.$("PDLEND"), vm.$("INTR31")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), vm.$("DESCR"), vm.$("FNCFCL")];
  }, "Insert FENCE failure function"], [null, "GETLG", function () {
    return [vm.$("TMVAL"), vm.$("TXSP")];
  }, "Get length"], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), 2 * vm.$("DESCR"), vm.$("TMVAL")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), 3 * vm.$("DESCR"), vm.$("LENFCL")];
  }, ""], [null, "SETAC", function () {
    return [vm.$("LENFCL"), 1];
  }, "Set length failure switch"], [null, "BRANIC", function () {
    return [vm.$("SCOKCL"), 0];
  }, "Return matching"], ["NME", "PROC", function () {
    return [null];
  }, "Matching procedure for naming"], [null, "INCRA", function () {
    return [vm.$("PDLPTR"), 3 * vm.$("DESCR")];
  }, "Make room for history entry"], [null, "ACOMP", function () {
    return [vm.$("PDLPTR"), vm.$("PDLEND"), vm.$("INTR31")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), vm.$("DESCR"), vm.$("FNMECL")];
  }, "Insert backup function"], [null, "GETLG", function () {
    return [vm.$("TMVAL"), vm.$("TXSP")];
  }, "Get cursor position"], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), 2 * vm.$("DESCR"), vm.$("TMVAL")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), 3 * vm.$("DESCR"), vm.$("LENFCL")];
  }, ""], [null, "PUSH", function () {
    return [[vm.$("TMVAL")]];
  }, "Save cursor"], [null, "SETAC", function () {
    return [vm.$("LENFCL"), 1];
  }, "Set length failure indicator"], [null, "BRANCH", function () {
    return [vm.$("SCOK"), vm.$("SCNR")];
  }, "Return matching successfully"], ["FNME", "PROC", function () {
    return [vm.$("NME")];
  }, "Backup procedure for naming"], [null, "POP", function () {
    return [[vm.$("TVAL")]];
  }, "Restore cursor"], ["FNME1", "AEQLC", function () {
    return [vm.$("LENFCL"), 0, vm.$("TSALT"), vm.$("TSALF")];
  }, ""], ["ENME", "PROC", function () {
    return [vm.$("NME")];
  }, "Naming process for X . Y"], [null, "INCRA", function () {
    return [vm.$("PATICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("YPTR"), vm.$("PATBCL"), vm.$("PATICL")];
  }, "Get argument"], [null, "POP", function () {
    return [[vm.$("NVAL")]];
  }, "Restore previous cursor position"], [null, "SETVA", function () {
    return [vm.$("YCL"), vm.$("NVAL")];
  }, "Set up length"], [null, "SETSP", function () {
    return [vm.$("TSP"), vm.$("TXSP")];
  }, "Copy specifier"], [null, "PUTLG", function () {
    return [vm.$("TSP"), vm.$("NVAL")];
  }, "Insert length"], [null, "REMSP", function () {
    return [vm.$("TSP"), vm.$("TXSP"), vm.$("TSP")];
  }, "Compute ramainder"], [null, "SUM", function () {
    return [vm.$("TPTR"), vm.$("NBSPTR"), vm.$("NAMICL")];
  }, "Compute position on name list"], [null, "PUTSPC", function () {
    return [vm.$("TPTR"), vm.$("DESCR"), vm.$("TSP")];
  }, "Insert specifier"], [null, "PUTDC", function () {
    return [vm.$("TPTR"), vm.$("DESCR") + vm.$("SPEC"), vm.$("YPTR")];
  }, ""], [null, "INCRA", function () {
    return [vm.$("NAMICL"), vm.$("DESCR") + vm.$("SPEC")];
  }, "Increment list offset"], [null, "ACOMP", function () {
    return [vm.$("NAMICL"), vm.$("NMOVER"), vm.$("INTR13"), vm.$("ENME1")];
  }, ""], ["ENME2", "INCRA", function () {
    return [vm.$("PDLPTR"), vm.$("DESCR") + vm.$("SPEC")];
  }, "Make room on history list"], [null, "ACOMP", function () {
    return [vm.$("PDLPTR"), vm.$("PDLEND"), vm.$("INTR31")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), vm.$("DESCR"), vm.$("DNMECL")];
  }, "Insert unravelling function"], ["ENME3", "GETLG", function () {
    return [vm.$("TMVAL"), vm.$("TXSP")];
  }, "Get cursor position"], [null, "MOVV", function () {
    return [vm.$("TMVAL"), vm.$("YCL")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), 2 * vm.$("DESCR"), vm.$("TMVAL")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), 3 * vm.$("DESCR"), vm.$("LENFCL")];
  }, ""], [null, "SETAC", function () {
    return [vm.$("LENFCL"), 1];
  }, "Set length failure"], [null, "BRANCH", function () {
    return [vm.$("SCOK"), vm.$("SCNR")];
  }, "Return matching successfully"], ["ENME1", "MOVD", function () {
    return [vm.$("WCL"), vm.$("NMOVER")];
  }, "Save copy of cuurent name list end"], [null, "INCRA", function () {
    return [vm.$("NMOVER"), vm.$("NAMLSZ") * vm.$("SPDR")];
  }, "Increment for larger block"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("NMOVER")];
  }, "Allocate larger block"], [null, "MOVBLK", function () {
    return [vm.$("TPTR"), vm.$("NBSPTR"), vm.$("WCL")];
  }, "Move in old block"], [null, "MOVD", function () {
    return [vm.$("NBSPTR"), vm.$("TPTR")];
  }, "Set up new base pointer"], [null, "BRANCH", function () {
    return [vm.$("ENME2")];
  }, "Rejoin processing"], ["DNME", "PROC", function () {
    return [vm.$("NME")];
  }, "Unravelling procedure for naming"], [null, "DECRA", function () {
    return [vm.$("NAMICL"), vm.$("DESCR") + vm.$("SPEC")];
  }, "Back off named string"], [null, "SUM", function () {
    return [vm.$("TPTR"), vm.$("NBSPTR"), vm.$("NAMICL")];
  }, "Compute current position"], ["DNME1", "PROC", function () {
    return [vm.$("NME")];
  }, ""], [null, "SETAV", function () {
    return [vm.$("VVAL"), vm.$("YCL")];
  }, ""], [null, "PUSH", function () {
    return [[vm.$("VVAL")]];
  }, "Preserve length"], [null, "BRANCH", function () {
    return [vm.$("FNME1")];
  }, ""], ["ENMI", "PROC", function () {
    return [vm.$("NME")];
  }, "Matching for X $ Y"], [null, "INCRA", function () {
    return [vm.$("PATICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("YPTR"), vm.$("PATBCL"), vm.$("PATICL")];
  }, "Get argument"], [null, "POP", function () {
    return [[vm.$("NVAL")]];
  }, "Restore initial length"], [null, "SETVA", function () {
    return [vm.$("YCL"), vm.$("NVAL")];
  }, "Move initial length into value field"], [null, "SETSP", function () {
    return [vm.$("TSP"), vm.$("TXSP")];
  }, "Get working specifier"], [null, "PUTLG", function () {
    return [vm.$("TSP"), vm.$("NVAL")];
  }, "Insert length"], [null, "REMSP", function () {
    return [vm.$("TSP"), vm.$("TXSP"), vm.$("TSP")];
  }, "Get specifier for part matched"], [null, "GETLG", function () {
    return [vm.$("ZCL"), vm.$("TSP")];
  }, "Get length of part"], [null, "ACOMP", function () {
    return [vm.$("ZCL"), vm.$("MLENCL"), vm.$("SCLNOR")];
  }, "Check &MAXLNGTH"], [null, "VEQLC", function () {
    return [vm.$("YPTR"), vm.$("E"), null, vm.$("ENMEXN")];
  }, "Is it EXPRESSION?"], ["ENMI5", "VEQLC", function () {
    return [vm.$("YPTR"), vm.$("K"), null, vm.$("ENMIC")];
  }, "Check for KEYWORD data type"], [null, "RCALL", function () {
    return [vm.$("VVAL"), vm.$("GENVAR"), [vm.$("TSPPTR")]];
  }, ""], ["ENMI3", "PUTDC", function () {
    return [vm.$("YPTR"), vm.$("DESCR"), vm.$("VVAL")];
  }, "Perform assignment"], [null, "AEQLC", function () {
    return [vm.$("OUTSW"), 0, null, vm.$("ENMI4")];
  }, "Check &OUTPUT"], [null, "LOCAPV", function () {
    return [vm.$("ZPTR"), vm.$("OUTATL"), vm.$("YPTR"), vm.$("ENMI4")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("ZPTR"), vm.$("DESCR")];
  }, "Get association"], [null, "RCALL", function () {
    return [null, vm.$("PUTOUT"), [vm.$("ZPTR"), vm.$("VVAL")]];
  }, "Perform output"], ["ENMI4", "ACOMPC", function () {
    return [vm.$("TRAPCL"), 0, null, vm.$("ENMI2"), vm.$("ENMI2")];
  }, ""], [null, "LOCAPT", function () {
    return [vm.$("ATPTR"), vm.$("TVALL"), vm.$("YPTR"), vm.$("ENMI2")];
  }, ""], [null, "PUSH", function () {
    return [[vm.$("PATBCL"), vm.$("PATICL"), vm.$("WPTR"), vm.$("XCL"), vm.$("YCL")]];
  }, ""], [null, "PUSH", function () {
    return [[vm.$("MAXLEN"), vm.$("LENFCL"), vm.$("PDLPTR"), vm.$("PDLHED"), vm.$("NAMICL"), vm.$("NHEDCL")]];
  }, ""], [null, "SPUSH", function () {
    return [[vm.$("HEADSP"), vm.$("TSP"), vm.$("TXSP"), vm.$("XSP")]];
  }, ""], [null, "MOVD", function () {
    return [vm.$("PDLHED"), vm.$("PDLPTR")];
  }, "Set up new history list head"], [null, "MOVD", function () {
    return [vm.$("NHEDCL"), vm.$("NAMICL")];
  }, "Set up new name list head"], [null, "RCALL", function () {
    return [null, vm.$("TRPHND"), vm.$("ATPTR")];
  }, "E3.3.1"], [null, "SPOP", function () {
    return [[vm.$("XSP"), vm.$("TXSP"), vm.$("TSP"), vm.$("HEADSP")]];
  }, ""], [null, "POP", function () {
    return [[vm.$("NHEDCL"), vm.$("NAMICL"), vm.$("PDLHED"), vm.$("PDLPTR"), vm.$("LENFCL"), vm.$("MAXLEN")]];
  }, ""], [null, "POP", function () {
    return [[vm.$("YCL"), vm.$("XCL"), vm.$("WPTR"), vm.$("PATICL"), vm.$("PATBCL")]];
  }, ""], ["ENMI2", "INCRA", function () {
    return [vm.$("PDLPTR"), 3 * vm.$("DESCR")];
  }, "Make room on history list"], [null, "ACOMP", function () {
    return [vm.$("PDLPTR"), vm.$("PDLEND"), vm.$("INTR31")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), vm.$("DESCR"), vm.$("DNMICL")];
  }, "Insert unravelling function"], [null, "BRANCH", function () {
    return [vm.$("ENME3")];
  }, "Join common processing"], ["ENMIC", "SPCINT", function () {
    return [vm.$("VVAL"), vm.$("TSP"), vm.$("SCDTER"), vm.$("ENMI3")];
  }, ""], ["ENMEXN", "PUSH", function () {
    return [vm.$("ZEROCL")];
  }, "E3.4.4 & E3.5.8"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("EXPEVL"), vm.$("YPTR"), [vm.$("TSALF"), null, vm.$("SCNEMO")]];
  }, "E3.4.4 & E3.5.8"], [null, "POP", function () {
    return [vm.$("ZEROCL")];
  }, "E3.4.4 & E3.5.8"], [null, "BRANCH", function () {
    return [vm.$("ENMI5")];
  }, "E3.4.4 & E3.5.8"], ["SUCE", "PROC", function () {
    return [null];
  }, "Matching procedure for SUCCEED"], ["SUCE1", "INCRA", function () {
    return [vm.$("PDLPTR"), 3 * vm.$("DESCR")];
  }, "Make room for history entry"], [null, "ACOMP", function () {
    return [vm.$("PDLPTR"), vm.$("PDLEND"), vm.$("INTR31")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), vm.$("DESCR"), vm.$("SUCFCL")];
  }, "Insert SUCCESS backup function"], [null, "GETLG", function () {
    return [vm.$("TMVAL"), vm.$("TXSP")];
  }, "Get length matched"], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), 2 * vm.$("DESCR"), vm.$("TMVAL")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("PDLPTR"), 3 * vm.$("DESCR"), vm.$("LENFCL")];
  }, ""], [null, "SETAC", function () {
    return [vm.$("LENFCL"), 1];
  }, "Set length failure"], [null, "BRANIC", function () {
    return [vm.$("SCOKCL"), 0];
  }, "Return successful match"], ["SUCF", "PROC", function () {
    return [vm.$("SUCE")];
  }, "SUCCEED failure"], [null, "GETDC", function () {
    return [vm.$("XCL"), vm.$("PDLPTR"), vm.$("DESCR")];
  }, "Get history entries"], [null, "GETDC", function () {
    return [vm.$("YCL"), vm.$("PDLPTR"), 2 * vm.$("DESCR")];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("SUCE1")];
  }, "Go in front door"], [null, "TITLE", function () {
    return ["Defined Functions"];
  }, ""], ["DEFINE", "PROC", function () {
    return [null];
  }, "DEFINE(P,E)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get prototype"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save prototype"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get entry point"], [null, "POP", function () {
    return [vm.$("XPTR")];
  }, "Restore prototype"], [null, "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Specifier for prototype"], [null, "STREAM", function () {
    return [vm.$("YSP"), vm.$("XSP"), vm.$("VARATB"), vm.$("PROTER"), vm.$("PROTER")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("STYPE"), vm.$("LPTYP"), vm.$("PROTER")];
  }, "Verify open parenthesis"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), [vm.$("YSPPTR")]];
  }, ""], [null, "RCALL", function () {
    return [vm.$("ZCL"), vm.$("FINDEX"), [vm.$("XPTR")]];
  }, "Get function descriptor for function"], [null, "DEQL", function () {
    return [vm.$("YPTR"), vm.$("NULVCL"), vm.$("DEFIN3")];
  }, "Check for omitted entry point"], [null, "MOVD", function () {
    return [vm.$("YPTR"), vm.$("XPTR")];
  }, "If omitted use function name"], ["DEFIN3", "PUSH", function () {
    return [vm.$("YPTR")];
  }, "Save entry point"], [null, "MOVD", function () {
    return [vm.$("YCL"), vm.$("ZEROCL")];
  }, "Set argument count to 0"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save function name"], ["DEFIN4", "FSHRTN", function () {
    return [vm.$("XSP"), 1];
  }, "Remove break character"], [null, "STREAM", function () {
    return [vm.$("YSP"), vm.$("XSP"), vm.$("VARATB"), vm.$("PROTER"), vm.$("PROTER")];
  }, ""], [null, "SELBRA", function () {
    return [vm.$("STYPE"), [vm.$("PROTER"), null, vm.$("DEFIN6")]];
  }, ""], [null, "LEQLC", function () {
    return [vm.$("YSP"), 0, null, vm.$("DEFIN4")];
  }, "Check for null argument"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), [vm.$("YSPPTR")]];
  }, ""], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save argument"], [null, "INCRA", function () {
    return [vm.$("YCL"), 1];
  }, "Increment argument count"], [null, "BRANCH", function () {
    return [vm.$("DEFIN4")];
  }, "Continue"], ["DEFIN6", "LEQLC", function () {
    return [vm.$("YSP"), 0, null, vm.$("DEFIN9")];
  }, ""], [null, "INCRA", function () {
    return [vm.$("YCL"), 1];
  }, "Increment argument count"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), [vm.$("YSPPTR")]];
  }, ""], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save argument"], ["DEFIN9", "SETVA", function () {
    return [vm.$("DEFCL"), vm.$("YCL")];
  }, ""], ["DEFIN8", "FSHRTN", function () {
    return [vm.$("XSP"), 1];
  }, ""], [null, "STREAM", function () {
    return [vm.$("YSP"), vm.$("XSP"), vm.$("VARATB"), vm.$("PROTER"), vm.$("DEF10")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("STYPE"), vm.$("CMATYP"), vm.$("PROTER")];
  }, "Verify comma"], [null, "LEQLC", function () {
    return [vm.$("YSP"), 0, null, vm.$("DEFIN8")];
  }, "Check for null argument"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), [vm.$("YSPPTR")]];
  }, ""], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save local argument"], [null, "INCRA", function () {
    return [vm.$("YCL"), 1];
  }, "Increment total count"], [null, "BRANCH", function () {
    return [vm.$("DEFIN8")];
  }, "Continue"], ["DEF10", "LEQLC", function () {
    return [vm.$("YSP"), 0, null, vm.$("DEF11")];
  }, "Check for null argument"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), vm.$("YSPPTR")];
  }, "Generate variable"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save argument"], [null, "INCRA", function () {
    return [vm.$("YCL"), 1];
  }, "Increment total count"], ["DEF11", "INCRA", function () {
    return [vm.$("YCL"), 2];
  }, "Increment for name and label"], [null, "MULTC", function () {
    return [vm.$("XCL"), vm.$("YCL"), vm.$("DESCR")];
  }, "Convert to address units"], [null, "SETVC", function () {
    return [vm.$("XCL"), vm.$("B")];
  }, "Insert block data type"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("BLOCK"), vm.$("XCL")];
  }, "Allocate block for definition"], [null, "PUTDC", function () {
    return [vm.$("ZCL"), 0, vm.$("DEFCL")];
  }, "Point to procedure descriptor"], [null, "PUTDC", function () {
    return [vm.$("ZCL"), vm.$("DESCR"), vm.$("XPTR")];
  }, "Insert definition block"], [null, "SUM", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), vm.$("XCL")];
  }, "Compute end of block"], ["DEF12", "DECRA", function () {
    return [vm.$("XPTR"), vm.$("DESCR")];
  }, "Decrement pointer"], [null, "POP", function () {
    return [vm.$("YPTR")];
  }, "Restore argument"], [null, "PUTDC", function () {
    return [vm.$("XPTR"), vm.$("DESCR"), vm.$("YPTR")];
  }, "Insert in definition block"], [null, "DECRA", function () {
    return [vm.$("YCL"), 1];
  }, "Decrement total count"], [null, "AEQLC", function () {
    return [vm.$("YCL"), 0, vm.$("DEF12"), vm.$("RETNUL")];
  }, "Check for end"], ["DEFFNC", "PROC", function () {
    return [null];
  }, "Procedure to invoke defined function"], [null, "SETAV", function () {
    return [vm.$("XCL"), vm.$("INCL")];
  }, "Get number of arguments in call"], [null, "MOVD", function () {
    return [vm.$("WCL"), vm.$("XCL")];
  }, "Save copy"], [null, "MOVD", function () {
    return [vm.$("YCL"), vm.$("INCL")];
  }, "Save function descriptor"], [null, "PSTACK", function () {
    return [vm.$("YPTR")];
  }, "Post stack position"], [null, "PUSH", function () {
    return [vm.$("NULVCL")];
  }, "Save null value for function name"], ["DEFF1", "INCRA", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("XPTR"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get object code descriptor"], [null, "TESTF", function () {
    return [vm.$("XPTR"), vm.$("FNC"), null, vm.$("DEFFC")];
  }, "Check for function descriptor"], ["DEFF2", "AEQLC", function () {
    return [vm.$("INSW"), 0, null, vm.$("DEFF14")];
  }, "Check &INPUT"], [null, "LOCAPV", function () {
    return [vm.$("ZPTR"), vm.$("INATL"), vm.$("XPTR"), vm.$("DEFF14")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("ZPTR"), vm.$("DESCR")];
  }, "Get association"], [null, "PUSH", function () {
    return [[vm.$("XCL"), vm.$("WCL"), vm.$("YCL"), vm.$("YPTR")]];
  }, "Save relevant descriptors"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("PUTIN"), [vm.$("ZPTR"), vm.$("XPTR")], vm.$("FAIL")];
  }, ""], [null, "POP", function () {
    return [[vm.$("YPTR"), vm.$("YCL"), vm.$("WCL"), vm.$("XCL")]];
  }, "Restore descriptors"], [null, "BRANCH", function () {
    return [vm.$("DEFF3")];
  }, "Join processing"], ["DEFF14", "GETDC", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), vm.$("DESCR")];
  }, "Get value"], ["DEFF3", "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save value"], [null, "DECRA", function () {
    return [vm.$("XCL"), 1];
  }, "Decrement argument count"], [null, "ACOMPC", function () {
    return [vm.$("XCL"), 0, vm.$("DEFF1"), null, vm.$("INTR10")];
  }, "Check for end"], [null, "GETDC", function () {
    return [vm.$("XCL"), vm.$("YCL"), 0];
  }, "Get expected number of arguments"], [null, "SETAV", function () {
    return [vm.$("XCL"), vm.$("XCL")];
  }, "Insert in A-field"], ["DEFF4", "ACOMP", function () {
    return [vm.$("WCL"), vm.$("XCL"), vm.$("DEFF9"), vm.$("DEFF5")];
  }, "Compare given and expected"], [null, "PUSH", function () {
    return [vm.$("NULVCL")];
  }, "Not enough, save null string"], [null, "INCRA", function () {
    return [vm.$("WCL"), 1];
  }, "Increment count"], [null, "BRANCH", function () {
    return [vm.$("DEFF4")];
  }, "Continue"], ["DEFF9", "POP", function () {
    return [vm.$("ZCL")];
  }, "Throw away extra argument"], [null, "DECRA", function () {
    return [vm.$("WCL"), 1];
  }, "Decrement count"], [null, "BRANCH", function () {
    return [vm.$("DEFF4")];
  }, "Continue"], ["DEFF5", "GETDC", function () {
    return [vm.$("ZCL"), vm.$("YCL"), vm.$("DESCR")];
  }, "Get definition block"], [null, "MOVD", function () {
    return [vm.$("XPTR"), vm.$("ZCL")];
  }, "Save copy"], [null, "GETSIZ", function () {
    return [vm.$("WCL"), vm.$("ZCL")];
  }, "Get size of block"], [null, "SUM", function () {
    return [vm.$("WPTR"), vm.$("ZCL"), vm.$("WCL")];
  }, "Compute pointer to end"], [null, "INCRA", function () {
    return [vm.$("XCL"), 1];
  }, "Increment for function name"], ["DEFF8", "INCRA", function () {
    return [vm.$("XPTR"), vm.$("DESCR")];
  }, "Increment pointer to block"], [null, "INCRA", function () {
    return [vm.$("YPTR"), vm.$("DESCR")];
  }, "Adjust stack pointer"], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("DESCR")];
  }, "Get argument name"], [null, "GETDC", function () {
    return [vm.$("TPTR"), vm.$("ZPTR"), vm.$("DESCR")];
  }, "Get current argument value"], [null, "GETDC", function () {
    return [vm.$("ATPTR"), vm.$("YPTR"), vm.$("DESCR")];
  }, "Get value from stack"], [null, "PUTDC", function () {
    return [vm.$("ZPTR"), vm.$("DESCR"), vm.$("ATPTR")];
  }, "Assign to argument name"], [null, "PUTDC", function () {
    return [vm.$("YPTR"), vm.$("DESCR"), vm.$("TPTR")];
  }, "Put current argument on stack"], [null, "DECRA", function () {
    return [vm.$("XCL"), 1];
  }, "Decrement count"], [null, "ACOMPC", function () {
    return [vm.$("XCL"), 0, vm.$("DEFF8"), null, vm.$("INTR10")];
  }, "Check for end"], ["DEFF10", "INCRA", function () {
    return [vm.$("XPTR"), vm.$("DESCR")];
  }, "Increment pointer to block"], [null, "AEQL", function () {
    return [vm.$("XPTR"), vm.$("WPTR"), null, vm.$("DEFFGO")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("DESCR")];
  }, "Get argument name from block"], [null, "GETDC", function () {
    return [vm.$("TPTR"), vm.$("ZPTR"), vm.$("DESCR")];
  }, "Get current value of argument"], [null, "PUSH", function () {
    return [vm.$("TPTR")];
  }, "Save current value"], [null, "PUTDC", function () {
    return [vm.$("ZPTR"), vm.$("DESCR"), vm.$("NULVCL")];
  }, "Assign null value to local"], [null, "BRANCH", function () {
    return [vm.$("DEFF10")];
  }, "Continue"], ["DEFFGO", "PUSH", function () {
    return [[vm.$("FRTNCL"), vm.$("STNOCL"), vm.$("OCICL"), vm.$("OCBSCL"), vm.$("ZCL"), vm.$("ZCL")]];
  }, ""], [null, "GETDC", function () {
    return [vm.$("XCL"), vm.$("ZCL"), vm.$("DESCR")];
  }, "Get entry label"], [null, "AEQLIC", function () {
    return [vm.$("XCL"), vm.$("ATTRIB"), 0, null, vm.$("UNDFFE")];
  }, "E3.0.2"], [null, "GETDC", function () {
    return [vm.$("OCBSCL"), vm.$("XCL"), vm.$("ATTRIB")];
  }, "E3.0.2"], [null, "ACOMPC", function () {
    return [vm.$("TRACL"), 0, null, vm.$("DEFF18"), vm.$("DEFF18")];
  }, ""], [null, "DECRA", function () {
    return [vm.$("TRACL"), 1];
  }, "Decrement &FTRACE"], [null, "GETDC", function () {
    return [vm.$("ATPTR"), vm.$("ZCL"), 2 * vm.$("DESCR")];
  }, "Get function name"], [null, "PUSH", function () {
    return [vm.$("ZCL")];
  }, "Save definition block"], [null, "RCALL", function () {
    return [null, vm.$("FENTR2"), [vm.$("ATPTR")], [vm.$("INTR10"), vm.$("INTR10")]];
  }, ""], [null, "POP", function () {
    return [vm.$("ZCL")];
  }, "Restore definition block"], ["DEFF18", "ACOMPC", function () {
    return [vm.$("TRAPCL"), 0, null, vm.$("DEFF19"), vm.$("DEFF19")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("ATPTR"), vm.$("ZCL"), 2 * vm.$("DESCR")];
  }, "Get function name"], [null, "LOCAPT", function () {
    return [vm.$("ATPTR"), vm.$("TFENTL"), vm.$("ATPTR"), vm.$("DEFF19")];
  }, ""], [null, "PUSH", function () {
    return [[vm.$("OCBSCL"), vm.$("ZCL")]];
  }, "Save object code base and block"], [null, "RCALL", function () {
    return [null, vm.$("TRPHND"), vm.$("ATPTR")];
  }, "E3.3.1"], [null, "POP", function () {
    return [[vm.$("ZCL"), vm.$("OCBSCL")]];
  }, "Restore base and block"], ["DEFF19", "INCRA", function () {
    return [vm.$("LVLCL"), 1];
  }, "Increment &FNCLEVEL"], [null, "ACOMPC", function () {
    return [vm.$("TRAPCL"), 0, null, vm.$("DEFF15"), vm.$("DEFF15")];
  }, ""], [null, "LOCAPT", function () {
    return [vm.$("ATPTR"), vm.$("TKEYL"), vm.$("FNCLKY"), vm.$("DEFF15")];
  }, ""], [null, "RCALL", function () {
    return [null, vm.$("TRPHND"), vm.$("ATPTR")];
  }, "E3.3.1"], ["DEFF15", "SETAC", function () {
    return [vm.$("OCICL"), 0];
  }, "Zero offset"], [null, "RCALL", function () {
    return [null, vm.$("INTERP"), null, [vm.$("DEFFF"), vm.$("DEFFNR")]];
  }, ""], [null, "MOVD", function () {
    return [vm.$("RETPCL"), vm.$("RETCL")];
  }, "Set &RTNTYPE to RETURN"], ["DEFFS1", "POP", function () {
    return [vm.$("ZCL")];
  }, "Restore definition block"], [null, "ACOMPC", function () {
    return [vm.$("TRACL"), 0, null, vm.$("DEFF20"), vm.$("DEFF20")];
  }, ""], [null, "DECRA", function () {
    return [vm.$("TRACL"), 1];
  }, "Decrement &FTRACE"], [null, "GETDC", function () {
    return [vm.$("ATPTR"), vm.$("ZCL"), 2 * vm.$("DESCR")];
  }, "Get function name"], [null, "PUSH", function () {
    return [vm.$("ZCL")];
  }, "Save definition block"], [null, "RCALL", function () {
    return [null, vm.$("FNEXT2"), [vm.$("ATPTR")], [vm.$("INTR10"), vm.$("INTR10")]];
  }, ""], [null, "POP", function () {
    return [vm.$("ZCL")];
  }, "Restore definition block"], ["DEFF20", "ACOMPC", function () {
    return [vm.$("TRAPCL"), 0, null, vm.$("DEFFS2"), vm.$("DEFFS2")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("ATPTR"), vm.$("ZCL"), 2 * vm.$("DESCR")];
  }, "Get function name"], [null, "LOCAPT", function () {
    return [vm.$("ATPTR"), vm.$("TFEXTL"), vm.$("ATPTR"), vm.$("DEFFS2")];
  }, ""], [null, "PUSH", function () {
    return [[vm.$("RETPCL"), vm.$("ZCL")]];
  }, "Save return and block"], [null, "RCALL", function () {
    return [null, vm.$("TRPHND"), vm.$("ATPTR")];
  }, "E3.3.1"], [null, "POP", function () {
    return [[vm.$("ZCL"), vm.$("RETPCL")]];
  }, "Restore block and return"], ["DEFFS2", "DECRA", function () {
    return [vm.$("LVLCL"), 1];
  }, "Decrement &FNCLEVEL"], [null, "ACOMPC", function () {
    return [vm.$("TRAPCL"), 0, null, vm.$("DEFF17"), vm.$("DEFF17")];
  }, ""], [null, "LOCAPT", function () {
    return [vm.$("ATPTR"), vm.$("TKEYL"), vm.$("FNCLKY"), vm.$("DEFF17")];
  }, ""], [null, "PUSH", function () {
    return [[vm.$("RETPCL"), vm.$("ZCL")]];
  }, "Save return and block"], [null, "RCALL", function () {
    return [null, vm.$("TRPHND"), vm.$("ATPTR")];
  }, "E3.3.1"], [null, "POP", function () {
    return [[vm.$("ZCL"), vm.$("RETPCL")]];
  }, "Restore block and return"], ["DEFF17", "POP", function () {
    return [[vm.$("ZCL"), vm.$("OCBSCL"), vm.$("OCICL"), vm.$("STNOCL"), vm.$("FRTNCL")]];
  }, ""], [null, "GETSIZ", function () {
    return [vm.$("WCL"), vm.$("ZCL")];
  }, "Get size of definition block"], [null, "DECRA", function () {
    return [vm.$("WCL"), vm.$("DESCR")];
  }, "Decrement pointer"], [null, "ACOMPC", function () {
    return [vm.$("WCL"), 0, null, vm.$("INTR10"), vm.$("INTR10")];
  }, ""], [null, "SUM", function () {
    return [vm.$("WPTR"), vm.$("ZCL"), vm.$("WCL")];
  }, "Compute pointer to last descriptor"], [null, "MOVD", function () {
    return [vm.$("YPTR"), vm.$("ZCL")];
  }, "Save pointer to block"], [null, "INCRA", function () {
    return [vm.$("YPTR"), vm.$("DESCR")];
  }, "Increment pointer"], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("YPTR"), vm.$("DESCR")];
  }, "Get function name"], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("ZPTR"), vm.$("DESCR")];
  }, "Get value to be returned"], ["DEFF6", "POP", function () {
    return [vm.$("XPTR")];
  }, "Get old value"], [null, "GETDC", function () {
    return [vm.$("YPTR"), vm.$("WPTR"), vm.$("DESCR")];
  }, "Get argument name"], [null, "PUTDC", function () {
    return [vm.$("YPTR"), vm.$("DESCR"), vm.$("XPTR")];
  }, "Restore old value"], [null, "DECRA", function () {
    return [vm.$("WPTR"), vm.$("DESCR")];
  }, "Decrement pointer"], [null, "AEQL", function () {
    return [vm.$("WPTR"), vm.$("ZCL"), vm.$("DEFF6")];
  }, "Check for end"], [null, "DEQL", function () {
    return [vm.$("RETPCL"), vm.$("FRETCL"), null, vm.$("FAIL")];
  }, "Check for FRETURN"], [null, "DEQL", function () {
    return [vm.$("RETPCL"), vm.$("NRETCL"), vm.$("RTZPTR")];
  }, ""], [null, "MOVD", function () {
    return [vm.$("XPTR"), vm.$("ZPTR")];
  }, "Move name to correct descriptor"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("S"), null, vm.$("DEFFVX")];
  }, "Check for natural variable"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("I"), null, vm.$("GENVIX")];
  }, "Convert integer"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("N"), null, vm.$("RTXNAM")];
  }, "Check for created variable"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("K"), vm.$("NONAME"), vm.$("RTXNAM")];
  }, ""], ["DEFFVX", "AEQLC", function () {
    return [vm.$("XPTR"), 0, vm.$("RTXNAM"), vm.$("NONAME")];
  }, ""], ["DEFFF", "MOVD", function () {
    return [vm.$("RETPCL"), vm.$("FRETCL")];
  }, "Set up FRETURN"], [null, "BRANCH", function () {
    return [vm.$("DEFFS1")];
  }, "Join processing"], ["DEFFC", "PUSH", function () {
    return [[vm.$("XCL"), vm.$("WCL"), vm.$("YCL"), vm.$("YPTR")]];
  }, "Save relevant descriptors"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("INVOKE"), [vm.$("XPTR")], [vm.$("FAIL"), vm.$("DEFFN")]];
  }, ""], [null, "POP", function () {
    return [[vm.$("YPTR"), vm.$("YCL"), vm.$("WCL"), vm.$("XCL")]];
  }, "Restore relevant variables"], [null, "BRANCH", function () {
    return [vm.$("DEFF3")];
  }, "Join processing"], ["DEFFN", "POP", function () {
    return [[vm.$("YPTR"), vm.$("YCL"), vm.$("WCL"), vm.$("XCL")]];
  }, "Restore relevant variables"], [null, "BRANCH", function () {
    return [vm.$("DEFF2")];
  }, "Join processing"], ["DEFFNR", "MOVD", function () {
    return [vm.$("RETPCL"), vm.$("NRETCL")];
  }, "Set up NRETURN"], [null, "BRANCH", function () {
    return [vm.$("DEFFS1")];
  }, "Join processing"], [null, "TITLE", function () {
    return ["External Functions"];
  }, ""], ["LOAD", "PROC", function () {
    return [null];
  }, "LOAD(P)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get prototype"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save prototype"], [null, "RCALL", function () {
    return [vm.$("WPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get library name"], [null, "LOCSP", function () {
    return [vm.$("VSP"), vm.$("WPTR")];
  }, "Get specifier for library"], [null, "POP", function () {
    return [vm.$("XPTR")];
  }, "Restore prototypr"], [null, "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier for prototype"], [null, "STREAM", function () {
    return [vm.$("YSP"), vm.$("XSP"), vm.$("VARATB"), vm.$("PROTER"), vm.$("PROTER")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("STYPE"), vm.$("LPTYP"), vm.$("PROTER")];
  }, "Verify left parenthesis"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), vm.$("YSPPTR")];
  }, "Generate variable for function"], [null, "RCALL", function () {
    return [vm.$("ZCL"), vm.$("FINDEX"), vm.$("XPTR")];
  }, "Find function"], [null, "MOVD", function () {
    return [vm.$("YCL"), vm.$("ZEROCL")];
  }, "Set argument count to zero"], ["LOAD4", "FSHRTN", function () {
    return [vm.$("XSP"), 1];
  }, "Remove break character"], [null, "STREAM", function () {
    return [vm.$("ZSP"), vm.$("XSP"), vm.$("VARATB"), vm.$("LOAD1"), vm.$("PROTER")];
  }, ""], [null, "SELBRA", function () {
    return [vm.$("STYPE"), [vm.$("PROTER"), null, vm.$("LOAD6")]];
  }, ""], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), vm.$("ZSPPTR")];
  }, "Generate variable for data type"], [null, "LOCAPV", function () {
    return [vm.$("XPTR"), vm.$("DTATL"), vm.$("XPTR"), vm.$("LOAD9")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), vm.$("DESCR")];
  }, "Extract data type code"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save data type code"], ["LOAD10", "INCRA", function () {
    return [vm.$("YCL"), 1];
  }, "Increment count of arguments"], [null, "BRANCH", function () {
    return [vm.$("LOAD4")];
  }, "Continue"], ["LOAD6", "INCRA", function () {
    return [vm.$("YCL"), 1];
  }, "Count last argument"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), vm.$("ZSPPTR")];
  }, "Generate variable for data type"], [null, "LOCAPV", function () {
    return [vm.$("XPTR"), vm.$("DTATL"), vm.$("XPTR"), vm.$("LOAD11")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), vm.$("DESCR")];
  }, "Get data type code"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save data type code"], ["LOAD13", "FSHRTN", function () {
    return [vm.$("XSP"), 1];
  }, "Delete right parenthesis"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), vm.$("XSPPTR")];
  }, "Generate variable for target"], [null, "LOCAPV", function () {
    return [vm.$("XPTR"), vm.$("DTATL"), vm.$("XPTR"), vm.$("LOAD7")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), vm.$("DESCR")];
  }, "Get data type code"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save data type code"], ["LOAD8", "SETVA", function () {
    return [vm.$("LODCL"), vm.$("YCL")];
  }, "Insert number of arguments"], [null, "INCRA", function () {
    return [vm.$("YCL"), 1];
  }, "Increment count"], [null, "MULTC", function () {
    return [vm.$("XCL"), vm.$("YCL"), vm.$("DESCR")];
  }, "Convert to address units"], [null, "INCRA", function () {
    return [vm.$("XCL"), vm.$("DESCR")];
  }, "Add space for entry point"], [null, "SETVC", function () {
    return [vm.$("XCL"), vm.$("B")];
  }, "Insert BLOCK data type"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("BLOCK"), vm.$("XCL")];
  }, "Allocate block for definition"], [null, "PUTDC", function () {
    return [vm.$("ZCL"), 0, vm.$("LODCL")];
  }, "Insert procedure descriptor"], [null, "PUTDC", function () {
    return [vm.$("ZCL"), vm.$("DESCR"), vm.$("XPTR")];
  }, "Insert definition block"], [null, "SUM", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), vm.$("XCL")];
  }, "Compute pointer to end of block"], ["LOAD12", "DECRA", function () {
    return [vm.$("XPTR"), vm.$("DESCR")];
  }, "Decrement pointer"], [null, "POP", function () {
    return [vm.$("YPTR")];
  }, "Restore data type"], [null, "PUTDC", function () {
    return [vm.$("XPTR"), vm.$("DESCR"), vm.$("YPTR")];
  }, "Insert in block"], [null, "DECRA", function () {
    return [vm.$("YCL"), 1];
  }, "Decrement count"], [null, "ACOMPC", function () {
    return [vm.$("YCL"), 0, vm.$("LOAD12")];
  }, "Check for end"], [null, "LOAD", function () {
    return [vm.$("YPTR"), vm.$("YSP"), vm.$("VSP"), vm.$("FAIL")];
  }, "Load external function"], [null, "PUTDC", function () {
    return [vm.$("XPTR"), 0, vm.$("YPTR")];
  }, "Insert entry point"], [null, "BRANCH", function () {
    return [vm.$("RETNUL")];
  }, "Return null string as value"], ["LOAD7", "PUSH", function () {
    return [vm.$("ZEROCL")];
  }, "Save 0 for unspecified type"], [null, "BRANCH", function () {
    return [vm.$("LOAD8")];
  }, "Continue"], ["LOAD9", "PUSH", function () {
    return [vm.$("ZEROCL")];
  }, "Save 0 for unspecified type"], [null, "BRANCH", function () {
    return [vm.$("LOAD10")];
  }, "Continue"], ["LOAD1", "PUSH", function () {
    return [vm.$("ZEROCL")];
  }, "Save 0 for unspecified type"], [null, "SETSP", function () {
    return [vm.$("TSP"), vm.$("XSP")];
  }, "Set up break check"], [null, "SETLC", function () {
    return [vm.$("TSP"), 1];
  }, "Set length to 1"], [null, "INCRA", function () {
    return [vm.$("YCL"), 1];
  }, ""], [null, "LEXCMP", function () {
    return [vm.$("TSP"), vm.$("RPRNSP"), vm.$("LOAD4"), vm.$("LOAD13"), vm.$("LOAD4")];
  }, ""], ["LOAD11", "PUSH", function () {
    return [vm.$("ZEROCL")];
  }, "Save 0 for unspecified type"], [null, "BRANCH", function () {
    return [vm.$("LOAD13")];
  }, "Continue"], ["UNLOAD", "PROC", function () {
    return [null];
  }, "UNLOAD(F)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get function name"], [null, "RCALL", function () {
    return [vm.$("ZCL"), vm.$("FINDEX"), vm.$("XPTR")];
  }, "Locate function descriptor"], [null, "PUTDC", function () {
    return [vm.$("ZCL"), 0, vm.$("UNDFCL")];
  }, "Undefine function"], [null, "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier"], [null, "UNLOAD", function () {
    return [vm.$("XSP")];
  }, "Unload external definition"], [null, "BRANCH", function () {
    return [vm.$("RETNUL")];
  }, "Return"], ["LNKFNC", "PROC", function () {
    return [null];
  }, "Procedure to link to externals"], [null, "SETAV", function () {
    return [vm.$("XCL"), vm.$("INCL")];
  }, "Get actual number of arguments"], [null, "MOVD", function () {
    return [vm.$("YCL"), vm.$("INCL")];
  }, "Save function descriptor"], [null, "SETAV", function () {
    return [vm.$("WCL"), vm.$("YCL")];
  }, "E3.9.1"], [null, "GETDC", function () {
    return [vm.$("ZCL"), vm.$("YCL"), vm.$("DESCR")];
  }, "Get definition block"], [null, "PSTACK", function () {
    return [vm.$("YPTR")];
  }, "Post stack position"], [null, "SETAC", function () {
    return [vm.$("TCL"), 2 * vm.$("DESCR")];
  }, "Set offset for first argument"], ["LNKF1", "PUSH", function () {
    return [[vm.$("XCL"), vm.$("ZCL"), vm.$("TCL"), vm.$("YPTR"), vm.$("WCL"), vm.$("YCL")]];
  }, ""], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("ARGVAL"), null, vm.$("FAIL")];
  }, "Evaluate argument"], [null, "POP", function () {
    return [[vm.$("YCL"), vm.$("WCL"), vm.$("YPTR"), vm.$("TCL"), vm.$("ZCL"), vm.$("XCL")]];
  }, ""], [null, "DECRA", function () {
    return [vm.$("WCL"), 1];
  }, "E3.9.1"], [null, "ACOMPC", function () {
    return [vm.$("WCL"), 0, null, null, vm.$("LNKF8")];
  }, "E3.9.1"], ["LNKF7", "GETD", function () {
    return [vm.$("ZPTR"), vm.$("ZCL"), vm.$("TCL")];
  }, "Get data type required"], [null, "VEQLC", function () {
    return [vm.$("ZPTR"), 0, null, vm.$("LNKF6")];
  }, "Check for possible conversion"], [null, "VEQL", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), null, vm.$("LNKF6")];
  }, "Skip if data types the same"], [null, "SETAV", function () {
    return [vm.$("DTCL"), vm.$("XPTR")];
  }, "Data type of argument"], [null, "MOVV", function () {
    return [vm.$("DTCL"), vm.$("ZPTR")];
  }, "Data type required"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("VIDTP"), null, vm.$("LNKVI")];
  }, "STRING-INTEGER"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("IVDTP"), null, vm.$("LNKIV")];
  }, "INTEGER-STRING"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("RIDTP"), null, vm.$("LNKRI")];
  }, "REAL-INTEGER"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("IRDTP"), null, vm.$("LNKIR")];
  }, "INTEGER-REAL"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("RVDTP"), null, vm.$("LNKRV")];
  }, "REAL-STRING"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("VRDTP"), vm.$("INTR1"), vm.$("LNKVR")];
  }, ""], ["LNKIV", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GNVARI"), vm.$("XPTR"), vm.$("LNKF6")];
  }, ""], ["LNKRI", "RLINT", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), vm.$("INTR1"), vm.$("LNKF6")];
  }, ""], ["LNKIR", "INTRL", function () {
    return [vm.$("XPTR"), vm.$("XPTR")];
  }, "Convert INTEGER to REAL"], [null, "BRANCH", function () {
    return [vm.$("LNKF6")];
  }, ""], ["LNKVR", "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier"], [null, "SPCINT", function () {
    return [vm.$("XPTR"), vm.$("XSP"), null, vm.$("LNKIR")];
  }, "Convert STRING to INTEGER"], [null, "SPREAL", function () {
    return [vm.$("XPTR"), vm.$("XSP"), vm.$("INTR1"), vm.$("LNKF6")];
  }, ""], ["LNKRV", "REALST", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, ""], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), vm.$("XSPPTR"), vm.$("LNKF6")];
  }, ""], ["LNKVI", "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier"], [null, "SPCINT", function () {
    return [vm.$("XPTR"), vm.$("XSP"), null, vm.$("LNKF6")];
  }, "Convert to INTEGER"], [null, "SPREAL", function () {
    return [vm.$("XPTR"), vm.$("XSP"), vm.$("INTR1"), vm.$("LNKRI")];
  }, ""], ["LNKF6", "INCRA", function () {
    return [vm.$("TCL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save argument"], ["LNKF8", "DECRA", function () {
    return [vm.$("XCL"), 1];
  }, "E3.9.1"], [null, "ACOMPC", function () {
    return [vm.$("XCL"), 0, vm.$("LNKF1")];
  }, "E3.9.1"], [null, "GETDC", function () {
    return [vm.$("WPTR"), vm.$("YCL"), 0];
  }, "Get procedure descriptor"], [null, "SETAV", function () {
    return [vm.$("WPTR"), vm.$("WPTR")];
  }, "Get argument count required"], ["LNKF4", "ACOMPC", function () {
    return [vm.$("WCL"), 0, null, vm.$("LNKF5"), vm.$("LNKF5")];
  }, "E3.9.1"], [null, "PUSH", function () {
    return [vm.$("NULVCL")];
  }, "E3.9.1"], [null, "DECRA", function () {
    return [vm.$("WCL"), 1];
  }, "Decrement argument count"], [null, "BRANCH", function () {
    return [vm.$("LNKF4")];
  }, "Continue"], ["LNKF5", "GETSIZ", function () {
    return [vm.$("WCL"), vm.$("ZCL")];
  }, "Get size of definition block"], [null, "SUM", function () {
    return [vm.$("XPTR"), vm.$("ZCL"), vm.$("WCL")];
  }, "Compute pointer to end"], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), 0];
  }, "Get data target descriptor"], [null, "GETDC", function () {
    return [vm.$("ZCL"), vm.$("ZCL"), vm.$("DESCR")];
  }, "Get function address"], [null, "INCRA", function () {
    return [vm.$("YPTR"), 2 * vm.$("DESCR")];
  }, "Get pointer to argument list"], [null, "LINK", function () {
    return [vm.$("ZPTR"), vm.$("YPTR"), vm.$("WPTR"), vm.$("ZCL"), vm.$("FAIL")];
  }, ""], [null, "VEQLC", function () {
    return [vm.$("ZPTR"), vm.$("L"), vm.$("RTZPTR")];
  }, "Check for linked string"], [null, "GETSPC", function () {
    return [vm.$("ZSP"), vm.$("ZPTR"), 0];
  }, "Get specifier"], [null, "BRANCH", function () {
    return [vm.$("GENVRZ")];
  }, "Go generate variable"], [null, "TITLE", function () {
    return ["Arrays, Tables, and Defined Data Objects"];
  }, ""], ["ARRAY", "PROC", function () {
    return [null];
  }, "ARRAY(P,V)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get prototype"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save prototype"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("ARGVAL"), null, vm.$("FAIL")];
  }, "Get initial value for array elements"], [null, "POP", function () {
    return [vm.$("XPTR")];
  }, "Restore prototype"], [null, "SETAC", function () {
    return [vm.$("ARRMRK"), 0];
  }, "Clear prototype analysis switch"], [null, "MOVD", function () {
    return [vm.$("WCL"), vm.$("ZEROCL")];
  }, "Initialize dimensionality to zero"], [null, "MOVD", function () {
    return [vm.$("XCL"), vm.$("ONECL")];
  }, "Initialize size to one"], [null, "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier to prototype"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save prototype for later insertion"], ["ARRAY1", "STREAM", function () {
    return [vm.$("YSP"), vm.$("XSP"), vm.$("NUMBTB"), vm.$("PROTER"), vm.$("ARROT1")];
  }, "E3.5.1"], [null, "SPCINT", function () {
    return [vm.$("YCL"), vm.$("YSP"), vm.$("PROTER")];
  }, "Convert string to integer"], [null, "SELBRA", function () {
    return [vm.$("STYPE"), [null, vm.$("ARRAY3")]];
  }, "Branch on colon or comma"], [null, "FSHRTN", function () {
    return [vm.$("XSP"), 1];
  }, "Delete colon"], [null, "STREAM", function () {
    return [vm.$("ZSP"), vm.$("XSP"), vm.$("NUMBTB"), vm.$("PROTER"), vm.$("ARROT2")];
  }, ""], [null, "SPCINT", function () {
    return [vm.$("ZCL"), vm.$("ZSP"), vm.$("PROTER")];
  }, "Convert upper bound to integer"], [null, "SELBRA", function () {
    return [vm.$("STYPE"), [vm.$("PROTER"), vm.$("ARRAY5")]];
  }, ""], ["ARRAY3", "ACOMPC", function () {
    return [vm.$("YCL"), 0, null, vm.$("PROTER"), vm.$("PROTER")];
  }, ""], [null, "MOVD", function () {
    return [vm.$("ZCL"), vm.$("YCL")];
  }, "Move to copy"], [null, "SETAC", function () {
    return [vm.$("YCL"), 1];
  }, "Set lower bound to default of one"], [null, "BRANCH", function () {
    return [vm.$("ARRAY6")];
  }, ""], ["ARRAY5", "SUBTRT", function () {
    return [vm.$("ZCL"), vm.$("ZCL"), vm.$("YCL")];
  }, "Compute difference"], [null, "SUM", function () {
    return [vm.$("ZCL"), vm.$("ZCL"), vm.$("ONECL")];
  }, "Add one"], [null, "ACOMPC", function () {
    return [vm.$("ZCL"), 0, null, null, vm.$("PROTER")];
  }, ""], ["ARRAY6", "SETVA", function () {
    return [vm.$("YCL"), vm.$("ZCL")];
  }, "Insert width of dimension"], [null, "PUSH", function () {
    return [vm.$("YCL")];
  }, "Save dimension information"], [null, "MULT", function () {
    return [vm.$("XCL"), vm.$("XCL"), vm.$("ZCL"), vm.$("PROTER")];
  }, "Compute size of array to this point"], [null, "INCRA", function () {
    return [vm.$("WCL"), 1];
  }, "Increase count of dimensions"], [null, "AEQLC", function () {
    return [vm.$("ARRMRK"), 0, vm.$("ARRAY7")];
  }, "E3.5.1"], [null, "FSHRTN", function () {
    return [vm.$("XSP"), 1];
  }, "Remove break character"], [null, "BRANCH", function () {
    return [vm.$("ARRAY1")];
  }, ""], ["ARROT1", "SETAC", function () {
    return [vm.$("ARRMRK"), 1];
  }, "On run out, mark end of prototype"], [null, "SPCINT", function () {
    return [vm.$("YCL"), vm.$("YSP"), vm.$("PROTER"), vm.$("ARRAY3")];
  }, ""], ["ARROT2", "SETAC", function () {
    return [vm.$("ARRMRK"), 1];
  }, "On run out, mark end of prototype"], [null, "SPCINT", function () {
    return [vm.$("ZCL"), vm.$("ZSP"), vm.$("PROTER"), vm.$("ARRAY5")];
  }, ""], ["ARRAY7", "SUM", function () {
    return [vm.$("ZCL"), vm.$("XCL"), vm.$("WCL")];
  }, "Add dimensionality to array size"], [null, "INCRA", function () {
    return [vm.$("ZCL"), 2];
  }, "Add two for heading information"], [null, "MULTC", function () {
    return [vm.$("ZCL"), vm.$("ZCL"), vm.$("DESCR")];
  }, "Convert to address units"], [null, "SETVC", function () {
    return [vm.$("ZCL"), vm.$("A")];
  }, "Insert ARRAY data type"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("BLOCK"), vm.$("ZCL")];
  }, "Allocate block for array structure"], [null, "MOVD", function () {
    return [vm.$("XPTR"), vm.$("ZPTR")];
  }, "Save copy"], [null, "SUM", function () {
    return [vm.$("WPTR"), vm.$("XPTR"), vm.$("ZCL")];
  }, "Get pointer to last descriptor"], [null, "PUTDC", function () {
    return [vm.$("ZPTR"), 2 * vm.$("DESCR"), vm.$("WCL")];
  }, "Insert dimensionality"], [null, "INCRA", function () {
    return [vm.$("XPTR"), vm.$("DESCR")];
  }, "Update working pointer"], ["ARRAY8", "INCRA", function () {
    return [vm.$("XPTR"), vm.$("DESCR")];
  }, "Update working pointer for another"], [null, "POP", function () {
    return [vm.$("YPTR")];
  }, "Restore index pair"], [null, "PUTDC", function () {
    return [vm.$("XPTR"), vm.$("DESCR"), vm.$("YPTR")];
  }, "Insert in structure"], [null, "DECRA", function () {
    return [vm.$("WCL"), 1];
  }, "Decrement dimensionality"], [null, "ACOMPC", function () {
    return [vm.$("WCL"), 0, vm.$("ARRAY8"), vm.$("ARRFIL")];
  }, "Check for last one"], ["ARRAY9", "PUTDC", function () {
    return [vm.$("XPTR"), vm.$("DESCR"), vm.$("TPTR")];
  }, "Insert initial value"], ["ARRFIL", "INCRA", function () {
    return [vm.$("XPTR"), vm.$("DESCR")];
  }, "Update working pointer"], [null, "ACOMP", function () {
    return [vm.$("XPTR"), vm.$("WPTR"), vm.$("INTR10"), null, vm.$("ARRAY9")];
  }, ""], [null, "POP", function () {
    return [vm.$("WPTR")];
  }, "RESTORE PROTOTYPE\t\tE3.10.1"], [null, "PUTDC", function () {
    return [vm.$("ZPTR"), vm.$("DESCR"), vm.$("WPTR")];
  }, "RETURN POINTER TO ARRAY\tE3.10.1"], [null, "BRANCH", function () {
    return [vm.$("RTZPTR")];
  }, "Return pointer to array structure"], ["ASSOC", "PROC", function () {
    return [null];
  }, "TABLE(N,M)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("INTVAL"), null, vm.$("FAIL")];
  }, "Get table size"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save size"], [null, "RCALL", function () {
    return [vm.$("WPTR"), vm.$("INTVAL"), null, vm.$("FAIL")];
  }, "Get secondary allocation"], [null, "MULT", function () {
    return [vm.$("ZPTR"), vm.$("WPTR"), vm.$("DSCRTW"), vm.$("SIZERR")];
  }, "E3.10.4"], [null, "INCRA", function () {
    return [vm.$("ZPTR"), 2 * vm.$("DESCR")];
  }, "E3.10.4"], [null, "ACOMP", function () {
    return [vm.$("ZPTR"), vm.$("SIZLMT"), vm.$("SIZERR"), vm.$("SIZERR")];
  }, "E3.10.4"], [null, "POP", function () {
    return [vm.$("XPTR")];
  }, "Restore size"], [null, "ACOMPC", function () {
    return [vm.$("XPTR"), 0, vm.$("ASSOC1"), null, vm.$("LENERR")];
  }, ""], [null, "SETAC", function () {
    return [vm.$("XPTR"), vm.$("EXTSIZ")];
  }, ""], ["ASSOC1", "INCRA", function () {
    return [vm.$("XPTR"), 1];
  }, "E3.2.3"], [null, "MULTC", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), 2 * vm.$("DESCR")];
  }, "E3.2.3"], [null, "ACOMPC", function () {
    return [vm.$("WPTR"), 0, vm.$("ASSOC4"), null, vm.$("LENERR")];
  }, ""], [null, "SETAC", function () {
    return [vm.$("WPTR"), vm.$("EXTSIZ")];
  }, ""], ["ASSOC4", "INCRA", function () {
    return [vm.$("WPTR"), 1];
  }, "E3.2.3"], [null, "MULTC", function () {
    return [vm.$("WPTR"), vm.$("WPTR"), 2 * vm.$("DESCR")];
  }, "E3.2.3"], [null, "SETVC", function () {
    return [vm.$("XPTR"), vm.$("T")];
  }, "E3.2.3"], ["ASSOCE", "PROC", function () {
    return [vm.$("ASSOC")];
  }, "E3.2.3"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("BLOCK"), vm.$("XPTR")];
  }, "E3.2.3"], [null, "PUTD", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("ONECL")];
  }, "E3.2.3"], [null, "DECRA", function () {
    return [vm.$("XPTR"), vm.$("DESCR")];
  }, "E3.2.3"], [null, "PUTD", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("WPTR")];
  }, "E3.2.3"], ["ASSOC2", "DECRA", function () {
    return [vm.$("XPTR"), 2 * vm.$("DESCR")];
  }, "E3.2.3"], [null, "PUTD", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("NULVCL")];
  }, "E3.2.3"], [null, "AEQLC", function () {
    return [vm.$("XPTR"), vm.$("DESCR"), vm.$("ASSOC2"), vm.$("RTZPTR")];
  }, "E3.2.3"], ["DATDEF", "PROC", function () {
    return [null];
  }, "DATA(P)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get prototype"], [null, "SETAC", function () {
    return [vm.$("DATACL"), 0];
  }, "Initialize prototype switch"], [null, "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier"], [null, "STREAM", function () {
    return [vm.$("YSP"), vm.$("XSP"), vm.$("VARATB"), vm.$("PROTER"), vm.$("PROTER")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("STYPE"), vm.$("LPTYP"), vm.$("PROTER")];
  }, "Verify left parenthesis"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), [vm.$("YSPPTR")]];
  }, ""], [null, "RCALL", function () {
    return [vm.$("ZCL"), vm.$("FINDEX"), [vm.$("XPTR")]];
  }, "Find function descriptor"], [null, "INCRV", function () {
    return [vm.$("DATSEG"), 1];
  }, "Increment data type code"], [null, "VEQLC", function () {
    return [vm.$("DATSEG"), vm.$("DATSIZ"), null, vm.$("INTR27")];
  }, ""], [null, "MOVD", function () {
    return [vm.$("YCL"), vm.$("ZEROCL")];
  }, "Initialize count of fields"], [null, "RCALL", function () {
    return [vm.$("DTATL"), vm.$("AUGATL"), [vm.$("DTATL"), vm.$("DATSEG"), vm.$("XPTR")]];
  }, ""], [null, "PSTACK", function () {
    return [vm.$("WPTR")];
  }, "Post stack position"], [null, "PUSH", function () {
    return [[vm.$("DATSEG"), vm.$("XPTR")]];
  }, "Save code and name"], ["DATA3", "FSHRTN", function () {
    return [vm.$("XSP"), 1];
  }, "Delete break character"], [null, "AEQLC", function () {
    return [vm.$("DATACL"), 0, vm.$("DAT5")];
  }, "Check for prototype end"], [null, "STREAM", function () {
    return [vm.$("YSP"), vm.$("XSP"), vm.$("VARATB"), vm.$("PROTER"), vm.$("PROTER")];
  }, ""], [null, "SELBRA", function () {
    return [vm.$("STYPE"), [vm.$("PROTER"), null, vm.$("DATA6")]];
  }, ""], ["DATA4", "LEQLC", function () {
    return [vm.$("YSP"), 0, null, vm.$("DATA3")];
  }, "Check for zero length"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), vm.$("YSPPTR")];
  }, "Generate variable"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save field name"], [null, "RCALL", function () {
    return [vm.$("XCL"), vm.$("FINDEX"), [vm.$("XPTR")]];
  }, "Find function descriptor for field"], [null, "GETDC", function () {
    return [vm.$("WCL"), vm.$("XCL"), 0];
  }, "Get procedure descriptor"], [null, "DEQL", function () {
    return [vm.$("WCL"), vm.$("FLDCL"), vm.$("DAT6")];
  }, "Check for FIELD procedure"], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("XCL"), vm.$("DESCR")];
  }, "Get field definition block"], [null, "MULTC", function () {
    return [vm.$("TCL"), vm.$("YCL"), vm.$("DESCR")];
  }, ""], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("AUGATL"), [vm.$("ZPTR"), vm.$("DATSEG"), vm.$("TCL")]];
  }, ""], ["DAT7", "PUTDC", function () {
    return [vm.$("XCL"), vm.$("DESCR"), vm.$("ZPTR")];
  }, "Insert new definition block"], [null, "INCRA", function () {
    return [vm.$("YCL"), 1];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("DATA3")];
  }, "Continue"], ["DATA6", "SETAC", function () {
    return [vm.$("DATACL"), 1];
  }, "Note end of prototype analysis"], [null, "BRANCH", function () {
    return [vm.$("DATA4")];
  }, "Join field processing"], ["DAT5", "LEQLC", function () {
    return [vm.$("XSP"), 0, vm.$("PROTER")];
  }, "Verify prototype consumption"], [null, "AEQLC", function () {
    return [vm.$("YCL"), 0, null, vm.$("PROTER")];
  }, "E3.1.2"], [null, "SETVA", function () {
    return [vm.$("DATCL"), vm.$("YCL")];
  }, "Insert field count for data function"], [null, "PUTDC", function () {
    return [vm.$("ZCL"), 0, vm.$("DATCL")];
  }, "Insert new procedure descriptor"], [null, "MULTC", function () {
    return [vm.$("YCL"), vm.$("YCL"), vm.$("DESCR")];
  }, ""], [null, "INCRA", function () {
    return [vm.$("YCL"), 2 * vm.$("DESCR")];
  }, "Add two for the number and name"], [null, "MOVV", function () {
    return [vm.$("YCL"), vm.$("DATSEG")];
  }, "Insert defined data code"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("BLOCK"), vm.$("YCL")];
  }, "Allocate definition block"], [null, "INCRA", function () {
    return [vm.$("WPTR"), vm.$("DESCR")];
  }, "E3.0.3"], [null, "MOVBLK", function () {
    return [vm.$("ZPTR"), vm.$("WPTR"), vm.$("YCL")];
  }, "Copy from stack into block"], [null, "PUTDC", function () {
    return [vm.$("ZCL"), vm.$("DESCR"), vm.$("ZPTR")];
  }, "Insert definition block"], [null, "BRANCH", function () {
    return [vm.$("RETNUL")];
  }, "Return null value"], ["DAT6", "PUTDC", function () {
    return [vm.$("XCL"), 0, vm.$("FLDCL")];
  }, "Insert FIELD procedure descriptor"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("BLOCK"), vm.$("TWOCL")];
  }, "Allocate definition block"], [null, "PUTDC", function () {
    return [vm.$("ZPTR"), vm.$("DESCR"), vm.$("DATSEG")];
  }, "Insert data type code"], [null, "MULTC", function () {
    return [vm.$("TCL"), vm.$("YCL"), vm.$("DESCR")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("ZPTR"), 2 * vm.$("DESCR"), vm.$("TCL")];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("DAT7")];
  }, "Join processing"], ["PROTO", "PROC", function () {
    return [null];
  }, "PROTOTYPE(A)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("ARGVAL"), null, vm.$("FAIL")];
  }, "Get argument"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("A"), vm.$("NONARY")];
  }, "Verify ARRAY"], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("DESCR")];
  }, "Get prototype"], [null, "BRANCH", function () {
    return [vm.$("RTZPTR")];
  }, "Return"], ["ITEM", "PROC", function () {
    return [null];
  }, "Array or table reference"], [null, "SETAV", function () {
    return [vm.$("XCL"), vm.$("INCL")];
  }, "Get argument count"], [null, "DECRA", function () {
    return [vm.$("XCL"), 1];
  }, "Skip referenced object"], [null, "PUSH", function () {
    return [vm.$("XCL")];
  }, "Save count"], [null, "RCALL", function () {
    return [vm.$("YCL"), vm.$("ARGVAL"), null, vm.$("FAIL")];
  }, "Get referenced object"], [null, "POP", function () {
    return [vm.$("XCL")];
  }, "Restore count"], [null, "VEQLC", function () {
    return [vm.$("YCL"), vm.$("A"), null, vm.$("ARYAD3")];
  }, "ARRAY is acceptable"], [null, "VEQLC", function () {
    return [vm.$("YCL"), vm.$("T"), vm.$("NONARY"), vm.$("ASSCR")];
  }, "TABLE is acceptable"], ["ARYAD3", "MOVD", function () {
    return [vm.$("WCL"), vm.$("XCL")];
  }, "Save copy of argument count"], ["ARYAD1", "ACOMPC", function () {
    return [vm.$("XCL"), 0, null, vm.$("ARYAD2"), vm.$("ARYAD2")];
  }, ""], [null, "PUSH", function () {
    return [[vm.$("XCL"), vm.$("WCL"), vm.$("YCL")]];
  }, "Save"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("INTVAL"), null, vm.$("FAIL")];
  }, "Get index"], [null, "POP", function () {
    return [[vm.$("YCL"), vm.$("WCL"), vm.$("XCL")]];
  }, "Restore saved descriptors"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save index"], [null, "DECRA", function () {
    return [vm.$("XCL"), 1];
  }, "Decrement argument count"], [null, "BRANCH", function () {
    return [vm.$("ARYAD1")];
  }, ""], ["ARYAD2", "MOVD", function () {
    return [vm.$("ZPTR"), vm.$("ZEROCL")];
  }, "Initialize offset to zero"], [null, "GETDC", function () {
    return [vm.$("ZCL"), vm.$("YCL"), 2 * vm.$("DESCR")];
  }, "Get number of dimensions"], [null, "MULTC", function () {
    return [vm.$("YPTR"), vm.$("ZCL"), vm.$("DESCR")];
  }, "Convert to addressing units"], [null, "SUM", function () {
    return [vm.$("YPTR"), vm.$("YCL"), vm.$("YPTR")];
  }, "Add base and offset"], [null, "INCRA", function () {
    return [vm.$("YPTR"), 2 * vm.$("DESCR")];
  }, "Add two for heading"], ["ARYAD7", "ACOMP", function () {
    return [vm.$("WCL"), vm.$("ZCL"), vm.$("ARGNER"), vm.$("ARYAD9")];
  }, ""], [null, "PUSH", function () {
    return [vm.$("ZEROCL")];
  }, "If too few, supply a zero"], [null, "INCRA", function () {
    return [vm.$("WCL"), 1];
  }, "Increment and loop"], [null, "BRANCH", function () {
    return [vm.$("ARYAD7")];
  }, ""], ["ARYAD9", "INCRA", function () {
    return [vm.$("YCL"), 2 * vm.$("DESCR")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("WPTR"), vm.$("YCL"), vm.$("DESCR")];
  }, "Get index pair"], [null, "SETAV", function () {
    return [vm.$("TPTR"), vm.$("WPTR")];
  }, "Get extent of dimension"], ["ARYA11", "POP", function () {
    return [vm.$("XPTR")];
  }, "Get index value"], [null, "SUBTRT", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), vm.$("WPTR")];
  }, "Compute differnece from lower bound"], [null, "ACOMPC", function () {
    return [vm.$("XPTR"), 0, null, null, vm.$("FAIL")];
  }, "If less than zero, out of bounds"], [null, "ACOMP", function () {
    return [vm.$("XPTR"), vm.$("TPTR"), vm.$("FAIL"), vm.$("FAIL")];
  }, "If greater than extent, out of bound"], [null, "SUM", function () {
    return [vm.$("XPTR"), vm.$("ZPTR"), vm.$("XPTR")];
  }, "Else add to evolving sum"], [null, "DECRA", function () {
    return [vm.$("ZCL"), 1];
  }, "Decrement dimension count"], [null, "ACOMPC", function () {
    return [vm.$("ZCL"), 0, null, vm.$("ARYA12")];
  }, "Get out if done"], [null, "INCRA", function () {
    return [vm.$("YCL"), vm.$("DESCR")];
  }, "Adjust bas pointer"], [null, "GETDC", function () {
    return [vm.$("WPTR"), vm.$("YCL"), vm.$("DESCR")];
  }, "Get index pair"], [null, "SETAV", function () {
    return [vm.$("TPTR"), vm.$("WPTR")];
  }, "Get extent of dimension"], [null, "MULT", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("TPTR")];
  }, "Multiply for next dimension"], [null, "BRANCH", function () {
    return [vm.$("ARYA11")];
  }, "Continue with next dimension"], ["ARYA12", "MULTC", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), vm.$("DESCR")];
  }, "Expand offset into addressing units"], [null, "SUM", function () {
    return [vm.$("XPTR"), vm.$("YPTR"), vm.$("XPTR")];
  }, "Add to adjusted base"], ["ARYA10", "SETVC", function () {
    return [vm.$("XPTR"), vm.$("N")];
  }, "Insert NAME data type"], [null, "BRANCH", function () {
    return [vm.$("RTXNAM")];
  }, "Return interior pointer"], ["ASSCR", "AEQLC", function () {
    return [vm.$("XCL"), 1, vm.$("ARGNER")];
  }, "Only one argument for tables"], [null, "PUSH", function () {
    return [vm.$("YCL")];
  }, "Save pointer to object"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("ARGVAL"), null, vm.$("FAIL")];
  }, "Evaluate argument"], [null, "POP", function () {
    return [vm.$("XPTR")];
  }, "E3.2.3"], ["ASSCR5", "LOCAPV", function () {
    return [vm.$("WPTR"), vm.$("XPTR"), vm.$("YPTR"), null, vm.$("ASSCR4")];
  }, "E3.2.3"], [null, "LOCAPV", function () {
    return [vm.$("WPTR"), vm.$("XPTR"), vm.$("ZEROCL"), vm.$("ASSCR2")];
  }, ""], ["ASSCR4", "MOVA", function () {
    return [vm.$("XPTR"), vm.$("WPTR")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("XPTR"), 2 * vm.$("DESCR"), vm.$("YPTR")];
  }, "E3.2.3"], [null, "BRANCH", function () {
    return [vm.$("ARYA10")];
  }, "Join array reference exit"], ["ASSCR2", "GETSIZ", function () {
    return [vm.$("TCL"), vm.$("XPTR")];
  }, "E3.2.3"], [null, "GETD", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("TCL")];
  }, "E3.2.3"], [null, "AEQLC", function () {
    return [vm.$("ZPTR"), 1, null, vm.$("ASSCR3")];
  }, "E3.2.3"], [null, "MOVD", function () {
    return [vm.$("XPTR"), vm.$("ZPTR")];
  }, "E3.2.3"], [null, "BRANCH", function () {
    return [vm.$("ASSCR5")];
  }, "E3.2.3"], ["ASSCR3", "DECRA", function () {
    return [vm.$("TCL"), vm.$("DESCR")];
  }, "E3.2.3"], [null, "GETD", function () {
    return [vm.$("WPTR"), vm.$("XPTR"), vm.$("TCL")];
  }, "E3.2.3"], [null, "PUSH", function () {
    return [[vm.$("XPTR"), vm.$("TCL"), vm.$("YPTR")]];
  }, "E3.2.3"], [null, "MOVD", function () {
    return [vm.$("XPTR"), vm.$("WPTR")];
  }, "E3.2.3"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("ASSOCE"), null, [vm.$("INTR10"), vm.$("INTR10")]];
  }, "E3.2.3"], [null, "POP", function () {
    return [[vm.$("YPTR"), vm.$("TCL"), vm.$("XPTR")]];
  }, "E3.2.3"], [null, "SETVC", function () {
    return [vm.$("ZPTR"), vm.$("B")];
  }, "E3.2.3"], [null, "INCRA", function () {
    return [vm.$("TCL"), vm.$("DESCR")];
  }, "E3.2.3"], [null, "PUTD", function () {
    return [vm.$("XPTR"), vm.$("TCL"), vm.$("ZPTR")];
  }, "E3.2.3"], [null, "PUTDC", function () {
    return [vm.$("ZPTR"), 2 * vm.$("DESCR"), vm.$("YPTR")];
  }, "E3.2.3"], [null, "MOVD", function () {
    return [vm.$("XPTR"), vm.$("ZPTR")];
  }, "E3.2.3"], [null, "BRANCH", function () {
    return [vm.$("ARYA10")];
  }, "E3.2.3"], ["DEFDAT", "PROC", function () {
    return [null];
  }, "Procedure to create defined objects"], [null, "SETAV", function () {
    return [vm.$("XCL"), vm.$("INCL")];
  }, "Get given number of arguments"], [null, "MOVD", function () {
    return [vm.$("WCL"), vm.$("XCL")];
  }, "Save a copy"], [null, "MOVD", function () {
    return [vm.$("YCL"), vm.$("INCL")];
  }, "Save function descriptor"], [null, "PSTACK", function () {
    return [vm.$("YPTR")];
  }, "Post stack position"], ["DEFD1", "INCRA", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("XPTR"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get object code descriptor"], [null, "TESTF", function () {
    return [vm.$("XPTR"), vm.$("FNC"), null, vm.$("DEFDC")];
  }, "Check for function"], ["DEFD2", "AEQLC", function () {
    return [vm.$("INSW"), 0, null, vm.$("DEFD8")];
  }, "Check &INPUT"], [null, "LOCAPV", function () {
    return [vm.$("ZPTR"), vm.$("INATL"), vm.$("XPTR"), vm.$("DEFD8")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("ZPTR"), vm.$("DESCR")];
  }, "Get association"], [null, "PUSH", function () {
    return [[vm.$("XCL"), vm.$("WCL"), vm.$("YCL"), vm.$("YPTR")]];
  }, "Save relevant descriptors"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("PUTIN"), [vm.$("ZPTR"), vm.$("XPTR")], vm.$("FAIL")];
  }, ""], [null, "POP", function () {
    return [[vm.$("YPTR"), vm.$("YCL"), vm.$("WCL"), vm.$("XCL")]];
  }, "Restore relevant descriptors"], [null, "BRANCH", function () {
    return [vm.$("DEFD3")];
  }, "Join main processing"], ["DEFD8", "GETDC", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), vm.$("DESCR")];
  }, "Get value"], ["DEFD3", "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save value"], [null, "DECRA", function () {
    return [vm.$("XCL"), 1];
  }, "Decrement argument count"], [null, "ACOMPC", function () {
    return [vm.$("XCL"), 0, vm.$("DEFD1"), null, vm.$("INTR10")];
  }, "Check for end"], [null, "GETDC", function () {
    return [vm.$("XCL"), vm.$("YCL"), 0];
  }, "Get procedure descriptor"], [null, "SETAV", function () {
    return [vm.$("XCL"), vm.$("XCL")];
  }, "Get number of arguments expected"], ["DEFD4", "ACOMP", function () {
    return [vm.$("WCL"), vm.$("XCL"), vm.$("DEFD5"), vm.$("DEFD5")];
  }, "Compare given with expected"], [null, "PUSH", function () {
    return [vm.$("NULVCL")];
  }, "Save null for omitted argument"], [null, "INCRA", function () {
    return [vm.$("WCL"), 1];
  }, "Increment count"], [null, "BRANCH", function () {
    return [vm.$("DEFD4")];
  }, "Continue"], ["DEFD5", "GETDC", function () {
    return [vm.$("WCL"), vm.$("YCL"), vm.$("DESCR")];
  }, "Get definition block"], [null, "MULTC", function () {
    return [vm.$("XCL"), vm.$("XCL"), vm.$("DESCR")];
  }, ""], [null, "MOVV", function () {
    return [vm.$("XCL"), vm.$("WCL")];
  }, "Insert data type code"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("BLOCK"), vm.$("XCL")];
  }, "Allocate block for data object"], [null, "INCRA", function () {
    return [vm.$("YPTR"), vm.$("DESCR")];
  }, "Adjust stack position"], [null, "MOVBLK", function () {
    return [vm.$("ZPTR"), vm.$("YPTR"), vm.$("XCL")];
  }, "Move values into block"], [null, "BRANCH", function () {
    return [vm.$("RTZPTR")];
  }, "Return new object"], ["DEFDC", "PUSH", function () {
    return [[vm.$("XCL"), vm.$("WCL"), vm.$("YCL"), vm.$("YPTR")]];
  }, "Save relevant descriptors"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("INVOKE"), [vm.$("XPTR")], [vm.$("FAIL"), vm.$("DEFDN")]];
  }, ""], [null, "POP", function () {
    return [[vm.$("YPTR"), vm.$("YCL"), vm.$("WCL"), vm.$("XCL")]];
  }, "Restore relevant descriptors"], [null, "BRANCH", function () {
    return [vm.$("DEFD3")];
  }, "Join main processing"], ["DEFDN", "POP", function () {
    return [[vm.$("YPTR"), vm.$("YCL"), vm.$("WCL"), vm.$("XCL")]];
  }, "Restore relevant descriptors"], [null, "BRANCH", function () {
    return [vm.$("DEFD2")];
  }, "Join main processing"], ["FIELD", "PROC", function () {
    return [null];
  }, "Field function procedure"], [null, "PUSH", function () {
    return [vm.$("INCL")];
  }, "Save function descriptor"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("ARGVAL"), null, vm.$("FAIL")];
  }, "Get value"], [null, "DEQL", function () {
    return [vm.$("XPTR"), vm.$("NULVCL"), null, vm.$("NONAME")];
  }, "Check for null value"], [null, "POP", function () {
    return [vm.$("YCL")];
  }, "Restore function descriptor"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("I"), vm.$("FIELD1")];
  }, "Check for INTEGER"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GNVARI"), vm.$("XPTR")];
  }, "Convert INTEGER to STRING"], ["FIELD1", "MOVV", function () {
    return [vm.$("DT1CL"), vm.$("XPTR")];
  }, "Set up data type"], [null, "GETDC", function () {
    return [vm.$("YPTR"), vm.$("YCL"), vm.$("DESCR")];
  }, "Get definition block"], [null, "LOCAPT", function () {
    return [vm.$("ZCL"), vm.$("YPTR"), vm.$("DT1CL"), vm.$("INTR1")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("ZCL"), vm.$("ZCL"), 2 * vm.$("DESCR")];
  }, "Get offset"], [null, "SUM", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), vm.$("ZCL")];
  }, "Compute field position"], [null, "SETVC", function () {
    return [vm.$("XPTR"), vm.$("N")];
  }, "Insert NAME data type"], [null, "BRANCH", function () {
    return [vm.$("RTXNAM")];
  }, "Return name"], [null, "TITLE", function () {
    return ["Input and Output"];
  }, ""], ["READ", "PROC", function () {
    return [null];
  }, "INPUT(V,U,L)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("IND"), null, vm.$("FAIL")];
  }, "Get variable"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save variable"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("INTVAL"), null, vm.$("FAIL")];
  }, "Get unit"], [null, "PUSH", function () {
    return [vm.$("YPTR")];
  }, "Save unit"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("INTVAL"), null, vm.$("FAIL")];
  }, "Get length"], [null, "POP", function () {
    return [[vm.$("YPTR"), vm.$("XPTR")]];
  }, "Restore unit and variable"], [null, "ACOMPC", function () {
    return [vm.$("YPTR"), 0, null, vm.$("READ5"), vm.$("UNTERR")];
  }, ""], ["READ6", "ACOMPC", function () {
    return [vm.$("ZPTR"), 0, vm.$("READ2"), null, vm.$("LENERR")];
  }, ""], [null, "LOCAPT", function () {
    return [vm.$("TPTR"), vm.$("INSATL"), vm.$("YPTR"), vm.$("READ4")];
  }, ""], ["READ3", "LOCAPV", function () {
    return [vm.$("ZPTR"), vm.$("INATL"), vm.$("XPTR"), vm.$("READ1")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("ZPTR"), vm.$("DESCR"), vm.$("TPTR")];
  }, "Inset input block"], [null, "BRANCH", function () {
    return [vm.$("RETNUL")];
  }, "Return"], ["READ1", "RCALL", function () {
    return [vm.$("INATL"), vm.$("AUGATL"), [vm.$("INATL"), vm.$("TPTR"), vm.$("XPTR")], vm.$("RETNUL")];
  }, ""], ["READ4", "MOVD", function () {
    return [vm.$("ZPTR"), vm.$("DFLSIZ")];
  }, "Set standard default"], ["READ2", "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("IOBLSZ")];
  }, "Allocate block"], [null, "PUTDC", function () {
    return [vm.$("TPTR"), vm.$("DESCR"), vm.$("YPTR")];
  }, "Insert unit"], [null, "PUTDC", function () {
    return [vm.$("TPTR"), 2 * vm.$("DESCR"), vm.$("ZPTR")];
  }, "Insert format"], [null, "BRANCH", function () {
    return [vm.$("READ3")];
  }, "Rejoin processing"], ["READ5", "SETAC", function () {
    return [vm.$("YPTR"), vm.$("UNITI")];
  }, "Set up default unit"], [null, "BRANCH", function () {
    return [vm.$("READ6")];
  }, "Join processing"], ["PRINT", "PROC", function () {
    return [null];
  }, "OUTPUT(V,U,F)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("IND"), null, vm.$("FAIL")];
  }, "Get variable"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save variable"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("INTVAL"), null, vm.$("FAIL")];
  }, "Get unit"], [null, "PUSH", function () {
    return [vm.$("YPTR")];
  }, "Save unit"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get format"], [null, "POP", function () {
    return [[vm.$("YPTR"), vm.$("XPTR")]];
  }, "Restore unit and variable"], [null, "ACOMPC", function () {
    return [vm.$("YPTR"), 0, null, vm.$("PRINT5"), vm.$("UNTERR")];
  }, ""], ["PRINT6", "AEQLC", function () {
    return [vm.$("ZPTR"), 0, vm.$("PRINT2")];
  }, "Check for defaulted format"], [null, "LOCAPT", function () {
    return [vm.$("TPTR"), vm.$("OTSATL"), vm.$("YPTR"), vm.$("PRINT4")];
  }, ""], ["PRINT3", "LOCAPV", function () {
    return [vm.$("ZPTR"), vm.$("OUTATL"), vm.$("XPTR"), vm.$("PRINT1")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("ZPTR"), vm.$("DESCR"), vm.$("TPTR")];
  }, "Insert output block"], [null, "BRANCH", function () {
    return [vm.$("RETNUL")];
  }, "Return"], ["PRINT1", "RCALL", function () {
    return [vm.$("OUTATL"), vm.$("AUGATL"), [vm.$("OUTATL"), vm.$("TPTR"), vm.$("XPTR")], vm.$("RETNUL")];
  }, ""], ["PRINT4", "MOVD", function () {
    return [vm.$("ZPTR"), vm.$("DFLFST")];
  }, "Set up standard default"], ["PRINT2", "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("IOBLSZ")];
  }, "Allocate block"], [null, "PUTDC", function () {
    return [vm.$("TPTR"), vm.$("DESCR"), vm.$("YPTR")];
  }, "Insert unit"], [null, "PUTDC", function () {
    return [vm.$("TPTR"), 2 * vm.$("DESCR"), vm.$("ZPTR")];
  }, "Insert format"], [null, "BRANCH", function () {
    return [vm.$("PRINT3")];
  }, "Rejoin processing"], ["PRINT5", "SETAC", function () {
    return [vm.$("YPTR"), vm.$("UNITO")];
  }, "Set default unit"], [null, "BRANCH", function () {
    return [vm.$("PRINT6")];
  }, "Join processing"], ["BKSPCE", "PROC", function () {
    return [null];
  }, "BACKSPACE(N)"], [null, "SETAC", function () {
    return [vm.$("SCL"), 1];
  }, "Indicate backspace"], [null, "BRANCH", function () {
    return [vm.$("IOOP")];
  }, ""], ["ENFILE", "PROC", function () {
    return [vm.$("BKSPCE")];
  }, "ENDFILE(N)"], [null, "SETAC", function () {
    return [vm.$("SCL"), 2];
  }, "Indicate end of file"], [null, "BRANCH", function () {
    return [vm.$("IOOP")];
  }, ""], ["REWIND", "PROC", function () {
    return [vm.$("BKSPCE")];
  }, "REWIND(N)"], [null, "SETAC", function () {
    return [vm.$("SCL"), 3];
  }, "Indicate rewind"], ["IOOP", "PUSH", function () {
    return [vm.$("SCL")];
  }, "Push indicator"], [null, "RCALL", function () {
    return [vm.$("XCL"), vm.$("INTVAL"), null, vm.$("FAIL")];
  }, "Evaluate integer argument"], [null, "ACOMPC", function () {
    return [vm.$("XCL"), 0, null, vm.$("UNTERR"), vm.$("UNTERR")];
  }, ""], [null, "POP", function () {
    return [vm.$("SCL")];
  }, "Restore indicator"], [null, "SELBRA", function () {
    return [vm.$("SCL"), [null, vm.$("EOP"), vm.$("ROP")]];
  }, "Select operation"], [null, "BKSPCE", function () {
    return [vm.$("XCL")];
  }, "Backspace unit"], [null, "BRANCH", function () {
    return [vm.$("RETNUL")];
  }, ""], ["EOP", "ENFILE", function () {
    return [vm.$("XCL")];
  }, "End file unit"], [null, "BRANCH", function () {
    return [vm.$("RETNUL")];
  }, ""], ["ROP", "REWIND", function () {
    return [vm.$("XCL")];
  }, "Rewind unit"], [null, "BRANCH", function () {
    return [vm.$("RETNUL")];
  }, ""], ["DETACH", "PROC", function () {
    return [null];
  }, "DETACH(N)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("IND"), null, vm.$("FAIL")];
  }, "Get name of variable"], [null, "LOCAPV", function () {
    return [vm.$("ZPTR"), vm.$("INATL"), vm.$("XPTR"), vm.$("DTCH1")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("ZPTR"), vm.$("DESCR"), vm.$("ZEROCL")];
  }, "Delete association if there is one"], [null, "PUTDC", function () {
    return [vm.$("ZPTR"), 2 * vm.$("DESCR"), vm.$("ZEROCL")];
  }, "Clear association pointer also"], ["DTCH1", "LOCAPV", function () {
    return [vm.$("ZPTR"), vm.$("OUTATL"), vm.$("XPTR"), vm.$("RETNUL")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("ZPTR"), vm.$("DESCR"), vm.$("ZEROCL")];
  }, "Delete association is there is one"], [null, "PUTDC", function () {
    return [vm.$("ZPTR"), 2 * vm.$("DESCR"), vm.$("ZEROCL")];
  }, "Clear association pointer also"], [null, "BRANCH", function () {
    return [vm.$("RETNUL")];
  }, "Return null value"], ["PUTIN", "PROC", function () {
    return [null];
  }, "Input procedure"], [null, "POP", function () {
    return [[vm.$("IO1PTR"), vm.$("IO2PTR")]];
  }, "Restore block and variable"], [null, "GETDC", function () {
    return [vm.$("IO3PTR"), vm.$("IO1PTR"), vm.$("DESCR")];
  }, "Get unit"], [null, "GETDC", function () {
    return [vm.$("IO1PTR"), vm.$("IO1PTR"), 2 * vm.$("DESCR")];
  }, ""], [null, "RCALL", function () {
    return [vm.$("IO4PTR"), vm.$("CONVAR"), [vm.$("IO1PTR")]];
  }, ""], [null, "LOCSP", function () {
    return [vm.$("IOSP"), vm.$("IO4PTR")];
  }, "Get specifier"], [null, "INCRA", function () {
    return [vm.$("RSTAT"), 1];
  }, "Increment count of reads"], [null, "STREAD", function () {
    return [vm.$("IOSP"), vm.$("IO3PTR"), vm.$("FAIL"), vm.$("COMP5")];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("TRIMCL"), 0, null, vm.$("PUTIN1")];
  }, "Check &INPUT"], [null, "TRIMSP", function () {
    return [vm.$("IOSP"), vm.$("IOSP")];
  }, "Trim string"], [null, "GETLG", function () {
    return [vm.$("IO1PTR"), vm.$("IOSP")];
  }, "Get length"], ["PUTIN1", "ACOMP", function () {
    return [vm.$("IO1PTR"), vm.$("MLENCL"), vm.$("INTR8")];
  }, "E3.9.2"], [null, "VEQLC", function () {
    return [vm.$("IO2PTR"), vm.$("K"), null, vm.$("PUTIN3")];
  }, "CHECK FOR KEYWORD\t\tE3.10.2"], [null, "RCALL", function () {
    return [vm.$("IO1PTR"), vm.$("GNVARS"), vm.$("IO1PTR")];
  }, "E3.9.2"], ["PUTIN2", "PUTDC", function () {
    return [vm.$("IO2PTR"), vm.$("DESCR"), vm.$("IO1PTR")];
  }, "E3.10.2"], [null, "RRTURN", function () {
    return [vm.$("IO1PTR"), 2];
  }, "Return value"], ["PUTIN3", "LOCSP", function () {
    return [vm.$("XSP"), vm.$("IO1PTR")];
  }, "E3.10.2"], [null, "SPCINT", function () {
    return [vm.$("IO1PTR"), vm.$("XSP"), vm.$("INTR1"), vm.$("PUTIN2")];
  }, "E3.10.2"], ["PUTOUT", "PROC", function () {
    return [null];
  }, "Output procedure"], [null, "POP", function () {
    return [[vm.$("IO1PTR"), vm.$("IO2PTR")]];
  }, "Restore block and value"], [null, "VEQLC", function () {
    return [vm.$("IO2PTR"), vm.$("S"), null, vm.$("PUTV")];
  }, "Is value STRING?"], [null, "VEQLC", function () {
    return [vm.$("IO2PTR"), vm.$("I"), null, vm.$("PUTI")];
  }, "Is value INTEGER?"], [null, "RCALL", function () {
    return [vm.$("IO2PTR"), vm.$("DTREP"), vm.$("IO2PTR")];
  }, "Get data type representation"], [null, "GETSPC", function () {
    return [vm.$("IOSP"), vm.$("IO2PTR"), 0];
  }, "Get specifier"], [null, "BRANCH", function () {
    return [vm.$("PUTVU")];
  }, "Join processing"], ["PUTV", "LOCSP", function () {
    return [vm.$("IOSP"), vm.$("IO2PTR")];
  }, "Get specifier"], ["PUTVU", "STPRNT", function () {
    return [vm.$("IOKEY"), vm.$("IO1PTR"), vm.$("IOSP")];
  }, "Perform print"], [null, "INCRA", function () {
    return [vm.$("WSTAT"), 1];
  }, "Increment count of writes"], [null, "BRANCH", function () {
    return [vm.$("RTN1")];
  }, "Return"], ["PUTI", "INTSPC", function () {
    return [vm.$("IOSP"), vm.$("IO2PTR")];
  }, "Convert INTEGER to STRING"], [null, "BRANCH", function () {
    return [vm.$("PUTVU")];
  }, "Rejoin processing"], [null, "TITLE", function () {
    return ["Tracing Procedures and Functions"];
  }, ""], ["TRACE", "PROC", function () {
    return [null];
  }, "TRACE(V,R,T,F)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("IND"), null, vm.$("FAIL")];
  }, "Get name of variable"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save name"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get trace type"], [null, "PUSH", function () {
    return [vm.$("YPTR")];
  }, "Save type"], [null, "RCALL", function () {
    return [vm.$("WPTR"), vm.$("ARGVAL"), null, vm.$("FAIL")];
  }, "Get tag"], [null, "PUSH", function () {
    return [vm.$("WPTR")];
  }, "Save tag"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get trace function"], [null, "POP", function () {
    return [[vm.$("WPTR"), vm.$("YPTR"), vm.$("XPTR")]];
  }, "Restore saved arguments"], [null, "DEQL", function () {
    return [vm.$("YPTR"), vm.$("NULVCL"), vm.$("TRAC5")];
  }, "Is type defaulted??"], [null, "MOVD", function () {
    return [vm.$("YPTR"), vm.$("VALTRS")];
  }, "Set up VALUE default"], ["TRAC5", "LOCAPV", function () {
    return [vm.$("YPTR"), vm.$("TRATL"), vm.$("YPTR"), vm.$("TRAC1")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("YPTR"), vm.$("YPTR"), vm.$("DESCR")];
  }, "Get sub pair list"], ["TRACEP", "PROC", function () {
    return [vm.$("TRACE")];
  }, "Subentry for TRACE"], [null, "GETDC", function () {
    return [vm.$("TPTR"), vm.$("YPTR"), vm.$("DESCR")];
  }, "Get default function"], [null, "DEQL", function () {
    return [vm.$("ZPTR"), vm.$("NULVCL"), null, vm.$("TRAC2")];
  }, "Check for null"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("FINDEX"), [vm.$("ZPTR")]];
  }, "Locate function descriptor"], ["TRAC2", "SETAC", function () {
    return [vm.$("XSIZ"), 5 * vm.$("DESCR")];
  }, "V3.7"], [null, "SETVC", function () {
    return [vm.$("XSIZ"), vm.$("C")];
  }, "Insert CODE data type"], [null, "RCALL", function () {
    return [vm.$("XCL"), vm.$("BLOCK"), vm.$("XSIZ")];
  }, "Allocate block for code"], [null, "MOVBLK", function () {
    return [vm.$("XCL"), vm.$("TRCBLK"), vm.$("XSIZ")];
  }, "V3.7"], [null, "SETVC", function () {
    return [vm.$("TPTR"), 2];
  }, "Set up 2 arguments"], [null, "PUTDC", function () {
    return [vm.$("XCL"), 1 * vm.$("DESCR"), vm.$("TPTR")];
  }, "Insert function descriptor"], [null, "PUTDC", function () {
    return [vm.$("XCL"), 3 * vm.$("DESCR"), vm.$("XPTR")];
  }, "Insert name to be traced"], [null, "PUTDC", function () {
    return [vm.$("XCL"), 5 * vm.$("DESCR"), vm.$("WPTR")];
  }, "Insert tag"], [null, "GETDC", function () {
    return [vm.$("TPTR"), vm.$("YPTR"), 0];
  }, "Make entry for proper attribute"], [null, "AEQLC", function () {
    return [vm.$("TPTR"), 0, null, vm.$("TRAC4")];
  }, ""], [null, "LOCAPT", function () {
    return [vm.$("TPTR"), vm.$("TPTR"), vm.$("XPTR"), vm.$("TRAC3")];
  }, ""], [null, "PUTDC", function () {
    return [vm.$("TPTR"), 2 * vm.$("DESCR"), vm.$("XCL")];
  }, "Insert new code block"], [null, "BRANCH", function () {
    return [vm.$("RETNUL")];
  }, "Return"], ["TRAC3", "RCALL", function () {
    return [vm.$("TPTR"), vm.$("AUGATL"), [vm.$("TPTR"), vm.$("XPTR"), vm.$("XCL")]];
  }, ""], ["TRAC6", "PUTDC", function () {
    return [vm.$("YPTR"), 0, vm.$("TPTR")];
  }, "Link in new pair list"], [null, "BRANCH", function () {
    return [vm.$("RETNUL")];
  }, "Return"], ["TRAC1", "DEQL", function () {
    return [vm.$("YPTR"), vm.$("FUNTCL"), vm.$("INTR30")];
  }, "Is type FUNCTION?"], [null, "MOVD", function () {
    return [vm.$("YPTR"), vm.$("TFNCLP")];
  }, "Set up CALL trace"], [null, "RCALL", function () {
    return [null, vm.$("TRACEP"), null, [vm.$("INTR10"), vm.$("INTR10")]];
  }, ""], [null, "MOVD", function () {
    return [vm.$("YPTR"), vm.$("TFNRLP")];
  }, "Set up RETURN trace"], [null, "BRANCH", function () {
    return [vm.$("TRACEP")];
  }, "Branch to subentry to do it"], ["TRAC4", "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("TWOCL")];
  }, "Allocate new pair list"], [null, "PUTDC", function () {
    return [vm.$("TPTR"), vm.$("DESCR"), vm.$("XPTR")];
  }, "Insert name to be traced"], [null, "PUTDC", function () {
    return [vm.$("TPTR"), 2 * vm.$("DESCR"), vm.$("XCL")];
  }, "Insert pointer to pseudo-code"], [null, "BRANCH", function () {
    return [vm.$("TRAC6")];
  }, ""], ["STOPTR", "PROC", function () {
    return [null];
  }, "STOPTR(T,R)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("IND"), null, vm.$("FAIL")];
  }, "Get name of variable"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save name"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get trace respect"], [null, "POP", function () {
    return [vm.$("XPTR")];
  }, ""], [null, "DEQL", function () {
    return [vm.$("YPTR"), vm.$("NULVCL"), vm.$("STOPT2")];
  }, "Check for defaulted respect"], [null, "MOVD", function () {
    return [vm.$("YPTR"), vm.$("VALTRS")];
  }, "Set up VALUE as default"], ["STOPT2", "LOCAPV", function () {
    return [vm.$("YPTR"), vm.$("TRATL"), vm.$("YPTR"), vm.$("STOPT1")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("YPTR"), vm.$("YPTR"), vm.$("DESCR")];
  }, "Get pointer to trace list"], ["STOPTP", "PROC", function () {
    return [vm.$("STOPTR")];
  }, "Subentry for FUNCTION"], [null, "GETDC", function () {
    return [vm.$("YPTR"), vm.$("YPTR"), 0];
  }, "Get trace list"], [null, "LOCAPT", function () {
    return [vm.$("YPTR"), vm.$("YPTR"), vm.$("XPTR"), vm.$("FAIL")];
  }, "Look for traced variable"], [null, "PUTDC", function () {
    return [vm.$("YPTR"), vm.$("DESCR"), vm.$("ZEROCL")];
  }, "Zero the entry"], [null, "PUTDC", function () {
    return [vm.$("YPTR"), 2 * vm.$("DESCR"), vm.$("ZEROCL")];
  }, "Overwrite trace"], [null, "BRANCH", function () {
    return [vm.$("RETNUL")];
  }, "Return"], ["STOPT1", "DEQL", function () {
    return [vm.$("YPTR"), vm.$("FUNTCL"), vm.$("INTR30")];
  }, "Check for FUNCTION"], [null, "MOVD", function () {
    return [vm.$("YPTR"), vm.$("TFNCLP")];
  }, "Set up CALL"], [null, "RCALL", function () {
    return [null, vm.$("STOPTP"), null, [vm.$("FAIL"), vm.$("INTR10")]];
  }, ""], [null, "MOVD", function () {
    return [vm.$("YPTR"), vm.$("TFNRLP")];
  }, "Set up RETURN"], [null, "BRANCH", function () {
    return [vm.$("STOPTP")];
  }, "Branch to subentry"], ["FENTR", "PROC", function () {
    return [null];
  }, "Procedure to trace on CALL"], [null, "RCALL", function () {
    return [vm.$("WPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get argument"], ["FENTR3", "SETLC", function () {
    return [vm.$("PROTSP"), 0];
  }, "Clear specifier"], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("TRSTSP")];
  }, "Append trace message"], [null, "INTSPC", function () {
    return [vm.$("XSP"), vm.$("STNOCL")];
  }, "Convert &STNO to string"], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("XSP")];
  }, "Append &STNO"], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("COLSP")];
  }, "Append colon"], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("TRLVSP")];
  }, "Append level message"], [null, "INTSPC", function () {
    return [vm.$("XSP"), vm.$("LVLCL")];
  }, "Convert &FNCLEVEL to string"], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("XSP")];
  }, "Append &FNCLEVEL"], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("TRCLSP")];
  }, "Append call message"], [null, "LOCSP", function () {
    return [vm.$("XSP"), vm.$("WPTR")];
  }, "Get specifier for argument"], [null, "GETLG", function () {
    return [vm.$("TCL"), vm.$("XSP")];
  }, "Get length"], [null, "ACOMPC", function () {
    return [vm.$("TCL"), vm.$("BUFLEN"), vm.$("FXOVR"), vm.$("FXOVR")];
  }, ""], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("XSP")];
  }, "Append function name"], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("LPRNSP")];
  }, "Append left parenthesis"], [null, "SETAC", function () {
    return [vm.$("WCL"), 0];
  }, "Set argument count to 0"], ["FNTRLP", "INCRA", function () {
    return [vm.$("WCL"), 1];
  }, "Increment argument count"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("ARGINT"), [vm.$("WPTR"), vm.$("WCL")], [vm.$("FENTR4"), vm.$("INTR10")]];
  }, ""], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("ZPTR"), vm.$("DESCR")];
  }, "Get value"], [null, "VEQLC", function () {
    return [vm.$("ZPTR"), vm.$("S"), null, vm.$("DEFTV")];
  }, "Is it STRING?"], [null, "VEQLC", function () {
    return [vm.$("ZPTR"), vm.$("I"), null, vm.$("DEFTI")];
  }, "Is it INTEGER?"], [null, "RCALL", function () {
    return [vm.$("A2PTR"), vm.$("DTREP"), vm.$("ZPTR")];
  }, "Get data type representation"], [null, "GETSPC", function () {
    return [vm.$("XSP"), vm.$("A2PTR"), 0];
  }, "Get specifier"], [null, "GETLG", function () {
    return [vm.$("SCL"), vm.$("XSP")];
  }, "Get length"], [null, "SUM", function () {
    return [vm.$("TCL"), vm.$("TCL"), vm.$("SCL")];
  }, "Total length"], [null, "ACOMPC", function () {
    return [vm.$("TCL"), vm.$("BUFLEN"), vm.$("FXOVR"), vm.$("FXOVR")];
  }, ""], ["DEFTIA", "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("XSP")];
  }, "Append value"], [null, "BRANCH", function () {
    return [vm.$("DEFDTT")];
  }, "Continue with next argument"], ["DEFTI", "INTSPC", function () {
    return [vm.$("XSP"), vm.$("ZPTR")];
  }, "Convert INTEGER to STRING"], [null, "BRANCH", function () {
    return [vm.$("DEFTIA")];
  }, "Rejoin processing"], ["DEFTV", "LOCSP", function () {
    return [vm.$("XSP"), vm.$("ZPTR")];
  }, "Get specifier"], [null, "GETLG", function () {
    return [vm.$("SCL"), vm.$("XSP")];
  }, "Get length"], [null, "SUM", function () {
    return [vm.$("TCL"), vm.$("TCL"), vm.$("SCL")];
  }, "Get total length"], [null, "ACOMPC", function () {
    return [vm.$("TCL"), vm.$("BUFLEN"), vm.$("FXOVR"), vm.$("FXOVR")];
  }, ""], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("QTSP")];
  }, "Append quote"], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("XSP")];
  }, "Append value"], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("QTSP")];
  }, "Append quote"], ["DEFDTT", "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("CMASP")];
  }, "Append comma"], [null, "BRANCH", function () {
    return [vm.$("FNTRLP")];
  }, "Continue processing"], ["FENTR4", "AEQLC", function () {
    return [vm.$("WCL"), 1, null, vm.$("FENTR5")];
  }, "Leave paren if no arguments"], [null, "SHORTN", function () {
    return [vm.$("PROTSP"), 1];
  }, "Delete last comma"], ["FENTR5", "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("RPRNSP")];
  }, "Append right parenthesis"], [null, "MSTIME", function () {
    return [vm.$("ZPTR")];
  }, "Get time"], [null, "SUBTRT", function () {
    return [vm.$("ZPTR"), vm.$("ZPTR"), vm.$("ETMCL")];
  }, "Compute elapsed time"], [null, "INTSPC", function () {
    return [vm.$("XSP"), vm.$("ZPTR")];
  }, "Convert to STRING"], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("ETIMSP")];
  }, "Append time message"], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("XSP")];
  }, "Append time"], [null, "STPRNT", function () {
    return [vm.$("IOKEY"), vm.$("OUTBLK"), vm.$("PROTSP")];
  }, "Print trace message"], [null, "BRANCH", function () {
    return [vm.$("RTNUL3")];
  }, "Return"], ["FENTR2", "PROC", function () {
    return [vm.$("FENTR")];
  }, "Standard entry"], [null, "POP", function () {
    return [vm.$("WPTR")];
  }, "Restore function name"], [null, "BRANCH", function () {
    return [vm.$("FENTR3")];
  }, ""], ["FXOVR", "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("PRTOVF")];
  }, "Print error message"], [null, "BRANCH", function () {
    return [vm.$("RTNUL3")];
  }, "Return"], ["KEYTR", "PROC", function () {
    return [null];
  }, "Procedure to trace keywords"], [null, "SETAC", function () {
    return [vm.$("FNVLCL"), 1];
  }, "Set entry indicator"], [null, "RCALL", function () {
    return [vm.$("WPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get keyword"], [null, "LOCSP", function () {
    return [vm.$("XSP"), vm.$("WPTR")];
  }, "Get specifier"], [null, "RCALL", function () {
    return [vm.$("YCL"), vm.$("KEYT"), [vm.$("WPTR")]];
  }, "(INTR10,)"], ["KEYTR3", "SETLC", function () {
    return [vm.$("PROTSP"), 0];
  }, "Clear specifier"], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("TRSTSP")];
  }, "Append trace message"], [null, "INTSPC", function () {
    return [vm.$("TSP"), vm.$("STNOCL")];
  }, "Convert &STNO to string"], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("TSP")];
  }, "Append &STNO"], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("COLSP")];
  }, "Append colon"], [null, "AEQLC", function () {
    return [vm.$("FNVLCL"), 0, null, vm.$("KEYTR4")];
  }, "Check entry indicator"], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("AMPSP")];
  }, "Append ampersand"], ["KEYTR4", "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("XSP")];
  }, "Append name of keyword"], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("BLSP")];
  }, "Append blank"], [null, "AEQLC", function () {
    return [vm.$("FNVLCL"), 0, null, vm.$("KEYTR5")];
  }, "Check entry indicator"], [null, "INTSPC", function () {
    return [vm.$("YSP"), vm.$("YCL")];
  }, "Convert keyword value to string"], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("EQLSP")];
  }, "Append equal sign"], ["KEYTR5", "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("YSP")];
  }, "Append value"], [null, "MSTIME", function () {
    return [vm.$("YPTR")];
  }, "Get time"], [null, "SUBTRT", function () {
    return [vm.$("YPTR"), vm.$("YPTR"), vm.$("ETMCL")];
  }, "Compute elapsed time"], [null, "INTSPC", function () {
    return [vm.$("XSP"), vm.$("YPTR")];
  }, "Convert time to string"], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("ETIMSP")];
  }, "Append time message"], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("XSP")];
  }, "Append time"], [null, "STPRNT", function () {
    return [vm.$("IOKEY"), vm.$("OUTBLK"), vm.$("PROTSP")];
  }, "Print trace message"], [null, "BRANCH", function () {
    return [vm.$("RTN2")];
  }, "Return"], ["LABTR", "PROC", function () {
    return [vm.$("KEYTR")];
  }, "Procedure to trace labels"], [null, "SETAC", function () {
    return [vm.$("FNVLCL"), 0];
  }, "Set entry indicator"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get label name"], [null, "LOCSP", function () {
    return [vm.$("YSP"), vm.$("YPTR")];
  }, "Get specifier"], [null, "SETSP", function () {
    return [vm.$("XSP"), vm.$("XFERSP")];
  }, "Set up message specifier"], [null, "BRANCH", function () {
    return [vm.$("KEYTR3")];
  }, "Join common processing"], ["TRPHND", "PROC", function () {
    return [null];
  }, "Trace handling procedure"], [null, "POP", function () {
    return [vm.$("ATPTR")];
  }, "Restore trace"], [null, "DECRA", function () {
    return [vm.$("TRAPCL"), 1];
  }, "Decrement &TRACE"], [null, "PUSH", function () {
    return [[vm.$("LSTNCL"), vm.$("STNOCL"), vm.$("FRTNCL"), vm.$("OCBSCL"), vm.$("OCICL"), vm.$("TRAPCL"), vm.$("TRACL")]];
  }, ""], [null, "GETDC", function () {
    return [vm.$("OCBSCL"), vm.$("ATPTR"), 2 * vm.$("DESCR")];
  }, "NEW CODE BASE"], [null, "SETAC", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Set up offset"], [null, "GETD", function () {
    return [vm.$("XPTR"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get function descriptor"], [null, "SETAC", function () {
    return [vm.$("TRAPCL"), 0];
  }, "Set &TRACE to 0"], [null, "SETAC", function () {
    return [vm.$("TRACL"), 0];
  }, "Set &FTRACE to 0"], [null, "RCALL", function () {
    return [null, vm.$("INVOKE"), vm.$("XPTR")];
  }, "(,) \t\t\t\tE3.3.1"], [null, "POP", function () {
    return [[vm.$("TRACL"), vm.$("TRAPCL"), vm.$("OCICL"), vm.$("OCBSCL"), vm.$("FRTNCL"), vm.$("STNOCL"), vm.$("LSTNCL")]];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("RTN1")];
  }, "E3.3.1"], ["VALTR", "PROC", function () {
    return [null];
  }, "Tracing procedures"], [null, "SETAC", function () {
    return [vm.$("FNVLCL"), 1];
  }, "Note entry"], ["VALTR2", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("IND"), null, vm.$("FAIL")];
  }, "Get variable to be traced"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save name"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get tag"], [null, "POP", function () {
    return [vm.$("XPTR")];
  }, "Restore variable"], ["VALTR4", "SETLC", function () {
    return [vm.$("TRACSP"), 0];
  }, "Clear specifier"], [null, "APDSP", function () {
    return [vm.$("TRACSP"), vm.$("TRSTSP")];
  }, "Append trace message"], [null, "INTSPC", function () {
    return [vm.$("XSP"), vm.$("STNOCL")];
  }, "Convert &STNO to string"], [null, "APDSP", function () {
    return [vm.$("TRACSP"), vm.$("XSP")];
  }, "Append &STNO"], [null, "APDSP", function () {
    return [vm.$("TRACSP"), vm.$("COLSP")];
  }, "Append colon"], [null, "AEQLC", function () {
    return [vm.$("FNVLCL"), 0, null, vm.$("FNEXT1")];
  }, "Check entry indicator"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("S"), vm.$("DEFDT")];
  }, "Is variable a string?"], ["VALTR3", "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier"], [null, "GETLG", function () {
    return [vm.$("TCL"), vm.$("XSP")];
  }, "Get length"], [null, "ACOMPC", function () {
    return [vm.$("TCL"), vm.$("BUFLEN"), vm.$("VXOVR"), vm.$("VXOVR")];
  }, ""], ["VALTR1", "APDSP", function () {
    return [vm.$("TRACSP"), vm.$("XSP")];
  }, "Append name of variable"], [null, "APDSP", function () {
    return [vm.$("TRACSP"), vm.$("BLEQSP")];
  }, "Append ' = '"], [null, "GETDC", function () {
    return [vm.$("YPTR"), vm.$("XPTR"), vm.$("DESCR")];
  }, "Get value of traced variable"], [null, "VEQLC", function () {
    return [vm.$("YPTR"), vm.$("S"), null, vm.$("TRV")];
  }, "Is it STRING?"], [null, "VEQLC", function () {
    return [vm.$("YPTR"), vm.$("I"), null, vm.$("TRI")];
  }, "Is it INTEGER?"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("DTREP"), vm.$("YPTR")];
  }, "Else get data type representation"], [null, "GETSPC", function () {
    return [vm.$("XSP"), vm.$("XPTR"), 0];
  }, "Get specifier"], ["TRI2", "APDSP", function () {
    return [vm.$("TRACSP"), vm.$("XSP")];
  }, "Append value"], [null, "BRANCH", function () {
    return [vm.$("TRPRT")];
  }, "Join common processing"], ["TRV", "LOCSP", function () {
    return [vm.$("XSP"), vm.$("YPTR")];
  }, "Get specifier"], [null, "GETLG", function () {
    return [vm.$("SCL"), vm.$("XSP")];
  }, "Get length"], [null, "SUM", function () {
    return [vm.$("TCL"), vm.$("TCL"), vm.$("SCL")];
  }, "Compute total length"], [null, "ACOMPC", function () {
    return [vm.$("TCL"), vm.$("BUFLEN"), vm.$("VXOVR"), vm.$("VXOVR")];
  }, ""], [null, "APDSP", function () {
    return [vm.$("TRACSP"), vm.$("QTSP")];
  }, "Append quote"], [null, "APDSP", function () {
    return [vm.$("TRACSP"), vm.$("XSP")];
  }, "Append string"], [null, "APDSP", function () {
    return [vm.$("TRACSP"), vm.$("QTSP")];
  }, "Append quote"], ["TRPRT", "MSTIME", function () {
    return [vm.$("YPTR")];
  }, "Get time"], [null, "SUBTRT", function () {
    return [vm.$("YPTR"), vm.$("YPTR"), vm.$("ETMCL")];
  }, "Compute time in interpreter"], [null, "INTSPC", function () {
    return [vm.$("XSP"), vm.$("YPTR")];
  }, "Convert to STRING"], [null, "APDSP", function () {
    return [vm.$("TRACSP"), vm.$("ETIMSP")];
  }, "Append time message"], [null, "APDSP", function () {
    return [vm.$("TRACSP"), vm.$("XSP")];
  }, "Append time"], [null, "STPRNT", function () {
    return [vm.$("IOKEY"), vm.$("OUTBLK"), vm.$("TRACSP")];
  }, "Print trace message"], [null, "BRANCH", function () {
    return [vm.$("RTNUL3")];
  }, "Return"], ["TRI", "INTSPC", function () {
    return [vm.$("XSP"), vm.$("YPTR")];
  }, "Convert INTEGER to STRING"], [null, "BRANCH", function () {
    return [vm.$("TRI2")];
  }, "Join processing"], ["DEFDT", "LOCSP", function () {
    return [vm.$("XSP"), vm.$("ZPTR")];
  }, "Get specifier for tag"], [null, "BRANCH", function () {
    return [vm.$("VALTR1")];
  }, "Join processing"], ["FNEXTR", "PROC", function () {
    return [vm.$("VALTR")];
  }, "Return tracing procedure"], [null, "SETAC", function () {
    return [vm.$("FNVLCL"), 0];
  }, "Note entry"], [null, "BRANCH", function () {
    return [vm.$("VALTR2")];
  }, "Join processing"], ["FNEXT1", "APDSP", function () {
    return [vm.$("TRACSP"), vm.$("TRLVSP")];
  }, "Append level message"], [null, "MOVD", function () {
    return [vm.$("XCL"), vm.$("LVLCL")];
  }, "Copy &FNCLEVEL"], [null, "DECRA", function () {
    return [vm.$("XCL"), 1];
  }, "Decrement"], [null, "INTSPC", function () {
    return [vm.$("XSP"), vm.$("XCL")];
  }, "Convert to STRING"], [null, "APDSP", function () {
    return [vm.$("TRACSP"), vm.$("XSP")];
  }, "Append function level"], [null, "APDSP", function () {
    return [vm.$("TRACSP"), vm.$("BLSP")];
  }, "Append blank"], [null, "LOCSP", function () {
    return [vm.$("XSP"), vm.$("RETPCL")];
  }, "Get specifier for return"], [null, "APDSP", function () {
    return [vm.$("TRACSP"), vm.$("XSP")];
  }, "Append return type"], [null, "APDSP", function () {
    return [vm.$("TRACSP"), vm.$("OFSP")];
  }, "Append ' OF '"], [null, "DEQL", function () {
    return [vm.$("RETPCL"), vm.$("FRETCL"), vm.$("VALTR3")];
  }, ""], [null, "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier for function name"], [null, "GETLG", function () {
    return [vm.$("TCL"), vm.$("XSP")];
  }, "Get length"], [null, "ACOMPC", function () {
    return [vm.$("TCL"), vm.$("BUFLEN"), vm.$("VXOVR"), vm.$("VXOVR")];
  }, ""], [null, "APDSP", function () {
    return [vm.$("TRACSP"), vm.$("XSP")];
  }, "Append name of function"], [null, "BRANCH", function () {
    return [vm.$("TRPRT")];
  }, "Join common processing"], ["FNEXT2", "PROC", function () {
    return [vm.$("VALTR")];
  }, "Note entry"], [null, "SETAC", function () {
    return [vm.$("FNVLCL"), 0];
  }, "Restore function name"], [null, "POP", function () {
    return [vm.$("XPTR")];
  }, "Join common processing"], [null, "BRANCH", function () {
    return [vm.$("VALTR4")];
  }, ""], ["VXOVR", "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("PRTOVF")];
  }, "Print error message"], [null, "BRANCH", function () {
    return [vm.$("RTNUL3")];
  }, "Return"], [null, "TITLE", function () {
    return ["Other Operations"];
  }, ""], ["ASGN", "PROC", function () {
    return [null];
  }, "X = Y"], [null, "INCRA", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Increment offset in object code"], [null, "GETD", function () {
    return [vm.$("XPTR"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get object code descriptor"], [null, "TESTF", function () {
    return [vm.$("XPTR"), vm.$("FNC"), null, vm.$("ASGNC")];
  }, "Test for function descriptor"], ["ASGNV", "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("K"), null, vm.$("ASGNIC")];
  }, "Check for keyword subject"], [null, "INCRA", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Increment offset in object code"], [null, "GETD", function () {
    return [vm.$("YPTR"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get object code descriptor"], [null, "TESTF", function () {
    return [vm.$("YPTR"), vm.$("FNC"), null, vm.$("ASGNCV")];
  }, "Test for function descriptor"], ["ASGNVN", "AEQLC", function () {
    return [vm.$("INSW"), 0, null, vm.$("ASGNV1")];
  }, "Check &INPUT"], [null, "LOCAPV", function () {
    return [vm.$("ZPTR"), vm.$("INATL"), vm.$("YPTR"), vm.$("ASGNV1")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("ZPTR"), vm.$("DESCR")];
  }, "Get input association descriptor"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("PUTIN"), [vm.$("ZPTR"), vm.$("YPTR")], [vm.$("FAIL"), vm.$("ASGNVV")]];
  }, ""], ["ASGNV1", "GETDC", function () {
    return [vm.$("YPTR"), vm.$("YPTR"), vm.$("DESCR")];
  }, "Get value"], ["ASGNVV", "PUTDC", function () {
    return [vm.$("XPTR"), vm.$("DESCR"), vm.$("YPTR")];
  }, "Perform assignment"], [null, "AEQLC", function () {
    return [vm.$("OUTSW"), 0, null, vm.$("ASGN1")];
  }, "Check &OUTPUT"], [null, "LOCAPV", function () {
    return [vm.$("ZPTR"), vm.$("OUTATL"), vm.$("XPTR"), vm.$("ASGN1")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("ZPTR"), vm.$("DESCR")];
  }, "Get output association descriptor"], [null, "RCALL", function () {
    return [null, vm.$("PUTOUT"), [vm.$("ZPTR"), vm.$("YPTR")]];
  }, "Perform output"], ["ASGN1", "ACOMPC", function () {
    return [vm.$("TRAPCL"), 0, null, vm.$("RTNUL3"), vm.$("RTNUL3")];
  }, ""], [null, "LOCAPT", function () {
    return [vm.$("ATPTR"), vm.$("TVALL"), vm.$("XPTR"), vm.$("RTNUL3")];
  }, ""], [null, "RCALL", function () {
    return [null, vm.$("TRPHND"), vm.$("ATPTR"), vm.$("RTNUL3")];
  }, "E3.3.1"], ["ASGNC", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("INVOKE"), [vm.$("XPTR")], [vm.$("FAIL"), vm.$("ASGNV"), vm.$("NEMO")]];
  }, ""], ["ASGNCV", "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save subject of assignment"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("INVOKE"), [vm.$("YPTR")], [vm.$("FAIL"), vm.$("ASGNVP")]];
  }, ""], ["ASGNCJ", "POP", function () {
    return [vm.$("XPTR")];
  }, "Restore subject"], [null, "BRANCH", function () {
    return [vm.$("ASGNVV")];
  }, ""], ["ASGNVP", "POP", function () {
    return [vm.$("XPTR")];
  }, "Restore subject"], [null, "BRANCH", function () {
    return [vm.$("ASGNVN")];
  }, ""], ["ASGNIC", "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save subject of assignment"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("INTVAL"), null, [vm.$("FAIL"), vm.$("ASGNCJ")]];
  }, ""], ["CON", "PROC", function () {
    return [null];
  }, "X Y (concatenation)"], [null, "RCALL", function () {
    return [null, vm.$("XYARGS"), null, vm.$("FAIL")];
  }, "Get two arguments"], [null, "DEQL", function () {
    return [vm.$("XPTR"), vm.$("NULVCL"), null, vm.$("RTYPTR")];
  }, "If first is null, return second"], [null, "DEQL", function () {
    return [vm.$("YPTR"), vm.$("NULVCL"), null, vm.$("RTXPTR")];
  }, "If second is null, return first"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("S"), null, vm.$("CON5")];
  }, "Is first STRING?"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("P"), null, vm.$("CON5")];
  }, "Is first PATTERN?"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("I"), null, vm.$("CON4I")];
  }, "Is first INTEGER?"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("R"), null, vm.$("CON4R")];
  }, "Is first REAL?"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("E"), vm.$("INTR1")];
  }, "Is first EXPRESSION?"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("STARSZ")];
  }, "Allocate block for pattern"], [null, "MOVBLK", function () {
    return [vm.$("TPTR"), vm.$("STRPAT"), vm.$("STARSZ")];
  }, "Set up pattern for expression"], [null, "PUTDC", function () {
    return [vm.$("TPTR"), 4 * vm.$("DESCR"), vm.$("XPTR")];
  }, "Insert pointer to expression"], [null, "MOVD", function () {
    return [vm.$("XPTR"), vm.$("TPTR")];
  }, "Set up as first argument"], [null, "BRANCH", function () {
    return [vm.$("CON5")];
  }, ""], ["CON4R", "REALST", function () {
    return [vm.$("REALSP"), vm.$("XPTR")];
  }, "Convert REAL to STRING"], [null, "SETSP", function () {
    return [vm.$("XSP"), vm.$("REALSP")];
  }, "Set up specifier"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), vm.$("XSPPTR"), vm.$("CON5")];
  }, ""], ["CON4I", "INTSPC", function () {
    return [vm.$("ZSP"), vm.$("XPTR")];
  }, "Convert INTEGER to STRING"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GENVAR"), [vm.$("ZSPPTR")]];
  }, ""], ["CON5", "VEQLC", function () {
    return [vm.$("YPTR"), vm.$("S"), null, vm.$("CON7")];
  }, "Is second STRING?"], [null, "VEQLC", function () {
    return [vm.$("YPTR"), vm.$("P"), null, vm.$("CON7")];
  }, "Is second PATTERN?"], [null, "VEQLC", function () {
    return [vm.$("YPTR"), vm.$("I"), null, vm.$("CON5I")];
  }, "Is second INTEGER?"], [null, "VEQLC", function () {
    return [vm.$("YPTR"), vm.$("R"), null, vm.$("CON5R")];
  }, "Is second REAL?"], [null, "VEQLC", function () {
    return [vm.$("YPTR"), vm.$("E"), vm.$("INTR1")];
  }, "Is second EXPRESSION?"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("STARSZ")];
  }, "Allocate block for pattern"], [null, "MOVBLK", function () {
    return [vm.$("TPTR"), vm.$("STRPAT"), vm.$("STARSZ")];
  }, "Set up pattern for expression"], [null, "PUTDC", function () {
    return [vm.$("TPTR"), 4 * vm.$("DESCR"), vm.$("YPTR")];
  }, "Insert pointer to expression"], [null, "MOVD", function () {
    return [vm.$("YPTR"), vm.$("TPTR")];
  }, "Set up as second argument"], [null, "BRANCH", function () {
    return [vm.$("CON7")];
  }, "Join processing"], ["CON5R", "REALST", function () {
    return [vm.$("REALSP"), vm.$("YPTR")];
  }, "Convert REAL to STRING"], [null, "SETSP", function () {
    return [vm.$("YSP"), vm.$("REALSP")];
  }, "Set up sepcifier"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("GENVAR"), vm.$("YSPPTR"), vm.$("CON7")];
  }, ""], ["CON5I", "INTSPC", function () {
    return [vm.$("ZSP"), vm.$("YPTR")];
  }, "Convert INTEGER to STRING"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("GENVAR"), [vm.$("ZSPPTR")]];
  }, ""], ["CON7", "SETAV", function () {
    return [vm.$("DTCL"), vm.$("XPTR")];
  }, "Get data type of first"], [null, "MOVV", function () {
    return [vm.$("DTCL"), vm.$("YPTR")];
  }, "Get data type of second"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("VVDTP"), null, vm.$("CONVV")];
  }, "Check for STRING-STRING"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("VPDTP"), null, vm.$("CONVP")];
  }, "Check for STRING-PATTERN"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("PVDTP"), null, vm.$("CONPV")];
  }, "Check for PATTERN-STRING"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("PPDTP"), vm.$("INTR1"), vm.$("CONPP")];
  }, ""], ["CONVV", "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Specifier for first string"], [null, "LOCSP", function () {
    return [vm.$("YSP"), vm.$("YPTR")];
  }, "Specifier for second string"], [null, "GETLG", function () {
    return [vm.$("XCL"), vm.$("XSP")];
  }, "Length of first string"], [null, "GETLG", function () {
    return [vm.$("YCL"), vm.$("YSP")];
  }, "Length of second string"], [null, "SUM", function () {
    return [vm.$("XCL"), vm.$("XCL"), vm.$("YCL")];
  }, "Total length"], [null, "ACOMP", function () {
    return [vm.$("XCL"), vm.$("MLENCL"), vm.$("INTR8")];
  }, "Check against &MAXLNGTH"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("CONVAR"), [vm.$("XCL")]];
  }, "Allocate space for string"], [null, "LOCSP", function () {
    return [vm.$("TSP"), vm.$("ZPTR")];
  }, "Get specifier to allocated space"], [null, "SETLC", function () {
    return [vm.$("TSP"), 0];
  }, "Clear length"], [null, "APDSP", function () {
    return [vm.$("TSP"), vm.$("XSP")];
  }, "Move in first string"], [null, "APDSP", function () {
    return [vm.$("TSP"), vm.$("YSP")];
  }, "Append second string"], [null, "BRANCH", function () {
    return [vm.$("GENVSZ")];
  }, "Generate variable"], ["CONVP", "LOCSP", function () {
    return [vm.$("TSP"), vm.$("XPTR")];
  }, "Specifier to string"], [null, "GETLG", function () {
    return [vm.$("TMVAL"), vm.$("TSP")];
  }, "Get length of string"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("LNODSZ")];
  }, "Allocate block for pattern"], [null, "MAKNOD", function () {
    return [vm.$("XPTR"), vm.$("TPTR"), vm.$("TMVAL"), vm.$("ZEROCL"), vm.$("CHRCL"), vm.$("XPTR")];
  }, ""], ["CONPP", "GETSIZ", function () {
    return [vm.$("XSIZ"), vm.$("XPTR")];
  }, "Get size of first pattern"], [null, "GETSIZ", function () {
    return [vm.$("YSIZ"), vm.$("YPTR")];
  }, "Get size of second pattern"], [null, "SUM", function () {
    return [vm.$("TSIZ"), vm.$("XSIZ"), vm.$("YSIZ")];
  }, "Compute total size required"], [null, "SETVC", function () {
    return [vm.$("TSIZ"), vm.$("P")];
  }, "Insert PATTERN data type"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("TSIZ")];
  }, "Allocate block for new pattern"], [null, "MOVD", function () {
    return [vm.$("ZPTR"), vm.$("TPTR")];
  }, "Save copy to return"], [null, "LVALUE", function () {
    return [vm.$("TVAL"), vm.$("YPTR")];
  }, "Get least value for second pattern"], [null, "CPYPAT", function () {
    return [vm.$("TPTR"), vm.$("XPTR"), vm.$("TVAL"), vm.$("ZEROCL"), vm.$("XSIZ"), vm.$("XSIZ")];
  }, ""], [null, "CPYPAT", function () {
    return [vm.$("TPTR"), vm.$("YPTR"), vm.$("ZEROCL"), vm.$("XSIZ"), vm.$("ZEROCL"), vm.$("YSIZ")];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("RTZPTR")];
  }, "Return pattern as value"], ["CONPV", "LOCSP", function () {
    return [vm.$("TSP"), vm.$("YPTR")];
  }, "Get specifier to string"], [null, "GETLG", function () {
    return [vm.$("TMVAL"), vm.$("TSP")];
  }, "Get length of string"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("BLOCK"), vm.$("LNODSZ")];
  }, "Allocate block for pattern"], [null, "MAKNOD", function () {
    return [vm.$("YPTR"), vm.$("TPTR"), vm.$("TMVAL"), vm.$("ZEROCL"), vm.$("CHRCL"), vm.$("YPTR")];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("CONPP")];
  }, "Join common processing"], ["IND", "PROC", function () {
    return [null];
  }, "$X"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("ARGVAL"), null, vm.$("FAIL")];
  }, "Get argument"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("S"), null, vm.$("INDV")];
  }, "STRING is acceptable"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("N"), null, vm.$("RTXNAM")];
  }, "NAME can be returned directly"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("I"), null, vm.$("GENVIX")];
  }, "Convert INTEGER"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("K"), vm.$("INTR1"), vm.$("RTXNAM")];
  }, "KEYWORD is like NAME"], ["INDV", "AEQLC", function () {
    return [vm.$("XPTR"), 0, vm.$("RTXNAM"), vm.$("NONAME")];
  }, ""], ["KEYWRD", "PROC", function () {
    return [null];
  }, "&X"], [null, "INCRA", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("XPTR"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get object code descriptor"], [null, "TESTF", function () {
    return [vm.$("XPTR"), vm.$("FNC"), null, vm.$("KEYC")];
  }, "Check for function"], ["KEYN", "LOCAPV", function () {
    return [vm.$("XPTR"), vm.$("KNATL"), vm.$("XPTR"), vm.$("KEYV")];
  }, ""], [null, "SETVC", function () {
    return [vm.$("XPTR"), vm.$("K")];
  }, "Set KEYWORD (NAME) data type"], [null, "BRANCH", function () {
    return [vm.$("RTXNAM")];
  }, "Return by name"], ["KEYV", "LOCAPV", function () {
    return [vm.$("ATPTR"), vm.$("KVATL"), vm.$("XPTR"), vm.$("UNKNKW")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("ATPTR"), vm.$("DESCR")];
  }, "Get value"], [null, "BRANCH", function () {
    return [vm.$("RTZPTR")];
  }, "Return by value"], ["KEYC", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("INVOKE"), [vm.$("XPTR")], [vm.$("FAIL"), vm.$("KEYN"), vm.$("NEMO")]];
  }, ""], ["KEYT", "PROC", function () {
    return [vm.$("KEYWRD")];
  }, "Procedure to get keyword for trace"], [null, "POP", function () {
    return [vm.$("XPTR")];
  }, "Restore argument"], [null, "BRANCH", function () {
    return [vm.$("KEYN")];
  }, ""], ["LIT", "PROC", function () {
    return [null];
  }, "'X'"], [null, "INCRA", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("ZPTR"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get object code descriptor"], [null, "BRANCH", function () {
    return [vm.$("RTZPTR")];
  }, "Return value"], ["NAME", "PROC", function () {
    return [null];
  }, ".X"], [null, "INCRA", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("ZPTR"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get object code descriptor"], [null, "TESTF", function () {
    return [vm.$("ZPTR"), vm.$("FNC"), vm.$("RTZPTR")];
  }, "Test for function"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("INVOKE"), vm.$("ZPTR"), [vm.$("FAIL"), vm.$("RTZPTR"), vm.$("NEMO")]];
  }, ""], ["NMD", "PROC", function () {
    return [null];
  }, ""], [null, "MOVD", function () {
    return [vm.$("TCL"), vm.$("NHEDCL")];
  }, ""], ["NMD1", "ACOMP", function () {
    return [vm.$("TCL"), vm.$("NAMICL"), vm.$("INTR13"), vm.$("RTN2")];
  }, ""], [null, "SUM", function () {
    return [vm.$("TPTR"), vm.$("NBSPTR"), vm.$("TCL")];
  }, "Compute address"], [null, "GETSPC", function () {
    return [vm.$("TSP"), vm.$("TPTR"), vm.$("DESCR")];
  }, "Get specifier"], [null, "GETDC", function () {
    return [vm.$("TVAL"), vm.$("TPTR"), vm.$("DESCR") + vm.$("SPEC")];
  }, ""], [null, "GETLG", function () {
    return [vm.$("XCL"), vm.$("TSP")];
  }, "Get length"], [null, "ACOMP", function () {
    return [vm.$("XCL"), vm.$("MLENCL"), vm.$("INTR8")];
  }, "Check &MAXLNGTH"], [null, "VEQLC", function () {
    return [vm.$("TVAL"), vm.$("E"), null, vm.$("NAMEXN")];
  }, "Is Variable EXPRESSION?"], ["NMD5", "VEQLC", function () {
    return [vm.$("TVAL"), vm.$("K"), null, vm.$("NMDIC")];
  }, "Is variable KEYWORD?"], [null, "RCALL", function () {
    return [vm.$("VVAL"), vm.$("GENVAR"), [vm.$("TSPPTR")]];
  }, ""], ["NMD4", "PUTDC", function () {
    return [vm.$("TVAL"), vm.$("DESCR"), vm.$("VVAL")];
  }, "Assign value"], [null, "AEQLC", function () {
    return [vm.$("OUTSW"), 0, null, vm.$("NMD3")];
  }, "Check &OUTPUT"], [null, "LOCAPV", function () {
    return [vm.$("ZPTR"), vm.$("OUTATL"), vm.$("TVAL"), vm.$("NMD3")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("ZPTR"), vm.$("ZPTR"), vm.$("DESCR")];
  }, "Get association"], [null, "RCALL", function () {
    return [null, vm.$("PUTOUT"), [vm.$("ZPTR"), vm.$("VVAL")]];
  }, "Perform output"], ["NMD3", "ACOMPC", function () {
    return [vm.$("TRAPCL"), 0, null, vm.$("NMD2"), vm.$("NMD2")];
  }, "Check &TRACE"], [null, "LOCAPT", function () {
    return [vm.$("ATPTR"), vm.$("TVALL"), vm.$("TVAL"), vm.$("NMD2")];
  }, ""], [null, "PUSH", function () {
    return [[vm.$("TCL"), vm.$("NAMICL"), vm.$("NHEDCL")]];
  }, "Save state"], [null, "MOVD", function () {
    return [vm.$("NHEDCL"), vm.$("NAMICL")];
  }, "Set up new name list"], [null, "RCALL", function () {
    return [null, vm.$("TRPHND"), vm.$("ATPTR")];
  }, "E3.3.1"], [null, "POP", function () {
    return [[vm.$("NHEDCL"), vm.$("NAMICL"), vm.$("TCL")]];
  }, "Restore state"], ["NMD2", "INCRA", function () {
    return [vm.$("TCL"), vm.$("DESCR") + vm.$("SPEC")];
  }, "Move to next name"], [null, "BRANCH", function () {
    return [vm.$("NMD1")];
  }, "Continue"], ["NMDIC", "SPCINT", function () {
    return [vm.$("VVAL"), vm.$("TSP"), vm.$("INTR1"), vm.$("NMD4")];
  }, "Convert to INTEGER"], ["NAMEXN", "RCALL", function () {
    return [vm.$("TVAL"), vm.$("EXPEVL"), vm.$("TVAL"), [vm.$("FAIL"), vm.$("NMD5"), vm.$("NEMO")]];
  }, "E3.10.5"], ["STR", "PROC", function () {
    return [null];
  }, "*X"], [null, "SUM", function () {
    return [vm.$("ZPTR"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Compute position in code"], [null, "RCALL", function () {
    return [null, vm.$("CODSKP"), [vm.$("ONECL")]];
  }, "Skip one nest"], [null, "SETVC", function () {
    return [vm.$("ZPTR"), vm.$("E")];
  }, "Insert EXPRESSION data type"], [null, "BRANCH", function () {
    return [vm.$("RTZPTR")];
  }, "Return pointer to code"], [null, "TITLE", function () {
    return ["Other Predicates"];
  }, ""], ["DIFFER", "PROC", function () {
    return [null];
  }, "DIFFER(X,Y)"], [null, "RCALL", function () {
    return [null, vm.$("XYARGS"), null, vm.$("FAIL")];
  }, "Evaluate arguments"], [null, "DEQL", function () {
    return [vm.$("XPTR"), vm.$("YPTR"), vm.$("RETNUL"), vm.$("FAIL")];
  }, ""], ["IDENT", "PROC", function () {
    return [null];
  }, "IDENT(X,Y)"], [null, "RCALL", function () {
    return [null, vm.$("XYARGS"), null, vm.$("FAIL")];
  }, "Evaluate arguments"], [null, "DEQL", function () {
    return [vm.$("XPTR"), vm.$("YPTR"), vm.$("FAIL"), vm.$("RETNUL")];
  }, ""], ["LGT", "PROC", function () {
    return [null];
  }, "LGT(X,Y)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Evaluate first argument"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save first argument"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Evaluate second argument"], [null, "POP", function () {
    return [vm.$("XPTR")];
  }, "Restore first argument"], [null, "AEQLC", function () {
    return [vm.$("XPTR"), 0, null, vm.$("FAIL")];
  }, "Null is not greater than anything"], [null, "AEQLC", function () {
    return [vm.$("YPTR"), 0, null, vm.$("RETNUL")];
  }, "Similarly for second argument"], [null, "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier to first argument"], [null, "LOCSP", function () {
    return [vm.$("YSP"), vm.$("YPTR")];
  }, "Get specifier to second argument"], [null, "LEXCMP", function () {
    return [vm.$("XSP"), vm.$("YSP"), vm.$("RETNUL"), vm.$("FAIL"), vm.$("FAIL")];
  }, ""], ["NEG", "PROC", function () {
    return [null];
  }, "\\X"], [null, "PUSH", function () {
    return [[vm.$("OCBSCL"), vm.$("OCICL")]];
  }, "Save object code position"], [null, "RCALL", function () {
    return [null, vm.$("ARGVAL"), null, [null, vm.$("FAIL")]];
  }, "Fail on success"], [null, "POP", function () {
    return [[vm.$("OCICL"), vm.$("OCBSCL")]];
  }, "Restore object code position"], [null, "RCALL", function () {
    return [null, vm.$("CODSKP"), [vm.$("ONECL")], vm.$("RETNUL")];
  }, ""], ["QUES", "PROC", function () {
    return [null];
  }, "?X"], [null, "RCALL", function () {
    return [null, vm.$("ARGVAL"), null, [vm.$("FAIL"), vm.$("RETNUL")]];
  }, ""], [null, "TITLE", function () {
    return ["Other Functions"];
  }, ""], ["APPLY", "PROC", function () {
    return [null];
  }, "APPLY(F,A1,...,AN)"], [null, "SETAV", function () {
    return [vm.$("XCL"), vm.$("INCL")];
  }, "Get count of arguments"], [null, "DECRA", function () {
    return [vm.$("XCL"), 1];
  }, "Decrement to skip function name"], [null, "ACOMPC", function () {
    return [vm.$("XCL"), 1, null, null, vm.$("ARGNER")];
  }, "E3.3.3"], [null, "PUSH", function () {
    return [vm.$("XCL")];
  }, "Save argument count"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get function name"], [null, "POP", function () {
    return [vm.$("XCL")];
  }, "Restore argument count"], [null, "LOCAPV", function () {
    return [vm.$("XPTR"), vm.$("FNCPL"), vm.$("XPTR"), vm.$("UNDF")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("INCL"), vm.$("XPTR"), vm.$("DESCR")];
  }, "Get function descriptor"], [null, "SETVA", function () {
    return [vm.$("INCL"), vm.$("XCL")];
  }, "Insert actual number of arguments"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("INVOKE"), [vm.$("INCL")], [vm.$("FAIL"), null, vm.$("RTZPTR")]];
  }, ""], [null, "MOVD", function () {
    return [vm.$("XPTR"), vm.$("ZPTR")];
  }, "Return by name"], [null, "BRANCH", function () {
    return [vm.$("RTXNAM")];
  }, ""], ["ARG", "PROC", function () {
    return [null];
  }, "ARG(F,N)"], [null, "PUSH", function () {
    return [[vm.$("ONECL"), vm.$("DEFCL")]];
  }, "Save ARG indicators"], [null, "BRANCH", function () {
    return [vm.$("ARG1")];
  }, "Join main processing"], ["ARGINT", "PROC", function () {
    return [vm.$("ARG")];
  }, "Procedure used for CALL tracing"], [null, "POP", function () {
    return [[vm.$("XPTR"), vm.$("XCL")]];
  }, "Restore arguments"], [null, "PUSH", function () {
    return [[vm.$("ONECL"), vm.$("DEFCL")]];
  }, "Save indicators"], [null, "BRANCH", function () {
    return [vm.$("ARG2")];
  }, "Join processing"], ["LOCAL", "PROC", function () {
    return [vm.$("ARG")];
  }, "LOCAL(F,N)"], [null, "PUSH", function () {
    return [[vm.$("ONECL"), vm.$("ZEROCL"), vm.$("DEFCL")]];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("ARG1")];
  }, "Join main processing"], ["FIELDS", "PROC", function () {
    return [vm.$("ARG")];
  }, "FIELD(F,N)"], [null, "PUSH", function () {
    return [[vm.$("ZEROCL"), vm.$("ZEROCL"), vm.$("DATCL")]];
  }, ""], ["ARG1", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get function name"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save function name"], [null, "RCALL", function () {
    return [vm.$("XCL"), vm.$("INTVAL"), null, vm.$("FAIL")];
  }, "Get number"], [null, "ACOMP", function () {
    return [vm.$("ZEROCL"), vm.$("XCL"), vm.$("FAIL"), vm.$("FAIL")];
  }, ""], [null, "POP", function () {
    return [vm.$("XPTR")];
  }, "Restore function name"], ["ARG2", "LOCAPV", function () {
    return [vm.$("XPTR"), vm.$("FNCPL"), vm.$("XPTR"), vm.$("INTR30")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), vm.$("DESCR")];
  }, "Get function descriptor"], [null, "GETDC", function () {
    return [vm.$("YCL"), vm.$("XPTR"), 0];
  }, "Get procedure descriptor"], [null, "GETDC", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), vm.$("DESCR")];
  }, "Get definition block"], [null, "POP", function () {
    return [[vm.$("ZCL"), vm.$("ALCL")]];
  }, "Restore indicators"], [null, "AEQL", function () {
    return [vm.$("YCL"), vm.$("ZCL"), vm.$("INTR30")];
  }, "Check procedure type"], [null, "MULTC", function () {
    return [vm.$("XCL"), vm.$("XCL"), vm.$("DESCR")];
  }, "Convert number to address units"], [null, "INCRA", function () {
    return [vm.$("XCL"), 2 * vm.$("DESCR")];
  }, "Skip prototype information"], [null, "SETAV", function () {
    return [vm.$("YCL"), vm.$("YCL")];
  }, "Get argument count"], [null, "MULTC", function () {
    return [vm.$("YCL"), vm.$("YCL"), vm.$("DESCR")];
  }, "Convert to address units"], [null, "AEQLC", function () {
    return [vm.$("ALCL"), 0, null, vm.$("ARG4")];
  }, "Check funcion type"], [null, "INCRA", function () {
    return [vm.$("YCL"), 2 * vm.$("DESCR")];
  }, "Increment for heading"], [null, "MOVD", function () {
    return [vm.$("ZCL"), vm.$("YCL")];
  }, "Get working copy"], [null, "BRANCH", function () {
    return [vm.$("ARG5")];
  }, "Branch to continue processing"], ["ARG4", "GETSIZ", function () {
    return [vm.$("ZCL"), vm.$("XPTR")];
  }, "Get size of block"], [null, "POP", function () {
    return [vm.$("ALCL")];
  }, "Restore entry indicator"], [null, "AEQLC", function () {
    return [vm.$("ALCL"), 0, null, vm.$("ARG5")];
  }, "Check entry type"], [null, "SUM", function () {
    return [vm.$("XCL"), vm.$("XCL"), vm.$("YCL")];
  }, "Skip formal arguments"], ["ARG5", "ACOMP", function () {
    return [vm.$("XCL"), vm.$("ZCL"), vm.$("FAIL")];
  }, "Check number in bounds"], [null, "GETD", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("XCL")];
  }, "Get the desired name"], [null, "BRANCH", function () {
    return [vm.$("RTZPTR")];
  }, "Return name as value"], ["CLEAR", "PROC", function () {
    return [null];
  }, "CLEAR()"], [null, "RCALL", function () {
    return [null, vm.$("ARGVAL"), null, vm.$("FAIL")];
  }, "Get rid of argument"], [null, "SETAC", function () {
    return [vm.$("DMPPTR"), vm.$("OBLIST") - vm.$("DESCR")];
  }, "Initialize bin pointer"], ["CLEAR1", "ACOMP", function () {
    return [vm.$("DMPPTR"), vm.$("OBEND"), vm.$("RETNUL")];
  }, "Check for end"], [null, "INCRA", function () {
    return [vm.$("DMPPTR"), vm.$("DESCR")];
  }, "Update for next bin"], [null, "MOVD", function () {
    return [vm.$("YPTR"), vm.$("DMPPTR")];
  }, "Get working copy"], ["CLEAR2", "GETAC", function () {
    return [vm.$("YPTR"), vm.$("YPTR"), vm.$("LNKFLD")];
  }, "Get next variable"], [null, "AEQLC", function () {
    return [vm.$("YPTR"), 0, null, vm.$("CLEAR1")];
  }, "Check for end of chain"], [null, "PUTDC", function () {
    return [vm.$("YPTR"), vm.$("DESCR"), vm.$("NULVCL")];
  }, "Assign null value"], [null, "BRANCH", function () {
    return [vm.$("CLEAR2")];
  }, "Continue"], ["COLECT", "PROC", function () {
    return [null];
  }, "COLLECT(N)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("INTVAL"), null, vm.$("FAIL")];
  }, "Get number of address units required"], [null, "ACOMPC", function () {
    return [vm.$("XPTR"), 0, null, null, vm.$("LENERR")];
  }, "Verify positive integer"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("GC"), [vm.$("XPTR")], vm.$("FAIL")];
  }, "Call for storage regeneration"], [null, "SETVC", function () {
    return [vm.$("ZPTR"), vm.$("I")];
  }, "Set INTEGER data type"], [null, "BRANCH", function () {
    return [vm.$("RTZPTR")];
  }, "Return amount collected"], ["COPY", "PROC", function () {
    return [null];
  }, "COPY(X)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("ARGVAL"), null, vm.$("FAIL")];
  }, "Get object to copy"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("S"), null, vm.$("INTR1")];
  }, "STRING cannot be copied"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("I"), null, vm.$("INTR1")];
  }, "INTEGER cannot be copied"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("R"), null, vm.$("INTR1")];
  }, "REAL cannot be copied"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("N"), null, vm.$("INTR1")];
  }, "NAME cannot be copied"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("K"), null, vm.$("INTR1")];
  }, "KEYWORD (NAME) cannot be copied"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("E"), null, vm.$("INTR1")];
  }, "EXPRESSION cannot be copied"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("T"), null, vm.$("INTR1")];
  }, "TABLE cannot be copied"], [null, "GETSIZ", function () {
    return [vm.$("XCL"), vm.$("XPTR")];
  }, "Get size of object to copy"], [null, "MOVV", function () {
    return [vm.$("XCL"), vm.$("XPTR")];
  }, "Insert data type"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("BLOCK"), vm.$("XCL")];
  }, "Allocate block for copy"], [null, "MOVBLK", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), vm.$("XCL")];
  }, "Copy contents"], [null, "BRANCH", function () {
    return [vm.$("RTZPTR")];
  }, "Return the copy"], ["CNVRT", "PROC", function () {
    return [null];
  }, "CONVERT(X,T)"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("ARGVAL"), null, vm.$("FAIL")];
  }, "Get object to be converted"], [null, "PUSH", function () {
    return [vm.$("ZPTR")];
  }, "Save object"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get data type target"], [null, "POP", function () {
    return [vm.$("ZPTR")];
  }, "Restore object"], [null, "LOCAPV", function () {
    return [vm.$("XPTR"), vm.$("DTATL"), vm.$("YPTR"), vm.$("INTR1")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("XPTR"), vm.$("XPTR"), vm.$("DESCR")];
  }, "Get code"], [null, "SETAV", function () {
    return [vm.$("DTCL"), vm.$("ZPTR")];
  }, "Insert object data type"], [null, "MOVV", function () {
    return [vm.$("DTCL"), vm.$("XPTR")];
  }, "Insert target data type"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("IVDTP"), null, vm.$("CNVIV")];
  }, "Check for INTEGER-STRING"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("VCDTP"), null, vm.$("RECOMP")];
  }, "Check for STRING-CODE"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("VEDTP"), null, vm.$("CONVE")];
  }, ""], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("VRDTP"), null, vm.$("CONVR")];
  }, "Check for STRING-REAL"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("RIDTP"), null, vm.$("CONRI")];
  }, "Check for REAL-INTEGER"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("IRDTP"), null, vm.$("CONIR")];
  }, "Check for INTEGER-REAL"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("VIDTP"), null, vm.$("CNVVI")];
  }, "CHeck for STRING-INTEGER"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("ATDTP"), null, vm.$("CNVAT")];
  }, "Check for ARRAY-TABLE"], [null, "DEQL", function () {
    return [vm.$("DTCL"), vm.$("TADTP"), null, vm.$("CNVTA")];
  }, "Check for TABLE-ARRAY"], [null, "VEQL", function () {
    return [vm.$("ZPTR"), vm.$("XPTR"), null, vm.$("RTZPTR")];
  }, "E3.0.4"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("S"), vm.$("FAIL"), vm.$("CNVRTS")];
  }, "E3.0.4"], ["RECOMP", "SETAC", function () {
    return [vm.$("SCL"), 1];
  }, "Note STRING-CODE conversion"], ["RECOMJ", "LOCSP", function () {
    return [vm.$("TEXTSP"), vm.$("ZPTR")];
  }, "Set up global specifier"], ["RECOMT", "GETLG", function () {
    return [vm.$("OCALIM"), vm.$("TEXTSP")];
  }, "E3.1.5"], [null, "AEQLC", function () {
    return [vm.$("OCALIM"), 0, null, vm.$("RECOMN")];
  }, "E3.1.5"], [null, "MULTC", function () {
    return [vm.$("OCALIM"), vm.$("OCALIM"), vm.$("DESCR")];
  }, "Convert to address units"], [null, "INCRA", function () {
    return [vm.$("OCALIM"), 6 * vm.$("DESCR")];
  }, "Leave room for safety"], [null, "SETVC", function () {
    return [vm.$("OCALIM"), vm.$("C")];
  }, "Insert CODE data type"], [null, "RCALL", function () {
    return [vm.$("CMBSCL"), vm.$("BLOCK"), vm.$("OCALIM")];
  }, "Allocate block for object code"], [null, "SUM", function () {
    return [vm.$("OCLIM"), vm.$("CMBSCL"), vm.$("OCALIM")];
  }, "Compute end"], [null, "DECRA", function () {
    return [vm.$("OCLIM"), 6 * vm.$("DESCR")];
  }, ""], [null, "SETAC", function () {
    return [vm.$("CMOFCL"), 0];
  }, "Zero offset"], [null, "SETAC", function () {
    return [vm.$("ESAICL"), 0];
  }, "Zero error count"], [null, "PUSH", function () {
    return [vm.$("CMBSCL")];
  }, "Save block pointer"], [null, "SELBRA", function () {
    return [vm.$("SCL"), [null, vm.$("CONVEX")]];
  }, "Select correct procedure"], ["RECOM1", "LEQLC", function () {
    return [vm.$("TEXTSP"), 0, null, vm.$("RECOM2")];
  }, "Is string exhausted?"], [null, "RCALL", function () {
    return [null, vm.$("CMPILE"), null, [vm.$("RECOMF"), null, vm.$("RECOM1")]];
  }, ""], ["RECOM2", "SETAC", function () {
    return [vm.$("SCL"), 3];
  }, "Set return switch"], ["RECOMQ", "INCRA", function () {
    return [vm.$("CMOFCL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "PUTD", function () {
    return [vm.$("CMBSCL"), vm.$("CMOFCL"), vm.$("ENDCL")];
  }, "Insert END function"], [null, "POP", function () {
    return [vm.$("ZPTR")];
  }, "Restore pointer to code block"], ["RECOMZ", "SUM", function () {
    return [vm.$("CMBSCL"), vm.$("CMBSCL"), vm.$("CMOFCL")];
  }, ""], [null, "RCALL", function () {
    return [null, vm.$("SPLIT"), [vm.$("CMBSCL")]];
  }, "Split off remainder"], [null, "SETAC", function () {
    return [vm.$("OCLIM"), 0];
  }, "Clear limit pointer"], [null, "SETAC", function () {
    return [vm.$("LPTR"), 0];
  }, "Clear label pointer"], [null, "ZERBLK", function () {
    return [vm.$("COMREG"), vm.$("COMDCT")];
  }, "Zero compiler descriptors"], [null, "SELBRA", function () {
    return [vm.$("SCL"), [vm.$("FAIL"), vm.$("INTR10"), vm.$("RTZPTR")]];
  }, ""], ["RECOMF", "SETAC", function () {
    return [vm.$("SCL"), 1];
  }, "Set failure return"], [null, "BRANCH", function () {
    return [vm.$("RECOMQ")];
  }, "Rejoin processing"], ["RECOMN", "SETSP", function () {
    return [vm.$("TEXTSP"), vm.$("BLSP")];
  }, "E3.1.5"], [null, "BRANCH", function () {
    return [vm.$("RECOMT")];
  }, "E3.1.5"], ["CODER", "PROC", function () {
    return [vm.$("CNVRT")];
  }, "CODE(S)"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("VARVAL"), null, [vm.$("FAIL"), vm.$("RECOMP")]];
  }, ""], ["CONVE", "PROC", function () {
    return [vm.$("CNVRT")];
  }, "Convert to EXPRESSION"], [null, "SETAC", function () {
    return [vm.$("SCL"), 2];
  }, "Set switch"], [null, "BRANCH", function () {
    return [vm.$("RECOMJ")];
  }, "Join common program"], ["CONVEX", "RCALL", function () {
    return [vm.$("FORMND"), vm.$("EXPR"), null, vm.$("FAIL")];
  }, "Compile expression"], [null, "LEQLC", function () {
    return [vm.$("TEXTSP"), 0, vm.$("FAIL")];
  }, "Verify complete compilation"], [null, "RCALL", function () {
    return [null, vm.$("TREPUB"), vm.$("FORMND")];
  }, "Publish code tree"], [null, "MOVD", function () {
    return [vm.$("ZPTR"), vm.$("CMBSCL")];
  }, "E3.1.6"], [null, "SETVC", function () {
    return [vm.$("ZPTR"), vm.$("E")];
  }, "Insert EXPRESSION data type"], [null, "SETAC", function () {
    return [vm.$("SCL"), 3];
  }, "Set return branch"], [null, "BRANCH", function () {
    return [vm.$("RECOMZ")];
  }, "Join common program"], ["CONVR", "LOCSP", function () {
    return [vm.$("ZSP"), vm.$("ZPTR")];
  }, "Get specifier"], [null, "SPCINT", function () {
    return [vm.$("ZPTR"), vm.$("ZSP"), null, vm.$("CONIR")];
  }, "Try conversion to INTEGER first"], [null, "SPREAL", function () {
    return [vm.$("ZPTR"), vm.$("ZSP"), vm.$("FAIL"), vm.$("RTZPTR")];
  }, ""], ["CONIR", "INTRL", function () {
    return [vm.$("ZPTR"), vm.$("ZPTR")];
  }, "Convert INTEGER to REAL"], [null, "BRANCH", function () {
    return [vm.$("RTZPTR")];
  }, "Return value"], ["CONRI", "RLINT", function () {
    return [vm.$("ZPTR"), vm.$("ZPTR"), vm.$("FAIL"), vm.$("RTZPTR")];
  }, ""], ["CNVIV", "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("GNVARI"), vm.$("ZPTR"), vm.$("RTZPTR")];
  }, ""], ["CNVVI", "LOCSP", function () {
    return [vm.$("ZSP"), vm.$("ZPTR")];
  }, "Get specifier"], [null, "SPCINT", function () {
    return [vm.$("ZPTR"), vm.$("ZSP"), null, vm.$("RTZPTR")];
  }, "Convert STRING to INTEGER"], [null, "SPREAL", function () {
    return [vm.$("ZPTR"), vm.$("ZSP"), vm.$("FAIL"), vm.$("CONRI")];
  }, "Try conversion to REAL"], ["CNVRTS", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("DTREP"), vm.$("ZPTR")];
  }, "Get data type representation"], [null, "GETSPC", function () {
    return [vm.$("ZSP"), vm.$("XPTR"), 0];
  }, "Get specifier"], [null, "BRANCH", function () {
    return [vm.$("GENVRZ")];
  }, "Go generate variable"], ["CNVTA", "MOVD", function () {
    return [vm.$("YPTR"), vm.$("ZPTR")];
  }, "E3.2.3"], [null, "MOVD", function () {
    return [vm.$("YCL"), vm.$("ZEROCL")];
  }, "E3.2.3"], ["CNVTA7", "GETSIZ", function () {
    return [vm.$("XCL"), vm.$("YPTR")];
  }, "E3.2.3"], [null, "MOVD", function () {
    return [vm.$("WPTR"), vm.$("YPTR")];
  }, "E3.2.3"], [null, "MOVD", function () {
    return [vm.$("ZCL"), vm.$("XCL")];
  }, "E3.2.3"], [null, "DECRA", function () {
    return [vm.$("XCL"), 3 * vm.$("DESCR")];
  }, "E3.2.3"], ["CNVTA1", "GETD", function () {
    return [vm.$("WCL"), vm.$("WPTR"), vm.$("XCL")];
  }, "Get item value"], [null, "DEQL", function () {
    return [vm.$("WCL"), vm.$("NULVCL"), null, vm.$("CNVTA2")];
  }, "Check for null value"], [null, "INCRA", function () {
    return [vm.$("YCL"), 1];
  }, "Otherwise count item"], ["CNVTA2", "AEQLC", function () {
    return [vm.$("XCL"), vm.$("DESCR"), null, vm.$("CNVTA6")];
  }, "E3.2.3"], [null, "DECRA", function () {
    return [vm.$("XCL"), 2 * vm.$("DESCR")];
  }, "Count down"], [null, "BRANCH", function () {
    return [vm.$("CNVTA1")];
  }, "Process next item"], ["CNVTA6", "GETD", function () {
    return [vm.$("YPTR"), vm.$("YPTR"), vm.$("ZCL")];
  }, "E3.2.3"], [null, "AEQLC", function () {
    return [vm.$("YPTR"), 1, vm.$("CNVTA7")];
  }, "E3.2.3"], ["CNVTA4", "AEQLC", function () {
    return [vm.$("YCL"), 0, null, vm.$("FAIL")];
  }, "Fail on empty table"], [null, "MOVD", function () {
    return [vm.$("WPTR"), vm.$("ZPTR")];
  }, "E3.2.3"], [null, "MULTC", function () {
    return [vm.$("XCL"), vm.$("YCL"), 2 * vm.$("DESCR")];
  }, "Convert count to address units"], [null, "INTSPC", function () {
    return [vm.$("YSP"), vm.$("YCL")];
  }, "Get prototype for size"], [null, "SETLC", function () {
    return [vm.$("PROTSP"), 0];
  }, "Clear specifier"], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("YSP")];
  }, "Append length"], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("CMASP")];
  }, "Append comma"], [null, "MOVD", function () {
    return [vm.$("WCL"), vm.$("ZEROCL")];
  }, "E3.1.1"], [null, "SETAC", function () {
    return [vm.$("WCL"), 2];
  }, "Set up 2 for second dimension"], [null, "INTSPC", function () {
    return [vm.$("XSP"), vm.$("WCL")];
  }, "Convert to string"], [null, "APDSP", function () {
    return [vm.$("PROTSP"), vm.$("XSP")];
  }, "Append 2"], [null, "SETSP", function () {
    return [vm.$("XSP"), vm.$("PROTSP")];
  }, "Move specifier"], [null, "RCALL", function () {
    return [vm.$("TPTR"), vm.$("GENVAR"), vm.$("XSPPTR")];
  }, "E3.5.2"], [null, "MOVD", function () {
    return [vm.$("ZCL"), vm.$("XCL")];
  }, "Save size"], [null, "INCRA", function () {
    return [vm.$("XCL"), 4 * vm.$("DESCR")];
  }, "Increment for heading"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("BLOCK"), vm.$("XCL")];
  }, "Get block for array"], [null, "SETVC", function () {
    return [vm.$("ZPTR"), vm.$("A")];
  }, "Insert ARRAY data type"], [null, "MOVD", function () {
    return [vm.$("ATPRCL"), vm.$("TPTR")];
  }, "E3.5.2"], [null, "SETVA", function () {
    return [vm.$("ATEXCL"), vm.$("YCL")];
  }, "Insert First dimension in head"], [null, "MOVBLK", function () {
    return [vm.$("ZPTR"), vm.$("ATRHD"), vm.$("FRDSCL")];
  }, "Copy heading information"], [null, "MOVD", function () {
    return [vm.$("YPTR"), vm.$("ZPTR")];
  }, "Save copy of block pointer"], [null, "MULTC", function () {
    return [vm.$("YCL"), vm.$("YCL"), vm.$("DESCR")];
  }, "Convert item count to address units"], [null, "INCRA", function () {
    return [vm.$("YPTR"), 5 * vm.$("DESCR")];
  }, "Skip heading"], [null, "SUM", function () {
    return [vm.$("TPTR"), vm.$("YPTR"), vm.$("YCL")];
  }, "Compute second half position"], ["CNVTA8", "GETSIZ", function () {
    return [vm.$("WCL"), vm.$("WPTR")];
  }, "E3.2.3"], [null, "DECRA", function () {
    return [vm.$("WCL"), 2 * vm.$("DESCR")];
  }, "E3.2.3"], [null, "SUM", function () {
    return [vm.$("WCL"), vm.$("WPTR"), vm.$("WCL")];
  }, "E3.2.3"], ["CNVTA3", "GETDC", function () {
    return [vm.$("TCL"), vm.$("WPTR"), vm.$("DESCR")];
  }, "E3.2.3"], [null, "DEQL", function () {
    return [vm.$("TCL"), vm.$("NULVCL"), null, vm.$("CNVTA5")];
  }, "E3.2.3"], [null, "PUTDC", function () {
    return [vm.$("TPTR"), 0, vm.$("TCL")];
  }, "E3.2.3"], [null, "MOVDIC", function () {
    return [vm.$("YPTR"), 0, vm.$("WPTR"), 2 * vm.$("DESCR")];
  }, ""], [null, "INCRA", function () {
    return [vm.$("YPTR"), vm.$("DESCR")];
  }, "Increment upper pointer"], [null, "INCRA", function () {
    return [vm.$("TPTR"), vm.$("DESCR")];
  }, "Increment lower pointer"], ["CNVTA5", "INCRA", function () {
    return [vm.$("WPTR"), 2 * vm.$("DESCR")];
  }, ""], [null, "AEQL", function () {
    return [vm.$("WCL"), vm.$("WPTR"), vm.$("CNVTA3")];
  }, "E3.2.3"], [null, "GETDC", function () {
    return [vm.$("WPTR"), vm.$("WCL"), 2 * vm.$("DESCR")];
  }, "E3.2.3"], [null, "AEQLC", function () {
    return [vm.$("WPTR"), 1, vm.$("CNVTA8")];
  }, "E3.8.1"], [null, "SETAC", function () {
    return [vm.$("TPTR"), 0];
  }, "E3.8.1"], [null, "BRANCH", function () {
    return [vm.$("RTZPTR")];
  }, "E3.8.1"], ["CNVAT", "GETDC", function () {
    return [vm.$("XCL"), vm.$("ZPTR"), 2 * vm.$("DESCR")];
  }, "Get array dimensionality"], [null, "MOVD", function () {
    return [vm.$("YPTR"), vm.$("ZPTR")];
  }, "Save copy of array pointer"], [null, "AEQLC", function () {
    return [vm.$("XCL"), 2, vm.$("FAIL")];
  }, "Verify rectangular array"], [null, "GETDC", function () {
    return [vm.$("XCL"), vm.$("ZPTR"), 3 * vm.$("DESCR")];
  }, "Get second dimension"], [null, "VEQLC", function () {
    return [vm.$("XCL"), 2, vm.$("FAIL")];
  }, "Verify extent of 2"], [null, "GETSIZ", function () {
    return [vm.$("XCL"), vm.$("ZPTR")];
  }, "Get size of array block"], [null, "DECRA", function () {
    return [vm.$("XCL"), 2 * vm.$("DESCR")];
  }, "E3.2.3"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("BLOCK"), vm.$("XCL")];
  }, "Allocate block for pair list"], [null, "SETVC", function () {
    return [vm.$("XPTR"), vm.$("T")];
  }, "E3.2.3"], [null, "GETDC", function () {
    return [vm.$("YCL"), vm.$("ZPTR"), 4 * vm.$("DESCR")];
  }, "E3.2.3"], [null, "MOVD", function () {
    return [vm.$("ZPTR"), vm.$("XPTR")];
  }, "E3.2.3"], [null, "PUTD", function () {
    return [vm.$("XPTR"), vm.$("XCL"), vm.$("ONECL")];
  }, "E3.2.3"], [null, "DECRA", function () {
    return [vm.$("XCL"), vm.$("DESCR")];
  }, "E3.2.3"], [null, "MOVD", function () {
    return [vm.$("TCL"), vm.$("EXTVAL")];
  }, "E3.2.3"], [null, "INCRA", function () {
    return [vm.$("TCL"), 2 * vm.$("DESCR")];
  }, "E3.2.3"], [null, "PUTD", function () {
    return [vm.$("XPTR"), vm.$("XCL"), vm.$("TCL")];
  }, "E3.2.3"], [null, "SETAV", function () {
    return [vm.$("YCL"), vm.$("YCL")];
  }, "E3.2.3"], [null, "MULTC", function () {
    return [vm.$("YCL"), vm.$("YCL"), vm.$("DESCR")];
  }, "E3.2.3"], [null, "INCRA", function () {
    return [vm.$("YPTR"), 5 * vm.$("DESCR")];
  }, "E3.2.3"], [null, "SUM", function () {
    return [vm.$("WPTR"), vm.$("YPTR"), vm.$("YCL")];
  }, "E3.2.3"], ["CNVAT2", "MOVDIC", function () {
    return [vm.$("XPTR"), vm.$("DESCR"), vm.$("WPTR"), 0];
  }, "E3.2.3"], [null, "MOVDIC", function () {
    return [vm.$("XPTR"), 2 * vm.$("DESCR"), vm.$("YPTR"), 0];
  }, "E3.2.3"], [null, "DECRA", function () {
    return [vm.$("YCL"), vm.$("DESCR")];
  }, "E3.2.3"], [null, "AEQLC", function () {
    return [vm.$("YCL"), 0, null, vm.$("RTZPTR")];
  }, "E3.2.3"], [null, "INCRA", function () {
    return [vm.$("XPTR"), 2 * vm.$("DESCR")];
  }, "Increment pair list pointer"], [null, "INCRA", function () {
    return [vm.$("WPTR"), vm.$("DESCR")];
  }, "Increment lower array pointer"], [null, "INCRA", function () {
    return [vm.$("YPTR"), vm.$("DESCR")];
  }, "Increment upper array pointer"], [null, "BRANCH", function () {
    return [vm.$("CNVAT2")];
  }, "Continue"], ["DATE", "PROC", function () {
    return [null];
  }, "DATE()"], [null, "RCALL", function () {
    return [null, vm.$("ARGVAL"), null, vm.$("FAIL")];
  }, "Get rid of argument"], [null, "DATE", function () {
    return [vm.$("ZSP")];
  }, "Get the date"], [null, "BRANCH", function () {
    return [vm.$("GENVRZ")];
  }, "Go generate the variable"], ["DT", "PROC", function () {
    return [null];
  }, "DATATYPE(X)"], [null, "RCALL", function () {
    return [vm.$("A2PTR"), vm.$("ARGVAL"), null, vm.$("FAIL")];
  }, "Get object"], [null, "MOVV", function () {
    return [vm.$("DT1CL"), vm.$("A2PTR")];
  }, "Insert data type"], [null, "LOCAPT", function () {
    return [vm.$("A3PTR"), vm.$("DTATL"), vm.$("DT1CL"), vm.$("DTEXTN")];
  }, ""], [null, "GETDC", function () {
    return [vm.$("A3PTR"), vm.$("A3PTR"), 2 * vm.$("DESCR")];
  }, "Get data type name"], ["DTRTN", "RRTURN", function () {
    return [vm.$("A3PTR"), 3];
  }, "Return name"], ["DTEXTN", "MOVD", function () {
    return [vm.$("A3PTR"), vm.$("EXTPTR")];
  }, "Set up EXTERNAL data type"], [null, "BRANCH", function () {
    return [vm.$("DTRTN")];
  }, "Return"], ["DMP", "PROC", function () {
    return [null];
  }, "DUMP(N)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("INTVAL"), null, vm.$("FAIL")];
  }, "Evaluate argument"], [null, "AEQLC", function () {
    return [vm.$("XPTR"), 0, null, vm.$("RETNUL")];
  }, "No dump if zero"], ["DUMP", "PROC", function () {
    return [vm.$("DMP")];
  }, "End game dump procedure"], [null, "SETAC", function () {
    return [vm.$("WPTR"), vm.$("OBLIST") - vm.$("DESCR")];
  }, "Initialize bin list pointer"], ["DMPB", "ACOMP", function () {
    return [vm.$("WPTR"), vm.$("OBEND"), vm.$("RETNUL")];
  }, "Check for end"], [null, "INCRA", function () {
    return [vm.$("WPTR"), vm.$("DESCR")];
  }, "Increment pointer"], [null, "MOVD", function () {
    return [vm.$("YPTR"), vm.$("WPTR")];
  }, "Save working copy"], ["DMPA", "GETAC", function () {
    return [vm.$("YPTR"), vm.$("YPTR"), vm.$("LNKFLD")];
  }, "Get string structure"], [null, "AEQLC", function () {
    return [vm.$("YPTR"), 0, null, vm.$("DMPB")];
  }, "Check for end of chain"], [null, "GETDC", function () {
    return [vm.$("XPTR"), vm.$("YPTR"), vm.$("DESCR")];
  }, "Get value"], [null, "DEQL", function () {
    return [vm.$("XPTR"), vm.$("NULVCL"), null, vm.$("DMPA")];
  }, "Skip null string values"], [null, "SETLC", function () {
    return [vm.$("DMPSP"), 0];
  }, "Clear specifier"], [null, "LOCSP", function () {
    return [vm.$("YSP"), vm.$("YPTR")];
  }, "Get specifier for variable"], [null, "GETLG", function () {
    return [vm.$("YCL"), vm.$("YSP")];
  }, "Get length"], [null, "ACOMPC", function () {
    return [vm.$("YCL"), vm.$("BUFLEN"), vm.$("DMPOVR"), vm.$("DMPOVR")];
  }, ""], [null, "APDSP", function () {
    return [vm.$("DMPSP"), vm.$("YSP")];
  }, "Append variable"], [null, "APDSP", function () {
    return [vm.$("DMPSP"), vm.$("BLEQSP")];
  }, "Append ' = '"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("S"), null, vm.$("DMPV")];
  }, "STRING is alright"], [null, "VEQLC", function () {
    return [vm.$("XPTR"), vm.$("I"), null, vm.$("DMPI")];
  }, "Convert INTEGER"], [null, "RCALL", function () {
    return [vm.$("A1PTR"), vm.$("DTREP"), vm.$("XPTR")];
  }, "Else get representation"], [null, "GETSPC", function () {
    return [vm.$("YSP"), vm.$("A1PTR"), 0];
  }, "Get specifier"], ["DMPX", "GETLG", function () {
    return [vm.$("XCL"), vm.$("YSP")];
  }, "Get length"], [null, "SUM", function () {
    return [vm.$("YCL"), vm.$("YCL"), vm.$("XCL")];
  }, "Get total"], [null, "ACOMPC", function () {
    return [vm.$("YCL"), vm.$("BUFLEN"), vm.$("DMPOVR")];
  }, "Check for excessive length"], [null, "APDSP", function () {
    return [vm.$("DMPSP"), vm.$("YSP")];
  }, "Append value"], [null, "BRANCH", function () {
    return [vm.$("DMPRT")];
  }, "Go print it"], ["DMPV", "LOCSP", function () {
    return [vm.$("YSP"), vm.$("XPTR")];
  }, "Get specifier"], [null, "GETLG", function () {
    return [vm.$("XCL"), vm.$("YSP")];
  }, "Get length"], [null, "SUM", function () {
    return [vm.$("YCL"), vm.$("YCL"), vm.$("XCL")];
  }, "Total length"], [null, "ACOMPC", function () {
    return [vm.$("YCL"), vm.$("BUFLEN"), vm.$("DMPOVR")];
  }, "Check for excessive length"], [null, "APDSP", function () {
    return [vm.$("DMPSP"), vm.$("QTSP")];
  }, "Append quote"], [null, "APDSP", function () {
    return [vm.$("DMPSP"), vm.$("YSP")];
  }, "Append value"], [null, "APDSP", function () {
    return [vm.$("DMPSP"), vm.$("QTSP")];
  }, "Append quote"], ["DMPRT", "STPRNT", function () {
    return [vm.$("IOKEY"), vm.$("OUTBLK"), vm.$("DMPSP")];
  }, "Print line"], [null, "BRANCH", function () {
    return [vm.$("DMPA")];
  }, "Continue"], ["DMPI", "INTSPC", function () {
    return [vm.$("YSP"), vm.$("XPTR")];
  }, "Convert integer"], [null, "BRANCH", function () {
    return [vm.$("DMPX")];
  }, "Rejoin processing"], ["DMPOVR", "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("PRTOVF")];
  }, "Print error message"], [null, "BRANCH", function () {
    return [vm.$("DMPA")];
  }, "Continue"], ["DMK", "PROC", function () {
    return [null];
  }, "Procedure to dump keywords"], [null, "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("PKEYF")];
  }, "Print caption"], [null, "GETSIZ", function () {
    return [vm.$("XCL"), vm.$("KNLIST")];
  }, "Get size of pair list"], ["DMPK1", "GETD", function () {
    return [vm.$("XPTR"), vm.$("KNLIST"), vm.$("XCL")];
  }, "Get name of keyword"], [null, "DECRA", function () {
    return [vm.$("XCL"), vm.$("DESCR")];
  }, "Adjust offset"], [null, "GETD", function () {
    return [vm.$("YPTR"), vm.$("KNLIST"), vm.$("XCL")];
  }, "Get value of keyword"], [null, "INTSPC", function () {
    return [vm.$("YSP"), vm.$("YPTR")];
  }, "Convert integer to string"], [null, "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier"], [null, "SETLC", function () {
    return [vm.$("DMPSP"), 0];
  }, "Clear specifier"], [null, "APDSP", function () {
    return [vm.$("DMPSP"), vm.$("AMPSP")];
  }, "Append ampersand"], [null, "APDSP", function () {
    return [vm.$("DMPSP"), vm.$("XSP")];
  }, "Append name"], [null, "APDSP", function () {
    return [vm.$("DMPSP"), vm.$("BLEQSP")];
  }, "Append ' = '"], [null, "APDSP", function () {
    return [vm.$("DMPSP"), vm.$("YSP")];
  }, "Append value"], [null, "STPRNT", function () {
    return [vm.$("IOKEY"), vm.$("OUTBLK"), vm.$("DMPSP")];
  }, "Print line"], [null, "DECRA", function () {
    return [vm.$("XCL"), vm.$("DESCR")];
  }, "Adjust offset"], [null, "AEQLC", function () {
    return [vm.$("XCL"), 0, vm.$("DMPK1"), vm.$("RTN1")];
  }, "Check for end"], ["DUPL", "PROC", function () {
    return [null];
  }, "DUPL(S,N)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get string to duplicate"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save string"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("INTVAL"), null, vm.$("FAIL")];
  }, "Get duplication factor"], [null, "POP", function () {
    return [vm.$("XPTR")];
  }, "Restore string"], [null, "ACOMPC", function () {
    return [vm.$("YPTR"), 0, null, vm.$("RETNUL"), vm.$("FAIL")];
  }, "Return null for 0 duplications"], [null, "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier"], [null, "GETLG", function () {
    return [vm.$("XCL"), vm.$("XSP")];
  }, "Get length"], [null, "MULT", function () {
    return [vm.$("XCL"), vm.$("XCL"), vm.$("YPTR"), vm.$("AERROR")];
  }, "E3.9.3"], [null, "ACOMP", function () {
    return [vm.$("XCL"), vm.$("MLENCL"), vm.$("INTR8")];
  }, "Check &MAXLNGTH"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("CONVAR"), vm.$("XCL")];
  }, "Allocate space for string"], [null, "LOCSP", function () {
    return [vm.$("TSP"), vm.$("ZPTR")];
  }, "Get specifier"], [null, "SETLC", function () {
    return [vm.$("TSP"), 0];
  }, "Zero length"], ["DUPL1", "APDSP", function () {
    return [vm.$("TSP"), vm.$("XSP")];
  }, "Append a copy"], [null, "DECRA", function () {
    return [vm.$("YPTR"), 1];
  }, "Count down"], [null, "AEQLC", function () {
    return [vm.$("YPTR"), 0, vm.$("DUPL1"), vm.$("GENVSZ")];
  }, "Check for end"], ["OPSYN", "PROC", function () {
    return [null];
  }, "OPSYN(F,G,N)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get object function"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save object function"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get image function"], [null, "PUSH", function () {
    return [vm.$("YPTR")];
  }, "Save image function"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("INTVAL"), null, vm.$("FAIL")];
  }, "Get type indicator"], [null, "POP", function () {
    return [[vm.$("YPTR"), vm.$("XPTR")]];
  }, "Restore image and object functions"], [null, "AEQLC", function () {
    return [vm.$("XPTR"), 0, null, vm.$("NONAME")];
  }, "Object may not be null"], [null, "AEQLC", function () {
    return [vm.$("ZPTR"), 1, null, vm.$("UNYOP")];
  }, "Check for unary definition"], [null, "AEQLC", function () {
    return [vm.$("ZPTR"), 2, null, vm.$("BNYOP")];
  }, "Check for binary definition"], [null, "AEQLC", function () {
    return [vm.$("ZPTR"), 0, vm.$("INTR30")];
  }, "Check for function definition"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("FINDEX"), vm.$("XPTR")];
  }, "Get function descriptor for object"], ["UNBF", "RCALL", function () {
    return [vm.$("YPTR"), vm.$("FINDEX"), vm.$("YPTR")];
  }, "E3.6.2"], ["OPPD", "MOVDIC", function () {
    return [vm.$("XPTR"), 0, vm.$("YPTR"), 0];
  }, "Move procedure descriptor pair"], [null, "MOVDIC", function () {
    return [vm.$("XPTR"), vm.$("DESCR"), vm.$("YPTR"), vm.$("DESCR")];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("RETNUL")];
  }, ""], ["UNYOP", "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier for image"], [null, "LEQLC", function () {
    return [vm.$("XSP"), 1, vm.$("UNAF")];
  }, "Length must be 1 for operator"], [null, "SETSP", function () {
    return [vm.$("ZSP"), vm.$("PROTSP")];
  }, "E3.5.3"], [null, "SETLC", function () {
    return [vm.$("ZSP"), 0];
  }, "E3.5.3"], [null, "APDSP", function () {
    return [vm.$("ZSP"), vm.$("XSP")];
  }, "E3.5.3"], [null, "APDSP", function () {
    return [vm.$("ZSP"), vm.$("LPRNSP")];
  }, "E3.5.3"], [null, "STREAM", function () {
    return [vm.$("TSP"), vm.$("ZSP"), vm.$("UNOPTB"), vm.$("UNAF"), vm.$("UNAF")];
  }, "E3.5.3"], [null, "MOVD", function () {
    return [vm.$("XPTR"), vm.$("STYPE")];
  }, "STYPE has function descriptor"], ["UNCF", "LOCSP", function () {
    return [vm.$("YSP"), vm.$("YPTR")];
  }, "Get specifier for image"], [null, "LEQLC", function () {
    return [vm.$("YSP"), 1, vm.$("UNBF")];
  }, "Length must be 1 for operator"], [null, "SETSP", function () {
    return [vm.$("ZSP"), vm.$("PROTSP")];
  }, "E3.5.3"], [null, "SETLC", function () {
    return [vm.$("ZSP"), 0];
  }, "E3.5.3"], [null, "APDSP", function () {
    return [vm.$("ZSP"), vm.$("YSP")];
  }, "E3.5.3"], [null, "APDSP", function () {
    return [vm.$("ZSP"), vm.$("LPRNSP")];
  }, "E3.5.3"], [null, "STREAM", function () {
    return [vm.$("TSP"), vm.$("ZSP"), vm.$("UNOPTB"), vm.$("UNBF"), vm.$("UNBF")];
  }, "E3.5.3"], [null, "MOVD", function () {
    return [vm.$("YPTR"), vm.$("STYPE")];
  }, "STYPE has function descriptor"], [null, "BRANCH", function () {
    return [vm.$("OPPD")];
  }, "Join to copy descriptors"], ["UNAF", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("FINDEX"), vm.$("XPTR")];
  }, "Find definition of image"], [null, "BRANCH", function () {
    return [vm.$("UNCF")];
  }, "Join search for object"], ["BNYOP", "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier for image"], [null, "LCOMP", function () {
    return [vm.$("XSP"), vm.$("EQLSP"), vm.$("BNAF")];
  }, "Length must be 2 or less"], [null, "SETSP", function () {
    return [vm.$("ZSP"), vm.$("PROTSP")];
  }, "E3.5.3"], [null, "SETLC", function () {
    return [vm.$("ZSP"), 0];
  }, "E3.5.3"], [null, "APDSP", function () {
    return [vm.$("ZSP"), vm.$("XSP")];
  }, "E3.5.3"], [null, "APDSP", function () {
    return [vm.$("ZSP"), vm.$("BLSP")];
  }, "E3.5.3"], [null, "STREAM", function () {
    return [vm.$("TSP"), vm.$("ZSP"), vm.$("BIOPTB"), vm.$("BNAF"), vm.$("BNAF")];
  }, "E3.5.3"], [null, "LEQLC", function () {
    return [vm.$("ZSP"), 0, vm.$("BNAF")];
  }, "E3.5.3"], [null, "MOVD", function () {
    return [vm.$("XPTR"), vm.$("STYPE")];
  }, "STYPE has function descriptor"], ["BNCF", "LOCSP", function () {
    return [vm.$("YSP"), vm.$("YPTR")];
  }, "Get specifier for object"], [null, "LCOMP", function () {
    return [vm.$("YSP"), vm.$("EQLSP"), vm.$("BNBF")];
  }, "Length must be 2 or less"], [null, "SETSP", function () {
    return [vm.$("ZSP"), vm.$("PROTSP")];
  }, "E3.5.3"], [null, "SETLC", function () {
    return [vm.$("ZSP"), 0];
  }, "E3.5.3"], [null, "APDSP", function () {
    return [vm.$("ZSP"), vm.$("YSP")];
  }, "E3.5.3"], [null, "APDSP", function () {
    return [vm.$("ZSP"), vm.$("BLSP")];
  }, "E3.5.3"], [null, "STREAM", function () {
    return [vm.$("TSP"), vm.$("ZSP"), vm.$("BIOPTB"), vm.$("BNBF"), vm.$("BNBF")];
  }, "E3.5.3"], [null, "LEQLC", function () {
    return [vm.$("ZSP"), 0, vm.$("BNBF")];
  }, "E3.5.3"], [null, "MOVD", function () {
    return [vm.$("YPTR"), vm.$("STYPE")];
  }, "STYPE has function descriptor"], [null, "BRANCH", function () {
    return [vm.$("OPPD")];
  }, "Join to copy descriptors"], ["BNAF", "LEXCMP", function () {
    return [vm.$("XSP"), vm.$("BLSP"), null, vm.$("BNCN")];
  }, "Check for concatenation"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("FINDEX"), vm.$("XPTR")];
  }, "Find definition of image"], [null, "BRANCH", function () {
    return [vm.$("BNCF")];
  }, "Join search for object"], ["BNCN", "MOVD", function () {
    return [vm.$("XPTR"), vm.$("CONCL")];
  }, "CONCL represents concatenation"], [null, "BRANCH", function () {
    return [vm.$("BNCF")];
  }, "Join search for object"], ["BNBF", "LEXCMP", function () {
    return [vm.$("YSP"), vm.$("BLSP"), vm.$("UNBF"), null, vm.$("UNBF")];
  }, "Check for concatenation"], [null, "MOVD", function () {
    return [vm.$("YPTR"), vm.$("CONCL")];
  }, "CONCL represents concatenation"], [null, "BRANCH", function () {
    return [vm.$("OPPD")];
  }, "Join to copy descriptors"], ["RPLACE", "PROC", function () {
    return [null];
  }, "REPLACE(S1,S2,S3)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get first argument"], [null, "PUSH", function () {
    return [vm.$("XPTR")];
  }, "Save first argument"], [null, "RCALL", function () {
    return [vm.$("YPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get second argument"], [null, "PUSH", function () {
    return [vm.$("YPTR")];
  }, "Save second argument"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get third argument"], [null, "POP", function () {
    return [[vm.$("YPTR"), vm.$("XPTR")]];
  }, "Restore first and second"], [null, "AEQLC", function () {
    return [vm.$("XPTR"), 0, null, vm.$("RTXPTR")];
  }, "Ignore replacement on null"], [null, "LOCSP", function () {
    return [vm.$("YSP"), vm.$("YPTR")];
  }, "Get specifier for second"], [null, "LOCSP", function () {
    return [vm.$("ZSP"), vm.$("ZPTR")];
  }, "Get specifier for third"], [null, "LCOMP", function () {
    return [vm.$("ZSP"), vm.$("YSP"), vm.$("FAIL"), null, vm.$("FAIL")];
  }, "Verify same lengths"], [null, "AEQLC", function () {
    return [vm.$("YPTR"), 0, null, vm.$("FAIL")];
  }, "Ignore null replacement"], [null, "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier for first"], [null, "GETLG", function () {
    return [vm.$("XCL"), vm.$("XSP")];
  }, "Get length"], [null, "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("CONVAR"), vm.$("XCL")];
  }, "Allocate space for result"], [null, "LOCSP", function () {
    return [vm.$("TSP"), vm.$("ZPTR")];
  }, "Get specifier"], [null, "SETLC", function () {
    return [vm.$("TSP"), 0];
  }, "Clear specifier"], [null, "APDSP", function () {
    return [vm.$("TSP"), vm.$("XSP")];
  }, "Append first argument"], [null, "RPLACE", function () {
    return [vm.$("TSP"), vm.$("YSP"), vm.$("ZSP")];
  }, "Perform replacement"], [null, "BRANCH", function () {
    return [vm.$("GENVSZ")];
  }, "Got generate variable"], ["SIZE", "PROC", function () {
    return [null];
  }, "SIZE(S)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get argument"], [null, "LOCSP", function () {
    return [vm.$("XSP"), vm.$("XPTR")];
  }, "Get specifier"], [null, "GETLG", function () {
    return [vm.$("ZPTR"), vm.$("XSP")];
  }, "Get length"], [null, "SETVC", function () {
    return [vm.$("ZPTR"), vm.$("I")];
  }, "Insert INTEGER data type"], [null, "BRANCH", function () {
    return [vm.$("RTZPTR")];
  }, "Return length"], ["TIME", "PROC", function () {
    return [null];
  }, "TIME()"], [null, "RCALL", function () {
    return [null, vm.$("ARGVAL"), null, vm.$("FAIL")];
  }, "Get rid of argument"], [null, "MSTIME", function () {
    return [vm.$("ZPTR")];
  }, "Get elapsed time"], [null, "SUBTRT", function () {
    return [vm.$("ZPTR"), vm.$("ZPTR"), vm.$("ETMCL")];
  }, "Compute time in interpreter"], [null, "SETVC", function () {
    return [vm.$("ZPTR"), vm.$("I")];
  }, "Insert INTEGER data type"], [null, "BRANCH", function () {
    return [vm.$("RTZPTR")];
  }, "Return time"], ["TRIM", "PROC", function () {
    return [null];
  }, "TRIM(S)"], [null, "RCALL", function () {
    return [vm.$("XPTR"), vm.$("VARVAL"), null, vm.$("FAIL")];
  }, "Get string"], [null, "LOCSP", function () {
    return [vm.$("ZSP"), vm.$("XPTR")];
  }, "Get specifier"], [null, "TRIMSP", function () {
    return [vm.$("ZSP"), vm.$("ZSP")];
  }, "Trim string"], [null, "BRANCH", function () {
    return [vm.$("GENVRZ")];
  }, "Generate new variable"], [null, "TITLE", function () {
    return ["Common Code"];
  }, ""], ["DATA", "LHERE", function () {
    return [null];
  }, ""], ["RT1NUL", "RRTURN", function () {
    return [vm.$("NULVCL"), 1];
  }, "Return null string by exit 1"], ["RTN1", "LHERE", function () {
    return [null];
  }, ""], ["FAIL", "RRTURN", function () {
    return [null, 1];
  }, "Return by exit 1"], ["RETNUL", "RRTURN", function () {
    return [vm.$("NULVCL"), 3];
  }, "Return null string by exit 3"], ["RTN2", "RRTURN", function () {
    return [null, 2];
  }, "Return by exit 2"], ["RTN3", "LHERE", function () {
    return [null];
  }, ""], ["RTNUL3", "RRTURN", function () {
    return [null, 3];
  }, "Return by exit 3"], ["RTXNAM", "RRTURN", function () {
    return [vm.$("XPTR"), 2];
  }, "Return XPTR by exit 2"], ["RTXPTR", "RRTURN", function () {
    return [vm.$("XPTR"), 3];
  }, "Return XPTR by exit 3"], ["RTYPTR", "RRTURN", function () {
    return [vm.$("YPTR"), 3];
  }, "Return YPTR by exit 3"], ["ARTN", "INCRA", function () {
    return [vm.$("ARTHCL"), 1];
  }, "Increment count of arithmetic"], ["RTZPTR", "RRTURN", function () {
    return [vm.$("ZPTR"), 3];
  }, "Return ZPTR by exit 3"], ["A5RTN", "RRTURN", function () {
    return [vm.$("A5PTR"), 1];
  }, "Return A5PTR by exit 1"], ["TSALF", "BRANCH", function () {
    return [vm.$("SALF"), vm.$("SCNR")];
  }, "Branch to SALF in scanner"], ["TSALT", "BRANCH", function () {
    return [vm.$("SALT"), vm.$("SCNR")];
  }, "Branch to SALT in scanner"], ["TSCOK", "BRANCH", function () {
    return [vm.$("SCOK"), vm.$("SCNR")];
  }, "Branch to SCOK in scanner"], ["GENVSZ", "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("GNVARS"), vm.$("XCL"), vm.$("RTZPTR")];
  }, ""], ["GENVRZ", "RCALL", function () {
    return [vm.$("ZPTR"), vm.$("GENVAR"), vm.$("ZSPPTR"), vm.$("RTZPTR")];
  }, ""], ["GENVIX", "RCALL", function () {
    return [vm.$("XPTR"), vm.$("GNVARI"), vm.$("XPTR"), vm.$("RTXNAM")];
  }, ""], [null, "TITLE", function () {
    return ["Termination"];
  }, ""], ["END", "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("NRMEND"), [vm.$("LVLCL")]];
  }, ""], [null, "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("LASTSF"), [vm.$("STNOCL")]];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("FTLEN2")];
  }, "Join termination procedure"], ["FTLEND", "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("FTLCF"), [vm.$("ERRTYP"), vm.$("STNOCL"), vm.$("LVLCL")]];
  }, "V3.7"], [null, "AEQLC", function () {
    return [vm.$("INICOM"), 0, vm.$("FTLEN3")];
  }, "BE SURE OF INITIALIZATION\tE3.10.6"], [null, "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("ALOCFL")];
  }, "WARN USER\t\t\tE3.10.6"], [null, "BRANCH", function () {
    return [vm.$("ENDALL")];
  }, "GET OUT\t\t\tE3.10.6"], ["FTLEN3", "MULTC", function () {
    return [vm.$("YCL"), vm.$("ERRTYP"), vm.$("DESCR")];
  }, "E3.10.6"], [null, "GETD", function () {
    return [vm.$("YCL"), vm.$("MSGNO"), vm.$("YCL")];
  }, "Get message pointer"], [null, "GETSPC", function () {
    return [vm.$("TSP"), vm.$("YCL"), 0];
  }, "Get message specifier"], [null, "STPRNT", function () {
    return [vm.$("IOKEY"), vm.$("OUTBLK"), vm.$("TSP")];
  }, "Print error message"], ["FTLEN2", "ISTACK", function () {
    return [null];
  }, "Reset system stack"], [null, "AEQLC", function () {
    return [vm.$("ETMCL"), 0, vm.$("FTLEN4")];
  }, "Was compiler done?"], [null, "MSTIME", function () {
    return [vm.$("ETMCL")];
  }, "Time out compiler"], [null, "SUBTRT", function () {
    return [vm.$("TIMECL"), vm.$("ETMCL"), vm.$("TIMECL")];
  }, "Compute time in compiler"], [null, "SETAC", function () {
    return [vm.$("ETMCL"), 0];
  }, "Set interpreter time to 0"], [null, "BRANCH", function () {
    return [vm.$("FTLEN1")];
  }, "Join end game"], ["FTLEN4", "MSTIME", function () {
    return [vm.$("XCL")];
  }, "Time out interpreter"], [null, "SUBTRT", function () {
    return [vm.$("ETMCL"), vm.$("XCL"), vm.$("ETMCL")];
  }, "Compute time in interpreter"], ["FTLEN1", "AEQLC", function () {
    return [vm.$("DMPCL"), 0, null, vm.$("END1")];
  }, "Check &DUMP"], [null, "AEQLC", function () {
    return [vm.$("NODPCL"), 0, vm.$("DMPNO")];
  }, "Check storage condition"], [null, "ORDVST", function () {
    return [null];
  }, "Order string structures"], [null, "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("STDMP")];
  }, "Print dump title"], [null, "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("NVARF")];
  }, "Print subtitle"], [null, "RCALL", function () {
    return [null, vm.$("DUMP"), null, [vm.$("INTR10"), vm.$("INTR10"), vm.$("DMPK")]];
  }, ""], ["DMPNO", "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("INCGCF")];
  }, "Print disclaimer"], [null, "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("NODMPF")];
  }, "Print reason"], [null, "BRANCH", function () {
    return [vm.$("END1")];
  }, "Join end game"], ["DMPK", "RCALL", function () {
    return [null, vm.$("DMK")];
  }, "Dump keywords"], ["END1", "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("STATHD")];
  }, "Print statistics title"], [null, "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("CMTIME"), [vm.$("TIMECL")]];
  }, ""], [null, "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("INTIME"), [vm.$("ETMCL")]];
  }, ""], [null, "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("EXNO"), [vm.$("EXNOCL"), vm.$("FALCL")]];
  }, ""], [null, "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("ARTHNO"), [vm.$("ARTHCL")]];
  }, ""], [null, "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("SCANNO"), [vm.$("SCNCL")]];
  }, ""], [null, "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("STGENO"), [vm.$("GCNO")]];
  }, ""], [null, "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("READNO"), [vm.$("RSTAT")]];
  }, ""], [null, "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("WRITNO"), [vm.$("WSTAT")]];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("EXNOCL"), 0, vm.$("END2")];
  }, "Check for no interpretation"], [null, "INTRL", function () {
    return [vm.$("FCL"), vm.$("ZEROCL")];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("AVTIME")];
  }, "Join end game"], ["END2", "INTRL", function () {
    return [vm.$("EXNOCL"), vm.$("EXNOCL")];
  }, "Convert execution total tn REAL"], [null, "INTRL", function () {
    return [vm.$("XCL"), vm.$("ETMCL")];
  }, "Convert execution time to REAL"], [null, "DVREAL", function () {
    return [vm.$("FCL"), vm.$("XCL"), vm.$("EXNOCL")];
  }, "Compute average time"], ["AVTIME", "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("TIMEPS"), [vm.$("FCL")]];
  }, "Print average time"], ["ENDALL", "ENDEX", function () {
    return [vm.$("ABNDCL")];
  }, "E3.2.2"], ["SYSCUT", "OUTPUT", function () {
    return [vm.$("OUTPUT"), vm.$("SYSCMT"), [vm.$("STNOCL"), vm.$("LVLCL")]];
  }, ""], [null, "AEQLC", function () {
    return [vm.$("CUTNO"), 0, vm.$("ENDALL")];
  }, "E3.2.2"], [null, "SETAC", function () {
    return [vm.$("CUTNO"), 1];
  }, "E3.2.2"], [null, "BRANCH", function () {
    return [vm.$("FTLEN2")];
  }, "Join end game"], [null, "TITLE", function () {
    return ["Error Handling"];
  }, "\"%"], ["AERROR", "SETAC", function () {
    return [vm.$("ERRTYP"), 2];
  }, "Arithmetic error"], [null, "BRANCH", function () {
    return [vm.$("FTLTST")];
  }, ""], ["ALOC2", "SETAC", function () {
    return [vm.$("ERRTYP"), 20];
  }, "Storage exhausted"], [null, "BRANCH", function () {
    return [vm.$("FTLEND")];
  }, ""], ["ARGNER", "SETAC", function () {
    return [vm.$("ERRTYP"), 25];
  }, "Incorrect number of arguments"], [null, "BRANCH", function () {
    return [vm.$("FTLEND")];
  }, ""], ["INTR10", "LHERE", function () {
    return [null];
  }, ""], ["INTR13", "LHERE", function () {
    return [null];
  }, ""], ["COMP3", "SETAC", function () {
    return [vm.$("ERRTYP"), 17];
  }, "Program error"], [null, "BRANCH", function () {
    return [vm.$("FTLEND")];
  }, ""], ["COMP5", "SETAC", function () {
    return [vm.$("ERRTYP"), 11];
  }, "Reading error"], [null, "BRANCH", function () {
    return [vm.$("FTLTST")];
  }, ""], ["COMP7", "SETAC", function () {
    return [vm.$("ERRTYP"), 27];
  }, "Erroneous end statement"], [null, "BRANCH", function () {
    return [vm.$("FTLEND")];
  }, ""], ["COMP9", "SETAC", function () {
    return [vm.$("ERRTYP"), 26];
  }, "Compilation error limit"], [null, "DECRA", function () {
    return [vm.$("ESAICL"), vm.$("DESCR")];
  }, "Decrement error count"], [null, "BRANCH", function () {
    return [vm.$("FTLEND")];
  }, ""], ["EROR", "SETAC", function () {
    return [vm.$("ERRTYP"), 28];
  }, "Erroneous statement"], [null, "INCRA", function () {
    return [vm.$("OCICL"), vm.$("DESCR")];
  }, "Increment offset"], [null, "GETD", function () {
    return [vm.$("STNOCL"), vm.$("OCBSCL"), vm.$("OCICL")];
  }, "Get statement number"], [null, "BRANCH", function () {
    return [vm.$("FTLEND")];
  }, ""], ["EXEX", "SETAC", function () {
    return [vm.$("ERRTYP"), 22];
  }, "Exceeded &STLIMIT"], [null, "BRANCH", function () {
    return [vm.$("FTLEND")];
  }, ""], ["INTR1", "SETAC", function () {
    return [vm.$("ERRTYP"), 1];
  }, "Illegal data type"], [null, "BRANCH", function () {
    return [vm.$("FTLTST")];
  }, ""], ["INTR4", "SETAC", function () {
    return [vm.$("ERRTYP"), 24];
  }, "Erroneous goto"], [null, "BRANCH", function () {
    return [vm.$("FTLEND")];
  }, ""], ["INTR5", "SETAC", function () {
    return [vm.$("ERRTYP"), 19];
  }, "Failure in goto"], [null, "BRANCH", function () {
    return [vm.$("FTLEND")];
  }, ""], ["INTR8", "SETAC", function () {
    return [vm.$("ERRTYP"), 15];
  }, "Exceeded &MAXLNGTH"], [null, "BRANCH", function () {
    return [vm.$("FTLTST")];
  }, ""], ["INTR27", "SETAC", function () {
    return [vm.$("ERRTYP"), 13];
  }, "Excessive data types"], [null, "BRANCH", function () {
    return [vm.$("FTLTST")];
  }, ""], ["INTR30", "SETAC", function () {
    return [vm.$("ERRTYP"), 10];
  }, "Illegal argument"], [null, "BRANCH", function () {
    return [vm.$("FTLTST")];
  }, ""], ["INTR31", "SETAC", function () {
    return [vm.$("ERRTYP"), 16];
  }, "Overflow in pattern matching"], [null, "SETAC", function () {
    return [vm.$("SCERCL"), 3];
  }, ""], [null, "BRANCH", function () {
    return [vm.$("FTERST")];
  }, ""], ["LENERR", "SETAC", function () {
    return [vm.$("ERRTYP"), 14];
  }, "Negative number"], [null, "BRANCH", function () {
    return [vm.$("FTLTST")];
  }, ""], ["MAIN1", "SETAC", function () {
    return [vm.$("ERRTYP"), 18];
  }, "Return from level zero"], [null, "BRANCH", function () {
    return [vm.$("FTLEND")];
  }, ""], ["NEMO", "SETAC", function () {
    return [vm.$("ERRTYP"), 8];
  }, "Variable not present"], [null, "BRANCH", function () {
    return [vm.$("FTLTST")];
  }, ""], ["NONAME", "SETAC", function () {
    return [vm.$("ERRTYP"), 4];
  }, "Null string"], [null, "BRANCH", function () {
    return [vm.$("FTLTST")];
  }, ""], ["NONARY", "SETAC", function () {
    return [vm.$("ERRTYP"), 3];
  }, "Erroneous array or table reference"], [null, "BRANCH", function () {
    return [vm.$("FTLTST")];
  }, ""], ["OVER", "SETAC", function () {
    return [vm.$("ERRTYP"), 21];
  }, "Stack overflow"], [null, "BRANCH", function () {
    return [vm.$("FTLEND")];
  }, ""], ["PROTER", "SETAC", function () {
    return [vm.$("ERRTYP"), 6];
  }, "Erroneous prototype"], [null, "BRANCH", function () {
    return [vm.$("FTLTST")];
  }, ""], ["SCDTER", "SETAC", function () {
    return [vm.$("ERRTYP"), 1];
  }, "Illegal data type"], [null, "BRANCH", function () {
    return [vm.$("SCERST")];
  }, ""], ["SCLENR", "SETAC", function () {
    return [vm.$("ERRTYP"), 14];
  }, "Negative number"], [null, "BRANCH", function () {
    return [vm.$("SCERST")];
  }, ""], ["SCLNOR", "SETAC", function () {
    return [vm.$("ERRTYP"), 15];
  }, "String overflow"], [null, "BRANCH", function () {
    return [vm.$("SCERST")];
  }, ""], ["SCNAME", "SETAC", function () {
    return [vm.$("ERRTYP"), 4];
  }, "Null string"], [null, "BRANCH", function () {
    return [vm.$("SCERST")];
  }, ""], ["SCNEMO", "SETAC", function () {
    return [vm.$("ERRTYP"), 8];
  }, "E3.4.4"], [null, "BRANCH", function () {
    return [vm.$("SCERST")];
  }, "E3.4.4"], ["SIZERR", "SETAC", function () {
    return [vm.$("ERRTYP"), 23];
  }, "Object too large"], [null, "BRANCH", function () {
    return [vm.$("FTLEND")];
  }, ""], ["UNDF", "SETAC", function () {
    return [vm.$("ERRTYP"), 5];
  }, "Undefined function"], [null, "BRANCH", function () {
    return [vm.$("FTLTST")];
  }, ""], ["UNDFFE", "SETAC", function () {
    return [vm.$("ERRTYP"), 9];
  }, "Function entry point not label"], [null, "BRANCH", function () {
    return [vm.$("FTLTST")];
  }, ""], ["UNKNKW", "SETAC", function () {
    return [vm.$("ERRTYP"), 7];
  }, "Unknown keyword"], [null, "BRANCH", function () {
    return [vm.$("FTLTST")];
  }, ""], ["UNTERR", "SETAC", function () {
    return [vm.$("ERRTYP"), 12];
  }, "Illegal I/O unit"], [null, "BRANCH", function () {
    return [vm.$("FTLTST")];
  }, ""], ["SCERST", "SETAC", function () {
    return [vm.$("SCERCL"), 1];
  }, "Note failure during pattern matching"], [null, "BRANCH", function () {
    return [vm.$("FTERST")];
  }, ""], ["FTLTST", "SETAC", function () {
    return [vm.$("SCERCL"), 2];
  }, "Note failure out of pattern matching"], ["FTERST", "ACOMPC", function () {
    return [vm.$("ERRLCL"), 0, null, vm.$("FTLEND"), vm.$("FTLEND")];
  }, ""], [null, "DECRA", function () {
    return [vm.$("ERRLCL"), 1];
  }, "Decrement &ERRLIMIT"], [null, "ACOMPC", function () {
    return [vm.$("TRAPCL"), 0, null, vm.$("FTERBR"), vm.$("FTERBR")];
  }, ""], [null, "LOCAPT", function () {
    return [vm.$("ATPTR"), vm.$("TKEYL"), vm.$("ERRTKY"), vm.$("FTERBR")];
  }, ""], [null, "PUSH", function () {
    return [vm.$("SCERCL")];
  }, "E3.1.3"], [null, "RCALL", function () {
    return [null, vm.$("TRPHND"), vm.$("ATPTR")];
  }, "E3.3.1"], [null, "POP", function () {
    return [vm.$("SCERCL")];
  }, "E3.1.3"], ["FTERBR", "SELBRA", function () {
    return [vm.$("SCERCL"), [vm.$("TSALF"), vm.$("FAIL"), vm.$("RTNUL3")]];
  }, ""], [null, "TITLE", function () {
    return ["Data"];
  }, ""], ["DTLIST", "DESCR", function () {
    return [vm.$("DTLIST"), vm.$("TTL") + vm.$("MARK"), vm.$("DTLEND") - (vm.$("DTLIST") - vm.$("DESCR"))];
  }, ""], [null, "DESCR", function () {
    return [0, 0, vm.$("S")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("VARSP"), 0, 0];
  }, "STRING"], [null, "DESCR", function () {
    return [0, 0, vm.$("I")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("INTGSP"), 0, 0];
  }, "INTEGER"], [null, "DESCR", function () {
    return [0, 0, vm.$("P")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("PATSP"), 0, 0];
  }, "PATTERN"], [null, "DESCR", function () {
    return [0, 0, vm.$("A")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("ARRSP"), 0, 0];
  }, "ARRAY"], [null, "DESCR", function () {
    return [0, 0, vm.$("R")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("RLSP"), 0, 0];
  }, "REAL"], [null, "DESCR", function () {
    return [0, 0, vm.$("C")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("CODESP"), 0, 0];
  }, "CODE"], [null, "DESCR", function () {
    return [0, 0, vm.$("N")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("NAMESP"), 0, 0];
  }, "NAME"], [null, "DESCR", function () {
    return [0, 0, vm.$("K")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("NAMESP"), 0, 0];
  }, "NAME (for keyword)"], [null, "DESCR", function () {
    return [0, 0, vm.$("E")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("EXPSP"), 0, 0];
  }, "EXPRESSION"], [null, "DESCR", function () {
    return [0, 0, vm.$("T")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("ASSCSP"), 0, 0];
  }, "TABLE"], ["DTLEND", "LHERE", function () {
    return [null];
  }, ""], ["KNLIST", "DESCR", function () {
    return [vm.$("KNLIST"), vm.$("TTL") + vm.$("MARK"), vm.$("KNEND") - (vm.$("KNLIST") - vm.$("DESCR"))];
  }, ""], ["TRIMCL", "DESCR", function () {
    return [0, 0, vm.$("I")];
  }, "&TRIM"], [null, "DESCR", function () {
    return [vm.$("TRMSP"), 0, 0];
  }, ""], ["TRAPCL", "DESCR", function () {
    return [0, 0, vm.$("I")];
  }, "&TRACE"], [null, "DESCR", function () {
    return [vm.$("TRCESP"), 0, 0];
  }, ""], ["EXLMCL", "DESCR", function () {
    return [50000, 0, vm.$("I")];
  }, "&STLIMIT"], [null, "DESCR", function () {
    return [vm.$("STLMSP"), 0, 0];
  }, ""], ["OUTSW", "DESCR", function () {
    return [1, 0, vm.$("I")];
  }, "&OUTPUT"], [null, "DESCR", function () {
    return [vm.$("OUTSP"), 0, 0];
  }, ""], ["MLENCL", "DESCR", function () {
    return [5000, 0, vm.$("I")];
  }, "&MAXLNGTH"], [null, "DESCR", function () {
    return [vm.$("MAXLSP"), 0, 0];
  }, ""], ["INSW", "DESCR", function () {
    return [1, 0, vm.$("I")];
  }, "&INPUT"], [null, "DESCR", function () {
    return [vm.$("INSP"), 0, 0];
  }, ""], ["FULLCL", "DESCR", function () {
    return [0, 0, vm.$("I")];
  }, "&FULLSCAN"], [null, "DESCR", function () {
    return [vm.$("FULLSP"), 0, 0];
  }, ""], ["TRACL", "DESCR", function () {
    return [0, 0, vm.$("I")];
  }, "&FTRACE"], [null, "DESCR", function () {
    return [vm.$("FTRCSP"), 0, 0];
  }, ""], ["ERRLCL", "DESCR", function () {
    return [0, 0, vm.$("I")];
  }, "&ERRLIMIT"], [null, "DESCR", function () {
    return [vm.$("ERRLSP"), 0, 0];
  }, ""], ["DMPCL", "DESCR", function () {
    return [0, 0, vm.$("I")];
  }, "&DUMP"], [null, "DESCR", function () {
    return [vm.$("DUMPSP"), 0, 0];
  }, ""], ["RETCOD", "DESCR", function () {
    return [0, 0, vm.$("I")];
  }, "&CODE"], [null, "DESCR", function () {
    return [vm.$("CODESP"), 0, 0];
  }, ""], ["ANCCL", "DESCR", function () {
    return [0, 0, vm.$("I")];
  }, "&ANCHOR"], [null, "DESCR", function () {
    return [vm.$("ANCHSP"), 0, 0];
  }, ""], ["ABNDCL", "DESCR", function () {
    return [0, 0, vm.$("I")];
  }, "&ABEND"], [null, "DESCR", function () {
    return [vm.$("ABNDSP"), 0, 0];
  }, ""], ["KNEND", "LHERE", function () {
    return [null];
  }, ""], ["KVLIST", "DESCR", function () {
    return [vm.$("KVLIST"), vm.$("TTL") + vm.$("MARK"), vm.$("KVEND") - (vm.$("KVLIST") - vm.$("DESCR"))];
  }, ""], ["ERRTYP", "DESCR", function () {
    return [0, 0, vm.$("I")];
  }, "&ERRTYPE"], ["ERRTKY", "DESCR", function () {
    return [vm.$("ERRTSP"), 0, 0];
  }, ""], ["ARBPAT", "DESCR", function () {
    return [vm.$("ARBPT"), 0, vm.$("P")];
  }, "&ARB"], ["ARBKY", "DESCR", function () {
    return [vm.$("ARBSP"), 0, 0];
  }, ""], ["BALPAT", "DESCR", function () {
    return [vm.$("BALPT"), 0, vm.$("P")];
  }, "&BAL"], ["BALKY", "DESCR", function () {
    return [vm.$("BALSP"), 0, 0];
  }, ""], ["FNCPAT", "DESCR", function () {
    return [vm.$("FNCEPT"), 0, vm.$("P")];
  }, "&FENCE"], ["FNCEKY", "DESCR", function () {
    return [vm.$("FNCESP"), 0, 0];
  }, ""], ["ABOPAT", "DESCR", function () {
    return [vm.$("ABORPT"), 0, vm.$("P")];
  }, "&ABORT"], ["ABRTKY", "DESCR", function () {
    return [vm.$("ABORSP"), 0, 0];
  }, ""], ["FALPAT", "DESCR", function () {
    return [vm.$("FAILPT"), 0, vm.$("P")];
  }, "&FAIL"], ["FAILKY", "DESCR", function () {
    return [vm.$("FAILSP"), 0, 0];
  }, ""], ["REMPAT", "DESCR", function () {
    return [vm.$("REMPT"), 0, vm.$("P")];
  }, "&REM"], ["REMKY", "DESCR", function () {
    return [vm.$("REMSP"), 0, 0];
  }, ""], ["SUCPAT", "DESCR", function () {
    return [vm.$("SUCCPT"), 0, vm.$("P")];
  }, "&SUCCEED"], ["SUCCKY", "DESCR", function () {
    return [vm.$("SUCCSP"), 0, 0];
  }, ""], ["FALCL", "DESCR", function () {
    return [0, 0, vm.$("I")];
  }, "&STFCOUNT"], ["FALKY", "DESCR", function () {
    return [vm.$("STFCSP"), 0, 0];
  }, ""], ["LSTNCL", "DESCR", function () {
    return [0, 0, vm.$("I")];
  }, "&LASTNO"], [null, "DESCR", function () {
    return [vm.$("LSTNSP"), 0, 0];
  }, ""], ["RETPCL", "DESCR", function () {
    return [0, 0, vm.$("S")];
  }, "&RTNTYPE"], [null, "DESCR", function () {
    return [vm.$("RTYPSP"), 0, 0];
  }, ""], ["STNOCL", "DESCR", function () {
    return [0, 0, vm.$("I")];
  }, "&STNO"], [null, "DESCR", function () {
    return [vm.$("STNOSP"), 0, 0];
  }, ""], ["ALPHVL", "DESCR", function () {
    return [0, 0, 0];
  }, "&ALPHABET"], [null, "DESCR", function () {
    return [vm.$("ALNMSP"), 0, 0];
  }, ""], ["EXNOCL", "DESCR", function () {
    return [0, 0, vm.$("I")];
  }, "&STCOUNT"], ["STCTKY", "DESCR", function () {
    return [vm.$("STCTSP"), 0, 0];
  }, ""], ["LVLCL", "DESCR", function () {
    return [0, 0, vm.$("I")];
  }, "&FNCLEVEL"], ["FNCLKY", "DESCR", function () {
    return [vm.$("FNCLSP"), 0, 0];
  }, ""], ["KVEND", "LHERE", function () {
    return [null];
  }, ""], ["INLIST", "DESCR", function () {
    return [vm.$("INLIST"), vm.$("TTL") + vm.$("MARK"), 2 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("INPUT") - vm.$("DESCR"), 0, 0];
  }, "INPUT block"], [null, "DESCR", function () {
    return [vm.$("INSP"), 0, 0];
  }, ""], ["OTLIST", "DESCR", function () {
    return [vm.$("OTLIST"), vm.$("TTL") + vm.$("MARK"), 4 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("OUTPUT") - vm.$("DESCR"), 0, 0];
  }, "OUTPUT block"], [null, "DESCR", function () {
    return [vm.$("OUTSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("PUNCH") - vm.$("DESCR"), 0, 0];
  }, "PUNCH block"], [null, "DESCR", function () {
    return [vm.$("PNCHSP"), 0, 0];
  }, ""], ["OTSATL", "DESCR", function () {
    return [vm.$("OTSATL"), vm.$("TTL") + vm.$("MARK"), 4 * vm.$("DESCR")];
  }, ""], ["OUTPUT", "DESCR", function () {
    return [vm.$("UNITO"), 0, vm.$("I")];
  }, "OUTPUT unit"], [null, "DESCR", function () {
    return [vm.$("OUTPSP"), 0, 0];
  }, "OUTPUT format"], ["PUNCH", "DESCR", function () {
    return [vm.$("UNITP"), 0, vm.$("I")];
  }, "PUNCH unit"], ["PCHFST", "DESCR", function () {
    return [vm.$("CRDFSP"), 0, 0];
  }, "PUNCH format"], ["INSATL", "DESCR", function () {
    return [vm.$("INSATL"), vm.$("TTL") + vm.$("MARK"), 2 * vm.$("DESCR")];
  }, ""], ["INPUT", "DESCR", function () {
    return [vm.$("UNITI"), 0, vm.$("I")];
  }, "INPUT unit"], ["DFLSIZ", "DESCR", function () {
    return [80, 0, vm.$("I")];
  }, "INPUT length"], ["TRLIST", "DESCR", function () {
    return [vm.$("TRLIST"), vm.$("TTL") + vm.$("MARK"), 10 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("TVALL"), 0, 0];
  }, "VALUE trace"], ["VALTRS", "DESCR", function () {
    return [vm.$("VALSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("TLABL"), 0, 0];
  }, "LABEL trace"], [null, "DESCR", function () {
    return [vm.$("TRLASP"), 0, 0];
  }, ""], ["TFNCLP", "DESCR", function () {
    return [vm.$("TFENTL"), 0, 0];
  }, "CALL trace"], [null, "DESCR", function () {
    return [vm.$("TRFRSP"), 0, 0];
  }, ""], ["TFNRLP", "DESCR", function () {
    return [vm.$("TFEXTL"), 0, 0];
  }, "RETURN trace"], [null, "DESCR", function () {
    return [vm.$("RETSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("TKEYL"), 0, 0];
  }, "KEYWORD trace"], [null, "DESCR", function () {
    return [vm.$("TRKYSP"), 0, 0];
  }, ""], ["TRCBLK", "DESCR", function () {
    return [vm.$("TRCBLK"), vm.$("TTL") + vm.$("MARK"), 5 * vm.$("DESCR")];
  }, "V3.7"], [null, "DESCR", function () {
    return [0, vm.$("FNC"), 2];
  }, "TRACE FUNCTION DESCRIPTOR\tV3.7"], ["LIT1CL", "DESCR", function () {
    return [vm.$("LITFN"), vm.$("FNC"), 1];
  }, "LITERAL FUNCTION DESCRIPTOR\tE3.7.1"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, "VARIABLE TO BE TRACED\tV3.7"], [null, "DESCR", function () {
    return [vm.$("LITFN"), vm.$("FNC"), 1];
  }, "LITERAL FUNCTION DESCRIPTOR\tE3.7.1"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, "TAG SUPPLIED FOR TRACE\tV3.7"], ["ATRHD", "DESCR", function () {
    return [vm.$("ATPRCL") - vm.$("DESCR"), 0, 0];
  }, "Array header converting from TABLE"], ["ATPRCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Prototype"], [null, "DESCR", function () {
    return [2, 0, 0];
  }, "Dimensionality"], [null, "DESCR", function () {
    return [1, 0, 2];
  }, "1:2 second dimension"], ["ATEXCL", "DESCR", function () {
    return [1, 0, 0];
  }, "1:n first dimension"], ["ATDTP", "DESCR", function () {
    return [vm.$("A"), 0, vm.$("T")];
  }, "ARRAY-TABLE"], ["IIDTP", "DESCR", function () {
    return [vm.$("I"), 0, vm.$("I")];
  }, "INTEGER-INTEGER"], ["IPDTP", "DESCR", function () {
    return [vm.$("I"), 0, vm.$("P")];
  }, "INTEGER-PATTERN"], ["IRDTP", "DESCR", function () {
    return [vm.$("I"), 0, vm.$("R")];
  }, "INTEGER-REAL"], ["IVDTP", "DESCR", function () {
    return [vm.$("I"), 0, vm.$("S")];
  }, "INTEGER-STRING"], ["PIDTP", "DESCR", function () {
    return [vm.$("P"), 0, vm.$("I")];
  }, "PATTERN-INTEGER"], ["PPDTP", "DESCR", function () {
    return [vm.$("P"), 0, vm.$("P")];
  }, "PATTERN-PATTERN"], ["PVDTP", "DESCR", function () {
    return [vm.$("P"), 0, vm.$("S")];
  }, "PATTERN-STRING"], ["RIDTP", "DESCR", function () {
    return [vm.$("R"), 0, vm.$("I")];
  }, "REAL-INTEGER"], ["RPDTP", "DESCR", function () {
    return [vm.$("R"), 0, vm.$("P")];
  }, "REAL-PATTERN"], ["RRDTP", "DESCR", function () {
    return [vm.$("R"), 0, vm.$("R")];
  }, "REAL-REAL"], ["RVDTP", "DESCR", function () {
    return [vm.$("R"), 0, vm.$("S")];
  }, "REAL-STRING"], ["TADTP", "DESCR", function () {
    return [vm.$("T"), 0, vm.$("A")];
  }, "TABLE-ARRAY"], ["VCDTP", "DESCR", function () {
    return [vm.$("S"), 0, vm.$("C")];
  }, "STRING-CODE"], ["VEDTP", "DESCR", function () {
    return [vm.$("S"), 0, vm.$("E")];
  }, "STRING-EXPRESSION"], ["VIDTP", "DESCR", function () {
    return [vm.$("S"), 0, vm.$("I")];
  }, "STRING-INTEGER"], ["VPDTP", "DESCR", function () {
    return [vm.$("S"), 0, vm.$("P")];
  }, "STRING-PATTERN"], ["VRDTP", "DESCR", function () {
    return [vm.$("S"), 0, vm.$("R")];
  }, "STRING-REAL"], ["VVDTP", "DESCR", function () {
    return [vm.$("S"), 0, vm.$("S")];
  }, "STRING-STRING"], ["ARTHCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Number of arithmetic operations"], ["CSTNCL", "DESCR", function () {
    return [0, 0, vm.$("I")];
  }, "Compiler statement number"], ["RSTAT", "DESCR", function () {
    return [0, 0, 0];
  }, "Number of reads"], ["SCNCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Number of scanner entrances"], ["WSTAT", "DESCR", function () {
    return [0, 0, 0];
  }, "Number of writes"], ["TIMECL", "DESCR", function () {
    return [0, 0, 0];
  }, "Millisecond time"], ["ALCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Entry point switch for ARG(F,N)"], ["ARRMRK", "DESCR", function () {
    return [0, 0, 0];
  }, "Prototype end switch for ARRAY(P,V)"], ["CUTNO", "DESCR", function () {
    return [0, 0, 0];
  }, "E3.2.2"], ["CNSLCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Label redefinition switch"], ["DATACL", "DESCR", function () {
    return [0, 0, 0];
  }, "Prototype end switch for DATA(P)"], ["FNVLCL", "DESCR", function () {
    return [0, 0, 0];
  }, "FUNCTION-VALUE switch for trace"], ["INICOM", "DESCR", function () {
    return [0, 0, 0];
  }, "INITIALIZATION SWITCH\tE3.10.6"], ["LENFCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Length failure switch"], ["LISTCL", "DESCR", function () {
    return [1, 0, 0];
  }, "Compiler listing switch"], ["LLIST", "DESCR", function () {
    return [0, 0, 0];
  }, "Left listing switch"], ["NAMGCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Naming switch for SJSR"], ["SCERCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Error branch switch"], ["ARBSIZ", "DESCR", function () {
    return [8 * vm.$("NODESZ"), 0, 0];
  }, "Node size for ARBNO(P)"], ["CHARCL", "DESCR", function () {
    return [1, 0, 0];
  }, "Length constant 1"], ["CNDSIZ", "DESCR", function () {
    return [vm.$("CNODSZ"), 0, vm.$("B")];
  }, "Compiler node size"], ["CODELT", "DESCR", function () {
    return [200 * vm.$("DESCR"), 0, vm.$("C")];
  }, "Object code excess"], ["DSCRTW", "DESCR", function () {
    return [2 * vm.$("DESCR"), 0, 0];
  }, "Constant 2*DESCR"], ["EOSCL", "DESCR", function () {
    return [vm.$("EOSTYP"), 0, 0];
  }, "End of statement switch"], ["ESALIM", "DESCR", function () {
    return [vm.$("ESASIZ") * vm.$("DESCR"), 0, 0];
  }, "Bound on compilation errors"], ["EXTVAL", "DESCR", function () {
    return [vm.$("EXTSIZ") * (2 * vm.$("DESCR")), 0, 0];
  }, "V3.11"], ["FBLKRQ", "DESCR", function () {
    return [vm.$("FBLKSZ"), 0, vm.$("B")];
  }, "Quantum on allocated function blocks"], ["GOBRCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Goto break character switch"], ["GTOCL", "DESCR", function () {
    return [vm.$("FGOTYP"), 0, 0];
  }, "Goto decision switch"], ["IOBLSZ", "DESCR", function () {
    return [2 * vm.$("DESCR"), 0, vm.$("B")];
  }, "Size of I/O blocks"], ["LNODSZ", "DESCR", function () {
    return [vm.$("NODESZ") + vm.$("DESCR"), 0, vm.$("P")];
  }, "Size of long pattern node"], ["NODSIZ", "DESCR", function () {
    return [vm.$("NODESZ"), 0, vm.$("P")];
  }, "Size of short pattern node"], ["OBEND", "DESCR", function () {
    return [vm.$("OBLIST") + vm.$("DESCR") * vm.$("OBOFF"), 0, 0];
  }, ""], ["OCALIM", "DESCR", function () {
    return [vm.$("OCASIZ") * vm.$("DESCR"), 0, vm.$("C")];
  }, "Size of object code block"], ["ONECL", "DESCR", function () {
    return [1, 0, 0];
  }, "Constant 1"], ["OUTBLK", "DESCR", function () {
    return [vm.$("OUTPUT") - vm.$("DESCR"), 0, 0];
  }, "Pointer to OUTPUT block"], ["SIZLMT", "DESCR", function () {
    return [vm.$("SIZLIM"), 0, 0];
  }, "Limit on size of data object"], ["SNODSZ", "DESCR", function () {
    return [vm.$("NODESZ"), 0, vm.$("P")];
  }, "Small pattern node size"], ["STARSZ", "DESCR", function () {
    return [11 * vm.$("DESCR"), 0, vm.$("P")];
  }, "Size of EXPRESSION pattern"], ["ZEROCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Constant zero"], ["TRSKEL", "DESCR", function () {
    return [vm.$("TRCBLK"), 0, 0];
  }, ""], ["COMDCT", "DESCR", function () {
    return [14 * vm.$("DESCR"), 0, 0];
  }, ""], ["COMREG", "DESCR", function () {
    return [vm.$("ELEMND"), 0, 0];
  }, "Pointer to compiler descriptors"], ["ARBACK", "DESCR", function () {
    return [vm.$("ARBAK"), 0, vm.$("P")];
  }, ""], ["ARHEAD", "DESCR", function () {
    return [vm.$("ARHED"), 0, vm.$("P")];
  }, ""], ["ARTAIL", "DESCR", function () {
    return [vm.$("ARTAL"), 0, vm.$("P")];
  }, ""], ["STRPAT", "DESCR", function () {
    return [vm.$("STARPT"), 0, vm.$("P")];
  }, ""], ["ANYCCL", "DESCR", function () {
    return [vm.$("ANYCFN"), vm.$("FNC"), 3];
  }, ""], ["ASGNCL", "DESCR", function () {
    return [vm.$("ASGNFN"), vm.$("FNC"), 2];
  }, ""], ["ATOPCL", "DESCR", function () {
    return [vm.$("ATOPFN"), vm.$("FNC"), 3];
  }, ""], ["BASECL", "DESCR", function () {
    return [vm.$("BASEFN"), vm.$("FNC"), 0];
  }, ""], ["BRKCCL", "DESCR", function () {
    return [vm.$("BRKCFN"), vm.$("FNC"), 3];
  }, ""], ["CHRCL", "DESCR", function () {
    return [vm.$("CHRFN"), vm.$("FNC"), 3];
  }, ""], ["CONCL", "DESCR", function () {
    return [vm.$("CONFN"), vm.$("FNC"), 0];
  }, "Argument count is incremented"], ["DNMECL", "DESCR", function () {
    return [vm.$("DNMEFN"), vm.$("FNC"), 2];
  }, ""], ["DNMICL", "DESCR", function () {
    return [vm.$("DNMIFN"), vm.$("FNC"), 2];
  }, ""], ["ENDCL", "DESCR", function () {
    return [vm.$("ENDFN"), vm.$("FNC"), 0];
  }, ""], ["ENMECL", "DESCR", function () {
    return [vm.$("ENMEFN"), vm.$("FNC"), 3];
  }, ""], ["ENMICL", "DESCR", function () {
    return [vm.$("ENMIFN"), vm.$("FNC"), 3];
  }, ""], ["ERORCL", "DESCR", function () {
    return [vm.$("ERORFN"), vm.$("FNC"), 1];
  }, ""], ["FNCFCL", "DESCR", function () {
    return [vm.$("FNCFFN"), vm.$("FNC"), 2];
  }, ""], ["FNMECL", "DESCR", function () {
    return [vm.$("FNMEFN"), vm.$("FNC"), 2];
  }, ""], ["GOTGCL", "DESCR", function () {
    return [vm.$("GOTGFN"), vm.$("FNC"), 1];
  }, ""], ["GOTLCL", "DESCR", function () {
    return [vm.$("GOTLFN"), vm.$("FNC"), 1];
  }, ""], ["GOTOCL", "DESCR", function () {
    return [vm.$("GOTOFN"), vm.$("FNC"), 1];
  }, ""], ["INITCL", "DESCR", function () {
    return [vm.$("INITFN"), vm.$("FNC"), 1];
  }, ""], ["ITEMCL", "DESCR", function () {
    return [vm.$("AREFN"), vm.$("FNC"), 0];
  }, ""], ["LITCL", "DESCR", function () {
    return [vm.$("LITFN"), vm.$("FNC"), 0];
  }, "Argument count is incremented"], ["LNTHCL", "DESCR", function () {
    return [vm.$("LNTHFN"), vm.$("FNC"), 3];
  }, ""], ["NMECL", "DESCR", function () {
    return [vm.$("NMEFN"), vm.$("FNC"), 2];
  }, ""], ["NNYCCL", "DESCR", function () {
    return [vm.$("NNYCFN"), vm.$("FNC"), 3];
  }, ""], ["POSICL", "DESCR", function () {
    return [vm.$("POSIFN"), vm.$("FNC"), 3];
  }, ""], ["RPSICL", "DESCR", function () {
    return [vm.$("RPSIFN"), vm.$("FNC"), 3];
  }, ""], ["RTBCL", "DESCR", function () {
    return [vm.$("RTBFN"), vm.$("FNC"), 3];
  }, ""], ["SCANCL", "DESCR", function () {
    return [vm.$("SCANFN"), vm.$("FNC"), 2];
  }, ""], ["SCFLCL", "DESCR", function () {
    return [vm.$("SCFLFN"), vm.$("FNC"), 2];
  }, ""], ["SCOKCL", "DESCR", function () {
    return [vm.$("SCOKFN"), vm.$("FNC"), 2];
  }, ""], ["SCONCL", "DESCR", function () {
    return [vm.$("SCONFN"), vm.$("FNC"), 2];
  }, ""], ["SJSRCL", "DESCR", function () {
    return [vm.$("SJSRFN"), vm.$("FNC"), 3];
  }, ""], ["SPNCCL", "DESCR", function () {
    return [vm.$("SPNCFN"), vm.$("FNC"), 3];
  }, ""], ["SUCFCL", "DESCR", function () {
    return [vm.$("SUCFFN"), vm.$("FNC"), 2];
  }, ""], ["TBCL", "DESCR", function () {
    return [vm.$("TBFN"), vm.$("FNC"), 3];
  }, ""], ["INITB", "DESCR", function () {
    return [vm.$("ABNDB"), 0, 0];
  }, ""], ["INITE", "DESCR", function () {
    return [vm.$("DTEND") + vm.$("DESCR"), 0, 0];
  }, ""], ["A4PTR", "DESCR", function () {
    return [0, 0, 0];
  }, "Scratch descriptor"], ["A5PTR", "DESCR", function () {
    return [0, 0, 0];
  }, "Scratch descriptor"], ["A6PTR", "DESCR", function () {
    return [0, 0, 0];
  }, "Scratch descriptor"], ["A7PTR", "DESCR", function () {
    return [0, 0, 0];
  }, "Scratch descriptor"], ["BRTYPE", "DESCR", function () {
    return [0, 0, 0];
  }, "Break type returned by FORWRD"], ["CMOFCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Compiler offset"], ["DATSEG", "DESCR", function () {
    return [0, 0, 100];
  }, "Beginning of defined data types"], ["DMPPTR", "DESCR", function () {
    return [0, 0, 0];
  }, "Bin pointer for DUMP"], ["DTCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Data type descriptor"], ["DT1CL", "DESCR", function () {
    return [0, 0, 0];
  }, "Data type descriptor"], ["EMSGCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Present error message address"], ["ERRBAS", "DESCR", function () {
    return [vm.$("CARDSZ") + (vm.$("STNOSZ") - vm.$("SEQSIZ")), 0, 0];
  }, ""], ["ESAICL", "DESCR", function () {
    return [0, 0, 0];
  }, "Count of compiler errors"], ["ETMCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Time descriptor"], ["FCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Real number descriptor"], ["NEXFCL", "DESCR", function () {
    return [vm.$("FBLKSZ"), 0, 0];
  }, "Offset in function block"], ["FRTNCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Failure return"], ["GOGOCL", "DESCR", function () {
    return [0, 0, 0];
  }, "goto descriptor"], ["INCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Global function descriptor"], ["IOKEY", "DESCR", function () {
    return [0, 0, 0];
  }, "I/O indicator"], ["MAXLEN", "DESCR", function () {
    return [0, 0, 0];
  }, "Maximum length for matching"], ["MSGNO", "DESCR", function () {
    return [vm.$("MSGLST"), 0, 0];
  }, "Pointer to error message list"], ["NAMICL", "DESCR", function () {
    return [0, 0, 0];
  }, "Offset on naming list"], ["NHEDCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Name list head offset"], ["NMOVER", "DESCR", function () {
    return [vm.$("NAMLSZ") * vm.$("SPDR"), 0, vm.$("B")];
  }, "Name list end offset"], ["NULVCL", "DESCR", function () {
    return [0, 0, vm.$("S")];
  }, "Null string value"], ["OCICL", "DESCR", function () {
    return [0, 0, 0];
  }, "Object code offset"], ["PATICL", "DESCR", function () {
    return [0, 0, 0];
  }, "Pattern code offset"], ["PDLEND", "DESCR", function () {
    return [vm.$("PDLBLK") + (vm.$("SPDLDR") - vm.$("NODESZ")), 0, 0];
  }, ""], ["PDLPTR", "DESCR", function () {
    return [vm.$("PDLBLK"), 0, 0];
  }, "Pattern history list beginning"], ["SCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Switch descriptor"], ["STKPTR", "DESCR", function () {
    return [vm.$("STACK"), 0, 0];
  }, "Pointer to stack"], ["STYPE", "DESCR", function () {
    return [0, vm.$("FNC"), 0];
  }, "Descriptor return by STREAM"], ["TBLFNC", "DESCR", function () {
    return [0, 0, 0];
  }, "Pointer to last pattern table"], ["UNIT", "DESCR", function () {
    return [0, 0, 0];
  }, "Input unit switch"], ["VARSYM", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["DATCL", "DESCR", function () {
    return [vm.$("DEFDAT"), vm.$("FNC"), 0];
  }, "Defined data objects"], ["DEFCL", "DESCR", function () {
    return [vm.$("DEFFNC"), vm.$("FNC"), 0];
  }, "Defined functions"], ["FLDCL", "DESCR", function () {
    return [vm.$("FIELD"), 0, 1];
  }, "Field of defined data objects"], ["LODCL", "DESCR", function () {
    return [vm.$("LNKFNC"), vm.$("FNC"), 0];
  }, "External functions"], ["PDLHED", "DESCR", function () {
    return [vm.$("PDLBLK"), 0, 0];
  }, "History list head"], ["UNDFCL", "DESCR", function () {
    return [vm.$("UNDF"), vm.$("FNC"), 0];
  }, "Undefined functions"], ["DPSPTR", "DESCR", function () {
    return [vm.$("DPSP"), 0, 0];
  }, ""], ["XSPPTR", "DESCR", function () {
    return [vm.$("XSP"), 0, 0];
  }, ""], ["YSPPTR", "DESCR", function () {
    return [vm.$("YSP"), 0, 0];
  }, ""], ["ZSPPTR", "DESCR", function () {
    return [vm.$("ZSP"), 0, 0];
  }, ""], ["TSPPTR", "DESCR", function () {
    return [vm.$("TSP"), 0, 0];
  }, ""], ["KNATL", "DESCR", function () {
    return [vm.$("KNLIST"), 0, 0];
  }, "Unprotected keyword list"], ["KVATL", "DESCR", function () {
    return [vm.$("KVLIST"), 0, 0];
  }, "Protected keyword list"], ["TRATL", "DESCR", function () {
    return [vm.$("TRLIST"), 0, 0];
  }, "Trace list"], ["BLNSP", "SPEC", function () {
    return [vm.$("BLNBUF"), 0, 0, 0, vm.$("STNOSZ")];
  }, ""], ["ERRSP", "SPEC", function () {
    return [vm.$("ERRBUF"), 0, 0, 0, vm.$("CARDSZ") + (vm.$("STNOSZ") - (vm.$("SEQSIZ") + 1))];
  }, ""], ["INBFSP", "SPEC", function () {
    return [vm.$("INBUF"), 0, 0, vm.$("STNOSZ"), vm.$("CARDSZ")];
  }, ""], ["LNBFSP", "SPEC", function () {
    return [vm.$("INBUF"), 0, 0, 0, vm.$("CARDSZ") + (vm.$("DSTSZ") + 1)];
  }, ""], ["NEXTSP", "SPEC", function () {
    return [vm.$("INBUF"), 0, 0, vm.$("STNOSZ"), vm.$("CARDSZ") - vm.$("SEQSIZ")];
  }, ""], ["LNOSP", "SPEC", function () {
    return [vm.$("INBUF"), 0, 0, 0, vm.$("STNOSZ")];
  }, ""], ["RNOSP", "SPEC", function () {
    return [vm.$("INBUF"), 0, 0, vm.$("CARDSZ") + (vm.$("STNOSZ") + 1), vm.$("STNOSZ")];
  }, ""], ["ALPHSP", "SPEC", function () {
    return [vm.$("ALPHA"), 0, 0, 0, vm.$("ALPHSZ")];
  }, "Alphabet"], ["AMPSP", "SPEC", function () {
    return [vm.$("AMPST"), 0, 0, 0, 1];
  }, "Ampersand"], ["CERRSP", "SPEC", function () {
    return [vm.$("ANYSP"), 0, 0, 0, 0];
  }, "Buffer specifier"], ["COLSP", "SPEC", function () {
    return [vm.$("COLSTR"), 0, 0, 0, 2];
  }, "Colon for trace messages"], ["DMPSP", "SPEC", function () {
    return [vm.$("ANYSP"), 0, 0, 0, 0];
  }, "Buffer specifier"], ["DTARSP", "SPEC", function () {
    return [vm.$("DTARBF"), 0, 0, 0, vm.$("ARRLEN") + 9];
  }, ""], ["PROTSP", "SPEC", function () {
    return [vm.$("ANYSP"), 0, 0, 0, 0];
  }, "Buffer specifier"], ["QTSP", "SPEC", function () {
    return [vm.$("QTSTR"), 0, 0, 0, 1];
  }, "Quote for messages"], ["REALSP", "SPEC", function () {
    return [vm.$("REALBF"), 0, 0, 0, 10];
  }, "Specifier for real conversion"], ["TRACSP", "SPEC", function () {
    return [vm.$("ANYSP"), 0, 0, 0, 0];
  }, "Buffer specifier"], ["ARRSP", "STRING", function () {
    return ["ARRAY"];
  }, ""], ["ASSCSP", "STRING", function () {
    return ["TABLE"];
  }, ""], ["BLSP", "STRING", function () {
    return [" "];
  }, ""], ["BLEQSP", "STRING", function () {
    return [" = "];
  }, ""], ["CMASP", "STRING", function () {
    return [","];
  }, ""], ["EJCTSP", "STRING", function () {
    return ["EJECT"];
  }, ""], ["EQLSP", "STRING", function () {
    return ["= "];
  }, ""], ["ETIMSP", "STRING", function () {
    return [",TIME = "];
  }, ""], ["EXDTSP", "STRING", function () {
    return ["EXTERNAL"];
  }, ""], ["LEFTSP", "STRING", function () {
    return ["LEFT"];
  }, ""], ["LISTSP", "STRING", function () {
    return ["LIST"];
  }, ""], ["LPRNSP", "STRING", function () {
    return ["("];
  }, ""], ["OFSP", "STRING", function () {
    return [" OF "];
  }, ""], ["RPRNSP", "STRING", function () {
    return [")"];
  }, ""], ["STARSP", "STRING", function () {
    return ["*** "];
  }, ""], ["TRCLSP", "STRING", function () {
    return [" CALL OF "];
  }, ""], ["TRLVSP", "STRING", function () {
    return ["LEVEL "];
  }, ""], ["TRSTSP", "STRING", function () {
    return ["    STATEMENT "];
  }, ""], ["UNLSP", "STRING", function () {
    return ["UNLIST"];
  }, ""], ["XFERSP", "STRING", function () {
    return ["TRANSFER TO"];
  }, ""], ["BLNBUF", "BUFFER", function () {
    return [vm.$("STNOSZ")];
  }, "Blanks for statment number field"], ["DTARBF", "BUFFER", function () {
    return [vm.$("ARRLEN") + 7];
  }, "Array representation buffer"], ["ERRBUF", "BUFFER", function () {
    return [vm.$("CARDSZ") + (vm.$("STNOSZ") - (vm.$("SEQSIZ") + 1))];
  }, ""], ["INBUF", "BUFFER", function () {
    return [vm.$("CARDSZ") + (vm.$("DSTSZ") + 1)];
  }, "Card input buffer"], ["REALBF", "BUFFER", function () {
    return [36];
  }, "Buffer for real number conversion"], ["ICLBLK", "DESCR", function () {
    return [vm.$("ICLBLK"), vm.$("TTL") + vm.$("MARK"), vm.$("ICLEND") - (vm.$("ICLBLK") - vm.$("DESCR"))];
  }, ""], ["DTATL", "DESCR", function () {
    return [vm.$("DTLIST"), 0, 0];
  }, "Data type pair list"], ["FNCPL", "DESCR", function () {
    return [vm.$("FNLIST"), 0, 0];
  }, "Function pair list"], ["INATL", "DESCR", function () {
    return [vm.$("INLIST"), 0, 0];
  }, "Input association pair list"], ["OUTATL", "DESCR", function () {
    return [vm.$("OTLIST"), 0, 0];
  }, "Output association pair list"], ["TVALL", "DESCR", function () {
    return [vm.$("TVALPL"), 0, 0];
  }, "Value trace pair list"], [null, "DESCR", function () {
    return [vm.$("VLTRFN"), vm.$("FNC"), 2];
  }, "Default value trace procedure"], ["TLABL", "DESCR", function () {
    return [vm.$("TLABPL"), 0, 0];
  }, "Label trace pair list"], [null, "DESCR", function () {
    return [vm.$("LABTFN"), vm.$("FNC"), 1];
  }, "Default label trace procedure"], ["TFENTL", "DESCR", function () {
    return [vm.$("TFENPL"), 0, 0];
  }, "Call trace pair list"], [null, "DESCR", function () {
    return [vm.$("FNTRFN"), vm.$("FNC"), 2];
  }, "Default call trace procedure"], ["TFEXTL", "DESCR", function () {
    return [vm.$("TFEXPL"), 0, 0];
  }, "Return trace pair list"], [null, "DESCR", function () {
    return [vm.$("FXTRFN"), vm.$("FNC"), 2];
  }, "Default return trace procedure"], ["TKEYL", "DESCR", function () {
    return [vm.$("TKEYPL"), 0, 0];
  }, "Keyword trace pair list"], [null, "DESCR", function () {
    return [vm.$("KEYTFN"), vm.$("FNC"), 1];
  }, "Default keyword trace procedure"], ["A1PTR", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["A2PTR", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["A3PTR", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["ATPTR", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["F1PTR", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["F2PTR", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["IO2PTR", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["IO1PTR", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["LPTR", "DESCR", function () {
    return [0, 0, 0];
  }, "Last label pointer"], ["NVAL", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["IO3PTR", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["IO4PTR", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["TBLCS", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["TMVAL", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["TPTR", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["TCL", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["TSIZ", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["TVAL", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["VVAL", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["WCL", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["WPTR", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["XCL", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["XPTR", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["XSIZ", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["YCL", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["YPTR", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["YSIZ", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["ZCL", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["ZPTR", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["ZSIZ", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["BOSCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Offset of beginning of statement"], ["CMBSCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Compiler code base descriptor"], ["NBSPTR", "DESCR", function () {
    return [0, 0, 0];
  }, "Name list base pointer"], ["FBLOCK", "DESCR", function () {
    return [0, 0, 0];
  }, "Function procedure descriptor block"], ["OCBSCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Interpreter code base descriptor"], ["OCLIM", "DESCR", function () {
    return [0, 0, 0];
  }, "End of object code block"], ["OCSVCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Pointer to basic object code"], ["PATBCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Pattern code base descriptor"], ["SCBSCL", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["SRNCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Success return descriptor"], ["ELEMND", "DESCR", function () {
    return [0, 0, 0];
  }, "Element node"], ["ELEXND", "DESCR", function () {
    return [0, 0, 0];
  }, "Temporary node"], ["ELEYND", "DESCR", function () {
    return [0, 0, 0];
  }, "Temporary node"], ["EXELND", "DESCR", function () {
    return [0, 0, 0];
  }, "Temporary node"], ["EXEXND", "DESCR", function () {
    return [0, 0, 0];
  }, "Temporary node"], ["EXOPCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Operator node"], ["EXOPND", "DESCR", function () {
    return [0, 0, 0];
  }, "Operator node"], ["EXPRND", "DESCR", function () {
    return [0, 0, 0];
  }, "Expression node"], ["FGOND", "DESCR", function () {
    return [0, 0, 0];
  }, "Failure goto node"], ["FORMND", "DESCR", function () {
    return [0, 0, 0];
  }, "Object node"], ["FRNCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Failure return descriptor"], ["GOTOND", "DESCR", function () {
    return [0, 0, 0];
  }, "Goto node"], ["PATND", "DESCR", function () {
    return [0, 0, 0];
  }, "Pattern node"], ["SGOND", "DESCR", function () {
    return [0, 0, 0];
  }, "Success goto node"], ["SUBJND", "DESCR", function () {
    return [0, 0, 0];
  }, "Subject node"], ["DFLFST", "DESCR", function () {
    return [0, 0, 0];
  }, "Default output format"], ["ENDPTR", "DESCR", function () {
    return [0, 0, 0];
  }, "'END'"], ["EXTPTR", "DESCR", function () {
    return [0, 0, 0];
  }, "'EXTERNAL'"], ["FRETCL", "DESCR", function () {
    return [0, 0, 0];
  }, "'FRETURN'"], ["NRETCL", "DESCR", function () {
    return [0, 0, 0];
  }, "'NRETURN'"], ["RETCL", "DESCR", function () {
    return [0, 0, 0];
  }, "'RETURN'"], ["FUNTCL", "DESCR", function () {
    return [0, 0, 0];
  }, "'FUNCTION'"], ["DPSP", "SPEC", function () {
    return [0, 0, 0, 0, 0];
  }, "Data type specifier"], ["HEADSP", "SPEC", function () {
    return [0, 0, 0, 0, 0];
  }, "Matching head specifier"], ["IOSP", "SPEC", function () {
    return [0, 0, 0, 0, 0];
  }, "I/O specifier"], ["TAILSP", "SPEC", function () {
    return [0, 0, 0, 0, 0];
  }, "Matching tail specifier"], ["TEXTSP", "SPEC", function () {
    return [0, 0, 0, 0, 0];
  }, "Compiler statement specifier"], ["TSP", "SPEC", function () {
    return [0, 0, 0, 0, 0];
  }, "Scratch specifier"], ["TXSP", "SPEC", function () {
    return [0, 0, 0, 0, 0];
  }, "Scratch specifier"], ["VSP", "SPEC", function () {
    return [0, 0, 0, 0, 0];
  }, "Scratch specifier"], ["XSP", "SPEC", function () {
    return [0, 0, 0, 0, 0];
  }, "Scratch specifier"], ["YSP", "SPEC", function () {
    return [0, 0, 0, 0, 0];
  }, "Scratch specifier"], ["ZSP", "SPEC", function () {
    return [0, 0, 0, 0, 0];
  }, "Scratch specifier"], ["ARG1CL", "DESCR", function () {
    return [0, 0, 0];
  }, "Scratch descriptor"], ["BUKPTR", "DESCR", function () {
    return [0, vm.$("PTR"), vm.$("S")];
  }, "Bin pointer"], ["LSTPTR", "DESCR", function () {
    return [0, vm.$("PTR"), vm.$("S")];
  }, "Pointer to last structure"], ["AXPTR", "DESCR", function () {
    return [0, 0, 0];
  }, "Allocation size descriptor"], ["SPECR1", "SPEC", function () {
    return [0, 0, 0, 0, 0];
  }, "Scratch specifier"], ["SPECR2", "SPEC", function () {
    return [0, 0, 0, 0, 0];
  }, "Scratch specifier"], ["ICLEND", "LHERE", function () {
    return [null];
  }, "End of basic block"], ["BK1CL", "DESCR", function () {
    return [0, 0, 0];
  }, "Pointer to block being marked"], ["BKDX", "DESCR", function () {
    return [0, 0, 0];
  }, "Offset in block being marked"], ["BKDXU", "DESCR", function () {
    return [0, 0, 0];
  }, "Offset in block"], ["BKLTCL", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["BKPTR", "DESCR", function () {
    return [0, vm.$("PTR"), vm.$("S")];
  }, ""], ["BLOCL", "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["CONVSW", "DESCR", function () {
    return [0, 0, 0];
  }, "CONVAR-GENVAR entry switch"], ["CPYCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Regeneration block pointer"], ["DESCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Regeneration scratch descriptor"], ["EQUVCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Variable identification descriptor"], ["FRDSCL", "DESCR", function () {
    return [4 * vm.$("DESCR"), 0, 0];
  }, ""], ["GCBLK", "DESCR", function () {
    return [vm.$("GCXTTL"), 0, 0];
  }, "Pointer to marking block"], ["GCNO", "DESCR", function () {
    return [0, 0, 0];
  }, "Count of regenerations"], ["GCMPTR", "DESCR", function () {
    return [0, 0, 0];
  }, "Pointer to basic blocks"], ["GCREQ", "DESCR", function () {
    return [0, 0, 0];
  }, "Space required from regeneration"], ["GCGOT", "DESCR", function () {
    return [0, 0, vm.$("I")];
  }, "Space obtained from regeneration"], ["LCPTR", "DESCR", function () {
    return [0, 0, 0];
  }, "Scratch descriptor"], ["MVSGPT", "DESCR", function () {
    return [0, 0, 0];
  }, "Compression boundary pointer"], ["NODPCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Regeneration switch"], ["OBPTR", "DESCR", function () {
    return [vm.$("OBLIST"), vm.$("PTR"), vm.$("S")];
  }, "Pointer to bins"], ["OFSET", "DESCR", function () {
    return [0, 0, 0];
  }, "Offset in block during regeneration"], ["PRMDX", "DESCR", function () {
    return [vm.$("PRMSIZ"), 0, 0];
  }, "Size of basic block list"], ["PRMPTR", "DESCR", function () {
    return [vm.$("PRMTBL"), 0, 0];
  }, "Pointer to list of basic blocks"], ["ST1PTR", "DESCR", function () {
    return [0, vm.$("PTR"), vm.$("S")];
  }, "Regeneration link pointer"], ["ST2PTR", "DESCR", function () {
    return [0, vm.$("PTR"), vm.$("S")];
  }, "Regeneration link pointer"], ["TEMPCL", "DESCR", function () {
    return [0, vm.$("PTR"), 0];
  }, "Scracth descriptor"], ["TOPCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Pointer to block title"], ["TTLCL", "DESCR", function () {
    return [0, 0, 0];
  }, "Pointer to block title"], ["TWOCL", "DESCR", function () {
    return [2 * vm.$("DESCR"), 0, vm.$("B")];
  }, "Size of string to be marked"], ["FRSGPT", "DESCR", function () {
    return [0, vm.$("PTR"), 0];
  }, "Position pointer"], ["HDSGPT", "DESCR", function () {
    return [0, vm.$("PTR"), 0];
  }, "Head of allocated data region"], ["TLSGP1", "DESCR", function () {
    return [0, vm.$("PTR"), 0];
  }, "End of allocated data region"], ["GCXTTL", "DESCR", function () {
    return [vm.$("GCXTTL"), vm.$("TTL") + vm.$("MARK"), vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, "Pointer to block to mark"], [null, "COPY", function () {
    return [vm.$("MDATA")];
  }, "Segment of machine-dependent data"], ["FTABLE", "DESCR", function () {
    return [vm.$("FTABLE"), vm.$("TTL") + vm.$("MARK"), vm.$("FTBLND") - (vm.$("FTABLE") - vm.$("DESCR"))];
  }, ""], ["ANYFN", "DESCR", function () {
    return [vm.$("ANY"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["APLYFN", "DESCR", function () {
    return [vm.$("APPLY"), vm.$("FNC"), 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["ARBOFN", "DESCR", function () {
    return [vm.$("ARBNO"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["ARGFN", "DESCR", function () {
    return [vm.$("ARG"), 0, 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["ARRAFN", "DESCR", function () {
    return [vm.$("ARRAY"), 0, 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["ASSCFN", "DESCR", function () {
    return [vm.$("ASSOC"), 0, 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["BACKFN", "DESCR", function () {
    return [vm.$("BKSPCE"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["BREAFN", "DESCR", function () {
    return [vm.$("BREAK"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["CLEAFN", "DESCR", function () {
    return [vm.$("CLEAR"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["CODEFN", "DESCR", function () {
    return [vm.$("CODER"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["COLEFN", "DESCR", function () {
    return [vm.$("COLECT"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["CNVRFN", "DESCR", function () {
    return [vm.$("CNVRT"), 0, 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["COPYFN", "DESCR", function () {
    return [vm.$("COPY"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["DATFN", "DESCR", function () {
    return [vm.$("DATE"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["DATDFN", "DESCR", function () {
    return [vm.$("DATDEF"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["DEFIFN", "DESCR", function () {
    return [vm.$("DEFINE"), 0, 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["DIFFFN", "DESCR", function () {
    return [vm.$("DIFFER"), 0, 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["DTCHFN", "DESCR", function () {
    return [vm.$("DETACH"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["DTFN", "DESCR", function () {
    return [vm.$("DT"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["DUMPFN", "DESCR", function () {
    return [vm.$("DMP"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["DUPLFN", "DESCR", function () {
    return [vm.$("DUPL"), 0, 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["ENDFFN", "DESCR", function () {
    return [vm.$("ENFILE"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["EQFN", "DESCR", function () {
    return [vm.$("EQ"), 0, 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["EVALFN", "DESCR", function () {
    return [vm.$("EVAL"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["FLDSFN", "DESCR", function () {
    return [vm.$("FIELDS"), 0, 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["GEFN", "DESCR", function () {
    return [vm.$("GE"), 0, 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["GTFN", "DESCR", function () {
    return [vm.$("GT"), 0, 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["IDENFN", "DESCR", function () {
    return [vm.$("IDENT"), 0, 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["INTGFN", "DESCR", function () {
    return [vm.$("INTGER"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["ITEMFN", "DESCR", function () {
    return [vm.$("ITEM"), vm.$("FNC"), 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["LEFN", "DESCR", function () {
    return [vm.$("LE"), 0, 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["LENFN", "DESCR", function () {
    return [vm.$("LEN"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["LGTFN", "DESCR", function () {
    return [vm.$("LGT"), 0, 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["LOADFN", "DESCR", function () {
    return [vm.$("LOAD"), 0, 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["LOCFN", "DESCR", function () {
    return [vm.$("LOCAL"), 0, 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["LTFN", "DESCR", function () {
    return [vm.$("LT"), 0, 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["NEFN", "DESCR", function () {
    return [vm.$("NE"), 0, 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["NOTAFN", "DESCR", function () {
    return [vm.$("NOTANY"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["OPSYFN", "DESCR", function () {
    return [vm.$("OPSYN"), 0, 3];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["POSFN", "DESCR", function () {
    return [vm.$("POS"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["PRINFN", "DESCR", function () {
    return [vm.$("PRINT"), 0, 3];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["PROTFN", "DESCR", function () {
    return [vm.$("PROTO"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["REMDFN", "DESCR", function () {
    return [vm.$("REMDR"), 0, 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["RPLAFN", "DESCR", function () {
    return [vm.$("RPLACE"), 0, 3];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["READFN", "DESCR", function () {
    return [vm.$("READ"), 0, 3];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["REWNFN", "DESCR", function () {
    return [vm.$("REWIND"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["RPOSFN", "DESCR", function () {
    return [vm.$("RPOS"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["RTABFN", "DESCR", function () {
    return [vm.$("RTAB"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["SIZEFN", "DESCR", function () {
    return [vm.$("SIZE"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["SPANFN", "DESCR", function () {
    return [vm.$("SPAN"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["STPTFN", "DESCR", function () {
    return [vm.$("STOPTR"), 0, 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["TABFN", "DESCR", function () {
    return [vm.$("TAB"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["TIMFN", "DESCR", function () {
    return [vm.$("TIME"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["TRCEFN", "DESCR", function () {
    return [vm.$("TRACE"), 0, 4];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["TRIMFN", "DESCR", function () {
    return [vm.$("TRIM"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["UNLDFN", "DESCR", function () {
    return [vm.$("UNLOAD"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["VALFN", "DESCR", function () {
    return [vm.$("FIELD"), 0, 1];
  }, ""], [null, "DESCR", function () {
    return [vm.$("VALBLK"), 0, 0];
  }, ""], ["FTBLND", "LHERE", function () {
    return [null];
  }, ""], ["INITLS", "DESCR", function () {
    return [vm.$("INITLS"), vm.$("TTL") + vm.$("MARK"), 8 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("DTLIST"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("FNLIST"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("INLIST"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("KNLIST"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("KVLIST"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("OTLIST"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("OTSATL"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("TRLIST"), 0, 0];
  }, ""], ["FNLIST", "DESCR", function () {
    return [vm.$("FNLIST"), vm.$("TTL") + vm.$("MARK"), vm.$("FNCPLE") - (vm.$("FNLIST") - vm.$("DESCR"))];
  }, ""], [null, "DESCR", function () {
    return [vm.$("ANYFN"), vm.$("FNC"), 0];
  }, "ANY(CS)"], [null, "DESCR", function () {
    return [vm.$("ANYSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("APLYFN"), vm.$("FNC"), 0];
  }, "APPLY(F,A1,...,AN)"], [null, "DESCR", function () {
    return [vm.$("APLYSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("ARBOFN"), vm.$("FNC"), 0];
  }, "ARBNO(P)"], [null, "DESCR", function () {
    return [vm.$("ARBNSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("ARGFN"), vm.$("FNC"), 0];
  }, "ARG(F,N)"], [null, "DESCR", function () {
    return [vm.$("ARGSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("ARRAFN"), vm.$("FNC"), 0];
  }, "ARRAY(P,V)"], [null, "DESCR", function () {
    return [vm.$("ARRSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("BACKFN"), vm.$("FNC"), 0];
  }, "BACKSPACE(N)"], [null, "DESCR", function () {
    return [vm.$("BACKSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("BREAFN"), vm.$("FNC"), 0];
  }, "BREAK(CS)"], [null, "DESCR", function () {
    return [vm.$("BRKSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("CLEAFN"), vm.$("FNC"), 0];
  }, "CLEAR()"], [null, "DESCR", function () {
    return [vm.$("CLERSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("CODEFN"), vm.$("FNC"), 0];
  }, "CODE(S)"], [null, "DESCR", function () {
    return [vm.$("CODESP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("COLEFN"), vm.$("FNC"), 0];
  }, "COLLECT(N)"], [null, "DESCR", function () {
    return [vm.$("CLSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("CNVRFN"), vm.$("FNC"), 0];
  }, "CONVERT(V,DT)"], [null, "DESCR", function () {
    return [vm.$("CNVTSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("COPYFN"), vm.$("FNC"), 0];
  }, "COPY(V)"], [null, "DESCR", function () {
    return [vm.$("COPYSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("DATDFN"), vm.$("FNC"), 0];
  }, "DATA(P)"], [null, "DESCR", function () {
    return [vm.$("DATASP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("DATFN"), vm.$("FNC"), 0];
  }, "E3.0.5"], [null, "DESCR", function () {
    return [vm.$("DATSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("DEFIFN"), vm.$("FNC"), 0];
  }, "DEFINE(P,L)"], [null, "DESCR", function () {
    return [vm.$("DEFISP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("DIFFFN"), vm.$("FNC"), 0];
  }, "DIFFER(V1,V2)"], [null, "DESCR", function () {
    return [vm.$("DIFFSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("DTCHFN"), vm.$("FNC"), 0];
  }, "DETACH(V)"], [null, "DESCR", function () {
    return [vm.$("DTCHSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("DTFN"), vm.$("FNC"), 0];
  }, "DATATYPE(V)"], [null, "DESCR", function () {
    return [vm.$("DTSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("DUMPFN"), vm.$("FNC"), 0];
  }, "DUMP()"], [null, "DESCR", function () {
    return [vm.$("DUMPSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("DUPLFN"), vm.$("FNC"), 0];
  }, "DUPL(S,N)"], [null, "DESCR", function () {
    return [vm.$("DUPLSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("ENDFFN"), vm.$("FNC"), 0];
  }, "ENDFILE(N)"], [null, "DESCR", function () {
    return [vm.$("ENDFSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("EQFN"), vm.$("FNC"), 0];
  }, "EQ(I1,I2)"], [null, "DESCR", function () {
    return [vm.$("EQSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("EVALFN"), vm.$("FNC"), 0];
  }, "EVAL(E)"], [null, "DESCR", function () {
    return [vm.$("EVALSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("FLDSFN"), vm.$("FNC"), 0];
  }, "FIELD(V,N)"], [null, "DESCR", function () {
    return [vm.$("FLDSSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("GEFN"), vm.$("FNC"), 0];
  }, "GE(I1,I2)"], [null, "DESCR", function () {
    return [vm.$("GESP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("GTFN"), vm.$("FNC"), 0];
  }, "GT(I1,I2)"], [null, "DESCR", function () {
    return [vm.$("GTSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("IDENFN"), vm.$("FNC"), 0];
  }, "IDENT(V1,V2)"], [null, "DESCR", function () {
    return [vm.$("IDENSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("READFN"), vm.$("FNC"), 0];
  }, "INPUT(V,N,L)"], [null, "DESCR", function () {
    return [vm.$("INSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("INTGFN"), vm.$("FNC"), 0];
  }, "INTEGER(V)"], [null, "DESCR", function () {
    return [vm.$("INTGSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("ITEMFN"), vm.$("FNC"), 0];
  }, "ITEM(A,I1,...,IN)"], [null, "DESCR", function () {
    return [vm.$("ITEMSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("LENFN"), vm.$("FNC"), 0];
  }, "LEN(N)"], [null, "DESCR", function () {
    return [vm.$("LENSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("LEFN"), vm.$("FNC"), 0];
  }, "LE(I1,I2)"], [null, "DESCR", function () {
    return [vm.$("LESP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("LGTFN"), vm.$("FNC"), 0];
  }, "LGT(S1,S2)"], [null, "DESCR", function () {
    return [vm.$("LGTSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("LOADFN"), vm.$("FNC"), 0];
  }, "LOAD(P)"], [null, "DESCR", function () {
    return [vm.$("LOADSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("LOCFN"), vm.$("FNC"), 0];
  }, "LOCAL(F,N)"], [null, "DESCR", function () {
    return [vm.$("LOCSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("LTFN"), vm.$("FNC"), 0];
  }, "LT(I1,I2)"], [null, "DESCR", function () {
    return [vm.$("LTSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("NEFN"), vm.$("FNC"), 0];
  }, "NE(I1,I2)"], [null, "DESCR", function () {
    return [vm.$("NESP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("NOTAFN"), vm.$("FNC"), 0];
  }, "NOTANY(CS)"], [null, "DESCR", function () {
    return [vm.$("NNYSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("OPSYFN"), vm.$("FNC"), 0];
  }, "OPSYN(F1,F2,N)"], [null, "DESCR", function () {
    return [vm.$("OPSNSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("PRINFN"), vm.$("FNC"), 0];
  }, "OUTPUT(V,N,F)"], [null, "DESCR", function () {
    return [vm.$("OUTSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("POSFN"), vm.$("FNC"), 0];
  }, "POS(N)"], [null, "DESCR", function () {
    return [vm.$("POSSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("PROTFN"), vm.$("FNC"), 0];
  }, "PROTOTYPE(A)"], [null, "DESCR", function () {
    return [vm.$("PRTSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("REMDFN"), vm.$("FNC"), 0];
  }, "REMDR(N,M)"], [null, "DESCR", function () {
    return [vm.$("REMDSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("REWNFN"), vm.$("FNC"), 0];
  }, "REWIND(N)"], [null, "DESCR", function () {
    return [vm.$("REWNSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("RPLAFN"), vm.$("FNC"), 0];
  }, "REPLACE(S,CS1,CS2)"], [null, "DESCR", function () {
    return [vm.$("RPLCSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("RPOSFN"), vm.$("FNC"), 0];
  }, "RPOS(N)"], [null, "DESCR", function () {
    return [vm.$("RPOSSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("RTABFN"), vm.$("FNC"), 0];
  }, "RTAB(N)"], [null, "DESCR", function () {
    return [vm.$("RTABSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("SIZEFN"), vm.$("FNC"), 0];
  }, "SIZE(S)"], [null, "DESCR", function () {
    return [vm.$("SIZESP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("SPANFN"), vm.$("FNC"), 0];
  }, "SPAN(CS)"], [null, "DESCR", function () {
    return [vm.$("SPANSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("STPTFN"), vm.$("FNC"), 0];
  }, "STOPTR(V,R)"], [null, "DESCR", function () {
    return [vm.$("STPTSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("TABFN"), vm.$("FNC"), 0];
  }, "TAB(N)"], [null, "DESCR", function () {
    return [vm.$("TABSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("ASSCFN"), vm.$("FNC"), 0];
  }, "TABLE(N,M)"], [null, "DESCR", function () {
    return [vm.$("ASSCSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("TIMFN"), vm.$("FNC"), 0];
  }, "TIME()"], [null, "DESCR", function () {
    return [vm.$("TIMSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("TRCEFN"), vm.$("FNC"), 0];
  }, "TRACE(V,R,T,F)"], [null, "DESCR", function () {
    return [vm.$("TRCESP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("TRIMFN"), vm.$("FNC"), 0];
  }, "TRIM(S)"], [null, "DESCR", function () {
    return [vm.$("TRMSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("UNLDFN"), vm.$("FNC"), 0];
  }, "UNLOAD(S)"], [null, "DESCR", function () {
    return [vm.$("UNLDSP"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("VALFN"), vm.$("FNC"), 0];
  }, "VALUE(S)"], [null, "DESCR", function () {
    return [vm.$("VALSP"), 0, 0];
  }, ""], [null, "ARRAY", function () {
    return [10 * 2];
  }, "Space for 10 more functions"], ["FNCPLE", "LHERE", function () {
    return [null];
  }, "End of function pair list"], ["OPTBL", "DESCR", function () {
    return [vm.$("OPTBL"), vm.$("TTL") + vm.$("MARK"), vm.$("OPTBND") - (vm.$("OPTBL") - vm.$("DESCR"))];
  }, ""], ["ADDFN", "DESCR", function () {
    return [vm.$("ADD"), 0, 2];
  }, "X + Y    addition"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [30, 0, 29];
  }, ""], ["BIAMFN", "DESCR", function () {
    return [vm.$("UNDF"), vm.$("FNC"), 0];
  }, "X & Y    definable"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [5, 0, 4];
  }, ""], ["BIATFN", "DESCR", function () {
    return [vm.$("UNDF"), vm.$("FNC"), 0];
  }, "X @ Y    definable"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [25, 0, 24];
  }, ""], ["BINGFN", "DESCR", function () {
    return [vm.$("UNDF"), vm.$("FNC"), 0];
  }, "X \\ Y    definable"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [70, 0, 70];
  }, ""], ["BIPDFN", "DESCR", function () {
    return [vm.$("UNDF"), vm.$("FNC"), 0];
  }, "X # Y    definable"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [35, 0, 34];
  }, ""], ["BIPRFN", "DESCR", function () {
    return [vm.$("UNDF"), vm.$("FNC"), 0];
  }, "X % Y    definable"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [45, 0, 44];
  }, ""], ["BIQSFN", "DESCR", function () {
    return [vm.$("UNDF"), vm.$("FNC"), 0];
  }, "X ? Y    definable"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [70, 0, 69];
  }, ""], ["CONFN", "DESCR", function () {
    return [vm.$("CON"), 0, 2];
  }, "X   Y    concatenation"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [20, 0, 19];
  }, ""], ["DIVFN", "DESCR", function () {
    return [vm.$("DIV"), 0, 2];
  }, "X / Y    division"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [40, 0, 39];
  }, ""], ["DOLFN", "DESCR", function () {
    return [vm.$("DOL"), 0, 2];
  }, "X $ Y    immediate naming"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [60, 0, 59];
  }, ""], ["EXPFN", "DESCR", function () {
    return [vm.$("EXP"), 0, 2];
  }, "X ** Y   exponentiation"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [50, 0, 50];
  }, ""], ["MPYFN", "DESCR", function () {
    return [vm.$("MPY"), 0, 2];
  }, "X * Y    multiplication"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [42, 0, 41];
  }, ""], ["NAMFN", "DESCR", function () {
    return [vm.$("NAM"), 0, 2];
  }, "X . Y    naming"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [60, 0, 59];
  }, ""], ["ORFN", "DESCR", function () {
    return [vm.$("OR"), 0, 2];
  }, "X | Y    alternation"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [10, 0, 9];
  }, ""], ["SUBFN", "DESCR", function () {
    return [vm.$("SUB"), 0, 2];
  }, "X - Y    subtraction"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [30, 0, 29];
  }, ""], ["AROWFN", "DESCR", function () {
    return [vm.$("UNDF"), vm.$("FNC"), 0];
  }, "!X\t    definable"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["ATFN", "DESCR", function () {
    return [vm.$("ATOP"), 0, 1];
  }, "@X\t    scanner position"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["BARFN", "DESCR", function () {
    return [vm.$("UNDF"), vm.$("FNC"), 0];
  }, "|X\t    definable"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["DOTFN", "DESCR", function () {
    return [vm.$("NAME"), 0, 1];
  }, ".X\t    name"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["INDFN", "DESCR", function () {
    return [vm.$("IND"), 0, 1];
  }, "$X\t    indirect reference"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["KEYFN", "DESCR", function () {
    return [vm.$("KEYWRD"), 0, 1];
  }, "&X\t    keyword"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["MNSFN", "DESCR", function () {
    return [vm.$("MNS"), 0, 1];
  }, "-X\t    minus"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["NEGFN", "DESCR", function () {
    return [vm.$("NEG"), 0, 1];
  }, "\\X\t    negation"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["PDFN", "DESCR", function () {
    return [vm.$("UNDF"), vm.$("FNC"), 0];
  }, "#X\t    definable"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["PLSFN", "DESCR", function () {
    return [vm.$("PLS"), 0, 1];
  }, "+X\t    plus"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["PRFN", "DESCR", function () {
    return [vm.$("UNDF"), vm.$("FNC"), 0];
  }, "%X\t    definable"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["QUESFN", "DESCR", function () {
    return [vm.$("QUES"), 0, 1];
  }, "?X\t    interrogation"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["SLHFN", "DESCR", function () {
    return [vm.$("UNDF"), vm.$("FNC"), 0];
  }, "/X\t    definable"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["STRFN", "DESCR", function () {
    return [vm.$("STR"), 0, 1];
  }, "*X\t    unevaluated expression"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["OPTBND", "LHERE", function () {
    return [null];
  }, "End of operator table"], ["AREFN", "DESCR", function () {
    return [vm.$("ITEM"), vm.$("FNC"), 1];
  }, "Array or table reference"], ["ASGNFN", "DESCR", function () {
    return [vm.$("ASGN"), 0, 2];
  }, "X = Y"], ["BASEFN", "DESCR", function () {
    return [vm.$("BASE"), 0, 0];
  }, "Base object code"], ["ENDAFN", "DESCR", function () {
    return [vm.$("ARGNER"), 0, 0];
  }, "Safety exit on trace psuedo-code"], ["ENDFN", "DESCR", function () {
    return [vm.$("END"), 0, 0];
  }, "End of program"], ["ERORFN", "DESCR", function () {
    return [vm.$("EROR"), 0, 1];
  }, "Erroneous statement"], ["FNTRFN", "DESCR", function () {
    return [vm.$("FENTR"), 0, 2];
  }, "Call tracing"], ["FXTRFN", "DESCR", function () {
    return [vm.$("FNEXTR"), 0, 2];
  }, "Return tracing"], ["GOTGFN", "DESCR", function () {
    return [vm.$("GOTG"), 0, 1];
  }, ":<X>"], ["GOTLFN", "DESCR", function () {
    return [vm.$("GOTL"), 0, 1];
  }, ":(L)"], ["GOTOFN", "DESCR", function () {
    return [vm.$("GOTO"), 0, 1];
  }, "Internal goto"], ["INITFN", "DESCR", function () {
    return [vm.$("INIT"), 0, 1];
  }, "Statement initialization"], ["KEYTFN", "DESCR", function () {
    return [vm.$("KEYTR"), 0, 2];
  }, "Keyword tracing"], ["LABTFN", "DESCR", function () {
    return [vm.$("LABTR"), 0, 2];
  }, "Label tracing"], ["LITFN", "DESCR", function () {
    return [vm.$("LIT"), 0, 1];
  }, "Literal evaluation"], ["SCANFN", "DESCR", function () {
    return [vm.$("SCAN"), 0, 2];
  }, "Pattern matching"], ["SJSRFN", "DESCR", function () {
    return [vm.$("SJSR"), 0, 3];
  }, "Pattern matching with replacement"], ["VLTRFN", "DESCR", function () {
    return [vm.$("VALTR"), 0, 2];
  }, "Value tracing"], ["ANYCFN", "DESCR", function () {
    return [vm.$("ANYC"), 0, 3];
  }, "Matching for ANY(S)"], ["ARBFFN", "DESCR", function () {
    return [vm.$("ARBF"), 0, 2];
  }, "Failure for ARB"], ["ARBNFN", "DESCR", function () {
    return [vm.$("ARBN"), 0, 2];
  }, "Matching for ARBNO(P)"], ["ATOPFN", "DESCR", function () {
    return [vm.$("ATP"), 0, 3];
  }, "Matching for @X"], ["CHRFN", "DESCR", function () {
    return [vm.$("CHR"), 0, 3];
  }, "Matching for string"], ["BALFN", "DESCR", function () {
    return [vm.$("BAL"), 0, 2];
  }, "Matching for BAL"], ["BALFFN", "DESCR", function () {
    return [vm.$("BALF"), 0, 2];
  }, "Failure for BAL"], ["BRKCFN", "DESCR", function () {
    return [vm.$("BRKC"), 0, 3];
  }, "Matching for BREAK(S)"], ["DNMEFN", "DESCR", function () {
    return [vm.$("DNME"), 0, 2];
  }, ""], ["DNMIFN", "DESCR", function () {
    return [vm.$("DNME1"), 0, 2];
  }, ""], ["EARBFN", "DESCR", function () {
    return [vm.$("EARB"), 0, 2];
  }, ""], ["DSARFN", "DESCR", function () {
    return [vm.$("DSAR"), 0, 3];
  }, ""], ["ENMEFN", "DESCR", function () {
    return [vm.$("ENME"), 0, 3];
  }, ""], ["ENMIFN", "DESCR", function () {
    return [vm.$("ENMI"), 0, 3];
  }, ""], ["FARBFN", "DESCR", function () {
    return [vm.$("FARB"), 0, 2];
  }, ""], ["FNMEFN", "DESCR", function () {
    return [vm.$("FNME"), 0, 2];
  }, ""], ["LNTHFN", "DESCR", function () {
    return [vm.$("LNTH"), 0, 3];
  }, "Matching for LEN(N)"], ["NMEFN", "DESCR", function () {
    return [vm.$("NME"), 0, 2];
  }, ""], ["NNYCFN", "DESCR", function () {
    return [vm.$("NNYC"), 0, 3];
  }, "Matching for NOTANY(S)"], ["ONARFN", "DESCR", function () {
    return [vm.$("ONAR"), 0, 2];
  }, ""], ["ONRFFN", "DESCR", function () {
    return [vm.$("ONRF"), 0, 2];
  }, ""], ["POSIFN", "DESCR", function () {
    return [vm.$("POSI"), 0, 3];
  }, "Matching for POS(N)"], ["RPSIFN", "DESCR", function () {
    return [vm.$("RPSI"), 0, 3];
  }, "Matching for RPOS(N)"], ["RTBFN", "DESCR", function () {
    return [vm.$("RTB"), 0, 3];
  }, "Matching for RTAB(N)"], ["SALFFN", "DESCR", function () {
    return [vm.$("SALF"), 0, 2];
  }, ""], ["SCFLFN", "DESCR", function () {
    return [vm.$("FAIL"), 0, 2];
  }, ""], ["SCOKFN", "DESCR", function () {
    return [vm.$("SCOK"), 0, 2];
  }, "Successful match procedure"], ["SCONFN", "DESCR", function () {
    return [vm.$("SCON"), 0, 2];
  }, ""], ["SPNCFN", "DESCR", function () {
    return [vm.$("SPNC"), 0, 3];
  }, "Matching for SPAN(S)"], ["STARFN", "DESCR", function () {
    return [vm.$("STAR"), 0, 3];
  }, "Matching for *X"], ["TBFN", "DESCR", function () {
    return [vm.$("TB"), 0, 3];
  }, "Matching for TAB(N)"], ["ABORFN", "DESCR", function () {
    return [vm.$("RTNUL3"), 0, 3];
  }, "Matching for ABORT"], ["FNCEFN", "DESCR", function () {
    return [vm.$("FNCE"), 0, 2];
  }, "Matching for FENCE"], ["FNCFFN", "DESCR", function () {
    return [vm.$("RTNUL3"), 0, 2];
  }, "Failure for FENCE"], ["SUCFFN", "DESCR", function () {
    return [vm.$("SUCF"), 0, 2];
  }, "Matching for SUCCEED"], ["ABNDSP", "STRING", function () {
    return ["ABEND"];
  }, ""], ["ABORSP", "STRING", function () {
    return ["ABORT"];
  }, ""], ["ALNMSP", "STRING", function () {
    return ["ALPHABET"];
  }, ""], ["ANCHSP", "STRING", function () {
    return ["ANCHOR"];
  }, ""], ["ANYSP", "STRING", function () {
    return ["ANY"];
  }, ""], ["APLYSP", "STRING", function () {
    return ["APPLY"];
  }, ""], ["ARBSP", "STRING", function () {
    return ["ARB"];
  }, ""], ["ARBNSP", "STRING", function () {
    return ["ARBNO"];
  }, ""], ["ARGSP", "STRING", function () {
    return ["ARG"];
  }, ""], ["BACKSP", "STRING", function () {
    return ["BACKSPACE"];
  }, ""], ["BALSP", "STRING", function () {
    return ["BAL"];
  }, ""], ["BRKSP", "STRING", function () {
    return ["BREAK"];
  }, ""], ["TRFRSP", "STRING", function () {
    return ["CALL"];
  }, ""], ["CLERSP", "STRING", function () {
    return ["CLEAR"];
  }, ""], ["CODESP", "STRING", function () {
    return ["CODE"];
  }, ""], ["CLSP", "STRING", function () {
    return ["COLLECT"];
  }, ""], ["CNVTSP", "STRING", function () {
    return ["CONVERT"];
  }, ""], ["COPYSP", "STRING", function () {
    return ["COPY"];
  }, ""], ["DATSP", "STRING", function () {
    return ["DATE"];
  }, ""], ["DATASP", "STRING", function () {
    return ["DATA"];
  }, ""], ["DEFISP", "STRING", function () {
    return ["DEFINE"];
  }, ""], ["DIFFSP", "STRING", function () {
    return ["DIFFER"];
  }, ""], ["DTCHSP", "STRING", function () {
    return ["DETACH"];
  }, ""], ["DTSP", "STRING", function () {
    return ["DATATYPE"];
  }, ""], ["DUMPSP", "STRING", function () {
    return ["DUMP"];
  }, ""], ["DUPLSP", "STRING", function () {
    return ["DUPL"];
  }, ""], ["ENDSP", "STRING", function () {
    return ["END"];
  }, ""], ["ENDFSP", "STRING", function () {
    return ["ENDFILE"];
  }, ""], ["EQSP", "STRING", function () {
    return ["EQ"];
  }, ""], ["ERRLSP", "STRING", function () {
    return ["ERRLIMIT"];
  }, ""], ["ERRTSP", "STRING", function () {
    return ["ERRTYPE"];
  }, ""], ["EVALSP", "STRING", function () {
    return ["EVAL"];
  }, ""], ["EXPSP", "STRING", function () {
    return ["EXPRESSION"];
  }, ""], ["FAILSP", "STRING", function () {
    return ["FAIL"];
  }, ""], ["FNCESP", "STRING", function () {
    return ["FENCE"];
  }, ""], ["FLDSSP", "STRING", function () {
    return ["FIELD"];
  }, ""], ["FNCLSP", "STRING", function () {
    return ["FNCLEVEL"];
  }, ""], ["FRETSP", "STRING", function () {
    return ["FRETURN"];
  }, ""], ["FTRCSP", "STRING", function () {
    return ["FTRACE"];
  }, ""], ["FULLSP", "STRING", function () {
    return ["FULLSCAN"];
  }, ""], ["FUNTSP", "STRING", function () {
    return ["FUNCTION"];
  }, ""], ["GESP", "STRING", function () {
    return ["GE"];
  }, ""], ["GTSP", "STRING", function () {
    return ["GT"];
  }, ""], ["IDENSP", "STRING", function () {
    return ["IDENT"];
  }, ""], ["INSP", "STRING", function () {
    return ["INPUT"];
  }, ""], ["INTGSP", "STRING", function () {
    return ["INTEGER"];
  }, ""], ["ITEMSP", "STRING", function () {
    return ["ITEM"];
  }, ""], ["TRKYSP", "STRING", function () {
    return ["KEYWORD"];
  }, ""], ["TRLASP", "STRING", function () {
    return ["LABEL"];
  }, ""], ["LSTNSP", "STRING", function () {
    return ["LASTNO"];
  }, ""], ["LENSP", "STRING", function () {
    return ["LEN"];
  }, ""], ["LESP", "STRING", function () {
    return ["LE"];
  }, ""], ["LGTSP", "STRING", function () {
    return ["LGT"];
  }, ""], ["LOADSP", "STRING", function () {
    return ["LOAD"];
  }, ""], ["LOCSP", "STRING", function () {
    return ["LOCAL"];
  }, ""], ["LTSP", "STRING", function () {
    return ["LT"];
  }, ""], ["MAXLSP", "STRING", function () {
    return ["MAXLNGTH"];
  }, ""], ["NAMESP", "STRING", function () {
    return ["NAME"];
  }, ""], ["NESP", "STRING", function () {
    return ["NE"];
  }, ""], ["NNYSP", "STRING", function () {
    return ["NOTANY"];
  }, ""], ["NRETSP", "STRING", function () {
    return ["NRETURN"];
  }, ""], ["OPSNSP", "STRING", function () {
    return ["OPSYN"];
  }, ""], ["OUTSP", "STRING", function () {
    return ["OUTPUT"];
  }, ""], ["PATSP", "STRING", function () {
    return ["PATTERN"];
  }, ""], ["POSSP", "STRING", function () {
    return ["POS"];
  }, ""], ["PRTSP", "STRING", function () {
    return ["PROTOTYPE"];
  }, ""], ["PNCHSP", "STRING", function () {
    return ["PUNCH"];
  }, ""], ["RLSP", "STRING", function () {
    return ["REAL"];
  }, ""], ["REMSP", "STRING", function () {
    return ["REM"];
  }, ""], ["REMDSP", "STRING", function () {
    return ["REMDR"];
  }, ""], ["RETSP", "STRING", function () {
    return ["RETURN"];
  }, ""], ["REWNSP", "STRING", function () {
    return ["REWIND"];
  }, ""], ["RPLCSP", "STRING", function () {
    return ["REPLACE"];
  }, ""], ["RPOSSP", "STRING", function () {
    return ["RPOS"];
  }, ""], ["RTABSP", "STRING", function () {
    return ["RTAB"];
  }, ""], ["RTYPSP", "STRING", function () {
    return ["RTNTYPE"];
  }, ""], ["SIZESP", "STRING", function () {
    return ["SIZE"];
  }, ""], ["SPANSP", "STRING", function () {
    return ["SPAN"];
  }, ""], ["STCTSP", "STRING", function () {
    return ["STCOUNT"];
  }, ""], ["STFCSP", "STRING", function () {
    return ["STFCOUNT"];
  }, ""], ["STLMSP", "STRING", function () {
    return ["STLIMIT"];
  }, ""], ["STPTSP", "STRING", function () {
    return ["STOPTR"];
  }, ""], ["STNOSP", "STRING", function () {
    return ["STNO"];
  }, ""], ["VARSP", "STRING", function () {
    return ["STRING"];
  }, ""], ["SUCCSP", "STRING", function () {
    return ["SUCCEED"];
  }, ""], ["TABSP", "STRING", function () {
    return ["TAB"];
  }, ""], ["TIMSP", "STRING", function () {
    return ["TIME"];
  }, ""], ["TRCESP", "STRING", function () {
    return ["TRACE"];
  }, ""], ["TRMSP", "STRING", function () {
    return ["TRIM"];
  }, ""], ["UNLDSP", "STRING", function () {
    return ["UNLOAD"];
  }, ""], ["VALSP", "STRING", function () {
    return ["VALUE"];
  }, ""], ["CRDFSP", "STRING", function () {
    return ["(80A1)"];
  }, "Default output format"], ["OUTPSP", "STRING", function () {
    return ["(1X,132A1)"];
  }, "Standard print format"], ["ABNDB", "LHERE", function () {
    return [null];
  }, ""], [null, "DESCR", function () {
    return [vm.$("ALPHSP"), 0, 0];
  }, "&ALPHABET"], [null, "DESCR", function () {
    return [vm.$("ALPHVL"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("CRDFSP"), 0, 0];
  }, "Default output format"], [null, "DESCR", function () {
    return [vm.$("DFLFST"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("EXDTSP"), 0, 0];
  }, "'EXTERNAL'"], [null, "DESCR", function () {
    return [vm.$("EXTPTR"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("ENDSP"), 0, 0];
  }, "'END'"], [null, "DESCR", function () {
    return [vm.$("ENDPTR"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("FRETSP"), 0, 0];
  }, "'FRETURN'"], [null, "DESCR", function () {
    return [vm.$("FRETCL"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("FUNTSP"), 0, 0];
  }, "'FUNCTION'"], [null, "DESCR", function () {
    return [vm.$("FUNTCL"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("NRETSP"), 0, 0];
  }, "'NRETURN'"], [null, "DESCR", function () {
    return [vm.$("NRETCL"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("RETSP"), 0, 0];
  }, "'RETURN'"], ["DTEND", "DESCR", function () {
    return [vm.$("RETCL"), 0, 0];
  }, ""], ["BUFEXT", "EQU", function () {
    return [vm.$("DTEND") - vm.$("ANYSP")];
  }, ""], ["BUFLEN", "EQU", function () {
    return [vm.$("BUFEXT") * vm.$("CPA")];
  }, ""], ["PRMTBL", "DESCR", function () {
    return [vm.$("PRMTBL"), vm.$("TTL") + vm.$("MARK"), vm.$("PRMSIZ")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("DTLIST"), 0, 0];
  }, "Data type pair list"], [null, "DESCR", function () {
    return [vm.$("FNLIST"), 0, 0];
  }, "Function pair list"], [null, "DESCR", function () {
    return [vm.$("FTABLE"), 0, 0];
  }, "Procedure descriptor table"], [null, "DESCR", function () {
    return [vm.$("ICLBLK"), 0, 0];
  }, "Miscellaneous data"], [null, "DESCR", function () {
    return [vm.$("KNLIST"), 0, 0];
  }, "Unprotected keyword pair list"], [null, "DESCR", function () {
    return [vm.$("KVLIST"), 0, 0];
  }, "Protected keyword pair list"], [null, "DESCR", function () {
    return [vm.$("OPTBL"), 0, 0];
  }, "Operator procedure descriptors"], [null, "DESCR", function () {
    return [vm.$("STACK"), 0, 0];
  }, "Interpreter stack"], [null, "DESCR", function () {
    return [vm.$("INLIST"), 0, 0];
  }, "Input association pair list"], [null, "DESCR", function () {
    return [vm.$("OTLIST"), 0, 0];
  }, "Output association pair list"], [null, "DESCR", function () {
    return [vm.$("INSATL"), 0, 0];
  }, "Input block list"], [null, "DESCR", function () {
    return [vm.$("OTSATL"), 0, 0];
  }, "Output block list"], [null, "DESCR", function () {
    return [vm.$("TFENPL"), 0, 0];
  }, "Call trace pair list"], [null, "DESCR", function () {
    return [vm.$("TFEXPL"), 0, 0];
  }, "Return trace pair list"], [null, "DESCR", function () {
    return [vm.$("TKEYPL"), 0, 0];
  }, "Keyword trace pair list"], [null, "DESCR", function () {
    return [vm.$("TLABPL"), 0, 0];
  }, "Label trace pair list"], [null, "DESCR", function () {
    return [vm.$("TRLIST"), 0, 0];
  }, "Trace pair list"], [null, "DESCR", function () {
    return [vm.$("TVALPL"), 0, 0];
  }, "Value trace pair list"], ["PRMTRM", "LHERE", function () {
    return [null];
  }, "End of basic block list"], ["PRMSIZ", "EQU", function () {
    return [vm.$("PRMTRM") - (vm.$("PRMTBL") - vm.$("DESCR"))];
  }, "Size of basic block list"], ["OBLOCK", "DESCR", function () {
    return [vm.$("OBLOCK"), vm.$("TTL") + vm.$("MARK"), vm.$("OBARY") * vm.$("DESCR")];
  }, ""], [null, "ARRAY", function () {
    return [3];
  }, "Pseudo heading"], ["OBSTRT", "ARRAY", function () {
    return [vm.$("OBSIZ")];
  }, "Bin list"], ["OBLIST", "EQU", function () {
    return [vm.$("OBSTRT") - vm.$("LNKFLD")];
  }, "Pseudo link pointer"], ["PDLBLK", "DESCR", function () {
    return [vm.$("PDLBLK"), vm.$("TTL") + vm.$("MARK"), vm.$("SPDLSZ") * vm.$("DESCR")];
  }, ""], [null, "ARRAY", function () {
    return [vm.$("SPDLSZ")];
  }, "Pattern history list"], ["STACK", "DESCR", function () {
    return [vm.$("STACK"), vm.$("TTL") + vm.$("MARK"), vm.$("STSIZE") * vm.$("DESCR")];
  }, ""], [null, "ARRAY", function () {
    return [vm.$("STSIZE")];
  }, "Interpreter stack"], ["ABORPT", "DESCR", function () {
    return [vm.$("ABORPT"), vm.$("TTL") + vm.$("MARK"), 3 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("ABORFN"), vm.$("FNC"), 2];
  }, "ABORT"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["ARBAK", "DESCR", function () {
    return [vm.$("ARBAK"), vm.$("TTL") + vm.$("MARK"), 6 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("ONARFN"), vm.$("FNC"), 2];
  }, ""], [null, "DESCR", function () {
    return [3 * vm.$("DESCR"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("ONRFFN"), vm.$("FNC"), 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["ARBPT", "DESCR", function () {
    return [vm.$("ARBPT"), vm.$("TTL") + vm.$("MARK"), 9 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("SCOKFN"), vm.$("FNC"), 2];
  }, "ARB"], [null, "DESCR", function () {
    return [0, 0, 3 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("SCOKFN"), vm.$("FNC"), 2];
  }, ""], [null, "DESCR", function () {
    return [6 * vm.$("DESCR"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("FARBFN"), vm.$("FNC"), 2];
  }, ""], [null, "DESCR", function () {
    return [6 * vm.$("DESCR"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["ARHED", "DESCR", function () {
    return [vm.$("ARHED"), vm.$("TTL") + vm.$("MARK"), 12 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("SCOKFN"), vm.$("FNC"), 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 3 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("SCOKFN"), vm.$("FNC"), 2];
  }, ""], [null, "DESCR", function () {
    return [6 * vm.$("DESCR"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("ARBNFN"), vm.$("FNC"), 2];
  }, ""], [null, "DESCR", function () {
    return [9 * vm.$("DESCR"), 0, 12 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("ARBFFN"), vm.$("FNC"), 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["ARTAL", "DESCR", function () {
    return [vm.$("ARTAL"), vm.$("TTL") + vm.$("MARK"), 6 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("EARBFN"), vm.$("FNC"), 2];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 3 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("SCOKFN"), vm.$("FNC"), 2];
  }, ""], [null, "DESCR", function () {
    return [6 * vm.$("DESCR"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["BALPT", "DESCR", function () {
    return [vm.$("BALPT"), vm.$("TTL") + vm.$("MARK"), 9 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("SCOKFN"), vm.$("FNC"), 2];
  }, "BAL"], [null, "DESCR", function () {
    return [0, 0, 3 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("BALFN"), vm.$("FNC"), 2];
  }, ""], [null, "DESCR", function () {
    return [6 * vm.$("DESCR"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("BALFFN"), vm.$("FNC"), 2];
  }, ""], [null, "DESCR", function () {
    return [6 * vm.$("DESCR"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["FAILPT", "DESCR", function () {
    return [vm.$("FAILPT"), vm.$("TTL") + vm.$("MARK"), 3 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("SALFFN"), vm.$("FNC"), 2];
  }, "FAIL"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["FNCEPT", "DESCR", function () {
    return [vm.$("FNCEPT"), vm.$("TTL") + vm.$("MARK"), 3 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("FNCEFN"), vm.$("FNC"), 2];
  }, "FENCE"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["REMPT", "DESCR", function () {
    return [vm.$("REMPT"), vm.$("TTL") + vm.$("MARK"), 4 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("RTBFN"), vm.$("FNC"), 3];
  }, "REM"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [0, 0, vm.$("I")];
  }, ""], ["STARPT", "DESCR", function () {
    return [vm.$("STARPT"), vm.$("TTL") + vm.$("MARK"), 11 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("STARFN"), vm.$("FNC"), 3];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 4 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [1, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("SCOKFN"), vm.$("FNC"), 2];
  }, ""], [null, "DESCR", function () {
    return [7 * vm.$("DESCR"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("DSARFN"), vm.$("FNC"), 3];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 4 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["SUCCPT", "DESCR", function () {
    return [vm.$("SUCCPT"), vm.$("TTL") + vm.$("MARK"), 3 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [vm.$("SUCFFN"), vm.$("FNC"), 2];
  }, "SUCCEED"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["TVALPL", "DESCR", function () {
    return [vm.$("TVALPL"), vm.$("TTL") + vm.$("MARK"), 2 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, "VALUE trace"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["TLABPL", "DESCR", function () {
    return [vm.$("TLABPL"), vm.$("TTL") + vm.$("MARK"), 2 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, "LABEL trace"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["TFENPL", "DESCR", function () {
    return [vm.$("TFENPL"), vm.$("TTL") + vm.$("MARK"), 2 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, "CALL trace"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["TFEXPL", "DESCR", function () {
    return [vm.$("TFEXPL"), vm.$("TTL") + vm.$("MARK"), 2 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, "RETURN trace"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["TKEYPL", "DESCR", function () {
    return [vm.$("TKEYPL"), vm.$("TTL") + vm.$("MARK"), 2 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [0, 0, 0];
  }, "KEYWORD trace"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, ""], ["VALBLK", "DESCR", function () {
    return [vm.$("VALBLK"), vm.$("TTL") + vm.$("MARK"), 6 * vm.$("DESCR")];
  }, ""], [null, "DESCR", function () {
    return [0, 0, vm.$("S")];
  }, "STRING"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, "0 offset"], [null, "DESCR", function () {
    return [0, 0, vm.$("N")];
  }, "NAME"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, "0 offset"], [null, "DESCR", function () {
    return [0, 0, vm.$("K")];
  }, "KEYWORD (NAME)"], [null, "DESCR", function () {
    return [0, 0, 0];
  }, "0 offset"], ["MSGLST", "DESCR", function () {
    return [0, 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG1"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG2"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG3"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG4"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG5"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG6"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG7"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG8"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG9"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG10"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG11"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG12"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG13"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG14"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG15"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG16"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG17"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG18"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG19"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG20"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG21"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG22"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG23"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG24"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG25"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG26"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG27"), 0, 0];
  }, ""], [null, "DESCR", function () {
    return [vm.$("MSG28"), 0, 0];
  }, ""], ["MSG1", "STRING", function () {
    return ["ILLEGAL DATA TYPE"];
  }, ""], ["MSG2", "STRING", function () {
    return ["ERROR IN ARITHMETIC OPERATION"];
  }, ""], ["MSG3", "STRING", function () {
    return ["ERRONEOUS ARRAY OR TABLE REFERENCE"];
  }, ""], ["MSG4", "STRING", function () {
    return ["NULL STRING IN ILLEGAL CONTEXT"];
  }, ""], ["MSG5", "STRING", function () {
    return ["UNDEFINED FUNCTION OR OPERATION"];
  }, ""], ["MSG6", "STRING", function () {
    return ["ERRONEOUS PROTOTYPE"];
  }, ""], ["MSG7", "STRING", function () {
    return ["UNKNOWN KEYWORD"];
  }, ""], ["MSG8", "STRING", function () {
    return ["VARIABLE NOT PRESENT WHERE REQUIRED"];
  }, ""], ["MSG9", "STRING", function () {
    return ["ENTRY POINT OF FUNCTION NOT LABEL"];
  }, ""], ["MSG10", "STRING", function () {
    return ["ILLEGAL ARGUMENT TO PRIMITIVE FUNCTION"];
  }, ""], ["MSG11", "STRING", function () {
    return ["READING ERROR"];
  }, ""], ["MSG12", "STRING", function () {
    return ["ILLEGAL I/O UNIT"];
  }, ""], ["MSG13", "STRING", function () {
    return ["LIMIT ON DEFINED DATA TYPES EXCEEDED"];
  }, ""], ["MSG14", "STRING", function () {
    return ["NEGATIVE NUMBER IN ILLEGAL CONTEXT"];
  }, ""], ["MSG15", "STRING", function () {
    return ["STRING OVERFLOW"];
  }, ""], ["MSG16", "STRING", function () {
    return ["OVERFLOW DURING PATTERN MATCHING"];
  }, ""], ["MSG17", "STRING", function () {
    return ["ERROR IN SNOBOL4 SYSTEM"];
  }, ""], ["MSG18", "STRING", function () {
    return ["RETURN FROM LEVEL ZERO"];
  }, ""], ["MSG19", "STRING", function () {
    return ["FAILURE DURING GOTO EVALUATION"];
  }, ""], ["MSG20", "STRING", function () {
    return ["INSUFFICIENT STORAGE TO CONTINUE"];
  }, ""], ["MSG21", "STRING", function () {
    return ["STACK OVERFLOW"];
  }, ""], ["MSG22", "STRING", function () {
    return ["LIMIT ON STATEMENT EXECUTION EXCEEDED"];
  }, ""], ["MSG23", "STRING", function () {
    return ["OBJECT EXCEEDS SIZE LIMIT"];
  }, ""], ["MSG24", "STRING", function () {
    return ["UNDEFINED OR ERRONEOUS GOTO"];
  }, ""], ["MSG25", "STRING", function () {
    return ["INCORRECT NUMBER OF ARGUMENTS"];
  }, ""], ["MSG26", "STRING", function () {
    return ["LIMIT ON COMPILATION ERRORS EXCEEDED"];
  }, ""], ["MSG27", "STRING", function () {
    return ["ERRONEOUS END STATEMENT"];
  }, ""], ["MSG28", "STRING", function () {
    return ["EXECUTION OF STATEMENT WITH COMPILATION ERROR"];
  }, ""], ["EMSG1", "STRING", function () {
    return ["ERRONEOUS LABEL"];
  }, ""], ["EMSG2", "STRING", function () {
    return ["PREVIOUSLY DEFINED LABEL"];
  }, ""], ["EMSG3", "STRING", function () {
    return ["ERRONEOUS SUBJECT"];
  }, ""], ["EMSG14", "STRING", function () {
    return ["ERROR IN GOTO"];
  }, ""], ["ILCHAR", "STRING", function () {
    return ["ILLEGAL CHARACTER IN ELEMENT"];
  }, ""], ["ILLBIN", "STRING", function () {
    return ["BINARY OPERATOR MISSING OR IN ERROR"];
  }, ""], ["ILLBRK", "STRING", function () {
    return ["ERRONEOUS OR MISSING BREAK CHARACTER"];
  }, ""], ["ILLDEC", "STRING", function () {
    return ["ERRONEOUS REAL NUMBER"];
  }, ""], ["ILLEOS", "STRING", function () {
    return ["IMPROPERLY TERMINATED STATEMENT"];
  }, ""], ["ILLINT", "STRING", function () {
    return ["ERRONEOUS INTEGER"];
  }, ""], ["OPNLIT", "STRING", function () {
    return ["UNCLOSED LITERAL"];
  }, ""], ["ALOCFL", "FORMAT", function () {
    return ["(40H0INSUFFICIENT STORAGE FOR INITIALIZATION)"];
  }, "E3.10.6"], ["ARTHNO", "FORMAT", function () {
    return ["(1H0,I15,32H ARITHMETIC OPERATIONS PERFORMED)"];
  }, ""], ["CMTIME", "FORMAT", function () {
    return ["(1H0,I15,21H MS. COMPILATION TIME)"];
  }, ""], ["EJECTF", "FORMAT", function () {
    return ["(1H1)"];
  }, ""], ["ERRCF", "FORMAT", function () {
    return ["(34H0ERRORS DETECTED IN SOURCE PROGRAM/1H1)"];
  }, ""], ["EXNO", "FORMAT", function () {
    return ["(1H0,I15,21H STATEMENTS EXECUTED,,I8,7H FAILED)"];
  }, ""], ["FTLCF", "FORMAT", function () {
    return ["(6H1ERROR,I3,13H IN STATEMENT,I5,9H AT LEVEL,I3)"];
  }, ""], ["INCGCF", "FORMAT", function () {
    return ["(33H1INCOMPLETE STORAGE REGENERATION.)"];
  }, ""], ["INTIME", "FORMAT", function () {
    return ["(1H0,I15,19H MS. EXECUTION TIME)"];
  }, ""], ["LASTSF", "FORMAT", function () {
    return ["(28H LAST STATEMENT EXECUTED WAS,I5)"];
  }, ""], ["NODMPF", "FORMAT", function () {
    return ["(28H1TERMINAL DUMP NOT POSSIBLE.)"];
  }, ""], ["NRMEND", "FORMAT", function () {
    return ["(28H1NORMAL TERMINATION AT LEVEL,I3)"];
  }, ""], ["NVARF", "FORMAT", function () {
    return ["(18H0NATURAL VARIABLES,/1H )"];
  }, ""], ["PKEYF", "FORMAT", function () {
    return ["(21H0UNPROTECTED KEYWORDS/1H )"];
  }, ""], ["PRTOVF", "FORMAT", function () {
    return ["(29H ***PRINT REQUEST TOO LONG***)"];
  }, ""], ["READNO", "FORMAT", function () {
    return ["(1H0,I15,16H READS PERFORMED)"];
  }, ""], ["SCANNO", "FORMAT", function () {
    return ["(1H0,I15,26H PATTERN MATCHES PERFORMED)"];
  }, ""], ["SOURCF", "FORMAT", function () {
    return ["(42H0BELL TELEPHONE LABORATORIES, INCORPORATED,/1H1)"];
  }, ""], ["STATHD", "FORMAT", function () {
    return ["(28H1SNOBOL4 STATISTICS SUMMARY-)"];
  }, ""], ["STDMP", "FORMAT", function () {
    return ["(33H1DUMP OF VARIABLES AT TERMINATION/1H )"];
  }, ""], ["STGENO", "FORMAT", function () {
    return ["(1H0,I15,33H REGENERATIONS OF DYNAMIC STORAGE)"];
  }, ""], ["SUCCF", "FORMAT", function () {
    return ["(37H0NO ERRORS DETECTED IN SOURCE PROGRAM/1H1)"];
  }, ""], ["SYSCMT", "FORMAT", function () {
    return ["(27H0CUT BY SYSTEM IN STATEMENT,I5,9H AT LEVEL,I3)"];
  }, ""], ["TIMEPS", "FORMAT", function () {
    return ["(1H0,F15.2,35H MS. AVERAGE PER STATEMENT EXECUTED/1H1)"];
  }, ""], ["TITLEF", "FORMAT", function () {
    return ["(37H1SNOBOL4 (VERSION 3.11, MAY 19, 1975)/8H+_______)"];
  }, ""], ["WRITNO", "FORMAT", function () {
    return ["(1H0,I15,17H WRITES PERFORMED)"];
  }, ""]];
};
